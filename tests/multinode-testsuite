#! /bin/sh
# Generated from multinode-testsuite.at by GNU Autoconf 2.71.
#
# Copyright (C) 2009-2017, 2020-2021 Free Software Foundation, Inc.
#
# This test suite is free software; the Free Software Foundation gives
# unlimited permission to copy, distribute and modify it.
#
# Copyright (c) 2022 Red Hat,
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
## -------------------- ##
## M4sh Initialization. ##
## -------------------- ##

# Be more Bourne compatible
DUALCASE=1; export DUALCASE # for MKS sh
as_nop=:
if test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1
then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else $as_nop
  case `(set -o) 2>/dev/null` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi



# Reset variables that may have inherited troublesome values from
# the environment.

# IFS needs to be set, to space, tab, and newline, in precisely that order.
# (If _AS_PATH_WALK were called with IFS unset, it would have the
# side effect of setting IFS to empty, thus disabling word splitting.)
# Quoting is to prevent editors from complaining about space-tab.
as_nl='
'
export as_nl
IFS=" ""	$as_nl"

PS1='$ '
PS2='> '
PS4='+ '

# Ensure predictable behavior from utilities with locale-dependent output.
LC_ALL=C
export LC_ALL
LANGUAGE=C
export LANGUAGE

# We cannot yet rely on "unset" to work, but we need these variables
# to be unset--not just set to an empty or harmless value--now, to
# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct
# also avoids known problems related to "unset" and subshell syntax
# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).
for as_var in BASH_ENV ENV MAIL MAILPATH CDPATH
do eval test \${$as_var+y} \
  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
done

# Ensure that fds 0, 1, and 2 are open.
if (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi
if (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi
if (exec 3>&2)            ; then :; else exec 2>/dev/null; fi

# The user is always right.
if ${PATH_SEPARATOR+false} :; then
  PATH_SEPARATOR=:
  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
      PATH_SEPARATOR=';'
  }
fi


# Find who we are.  Look in the path if we contain no directory separator.
as_myself=
case $0 in #((
  *[\\/]* ) as_myself=$0 ;;
  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  case $as_dir in #(((
    '') as_dir=./ ;;
    */) ;;
    *) as_dir=$as_dir/ ;;
  esac
    test -r "$as_dir$0" && as_myself=$as_dir$0 && break
  done
IFS=$as_save_IFS

     ;;
esac
# We did not find ourselves, most probably we were run as `sh COMMAND'
# in which case we are not to be found in the path.
if test "x$as_myself" = x; then
  as_myself=$0
fi
if test ! -f "$as_myself"; then
  printf "%s\n" "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
  exit 1
fi


if test "x$CONFIG_SHELL" = x; then
  as_bourne_compatible="as_nop=:
if test \${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1
then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '\${1+\"\$@\"}'='\"\$@\"'
  setopt NO_GLOB_SUBST
else \$as_nop
  case \`(set -o) 2>/dev/null\` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi
"
  as_required="as_fn_return () { (exit \$1); }
as_fn_success () { as_fn_return 0; }
as_fn_failure () { as_fn_return 1; }
as_fn_ret_success () { return 0; }
as_fn_ret_failure () { return 1; }

exitcode=0
as_fn_success || { exitcode=1; echo as_fn_success failed.; }
as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
if ( set x; as_fn_ret_success y && test x = \"\$1\" )
then :

else \$as_nop
  exitcode=1; echo positional parameters were not saved.
fi
test x\$exitcode = x0 || exit 1
blah=\$(echo \$(echo blah))
test x\"\$blah\" = xblah || exit 1
test -x / || exit 1"
  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
test \$(( 1 + 1 )) = 2 || exit 1"
  if (eval "$as_required") 2>/dev/null
then :
  as_have_required=yes
else $as_nop
  as_have_required=no
fi
  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null
then :

else $as_nop
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
as_found=false
for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
do
  IFS=$as_save_IFS
  case $as_dir in #(((
    '') as_dir=./ ;;
    */) ;;
    *) as_dir=$as_dir/ ;;
  esac
  as_found=:
  case $as_dir in #(
	 /*)
	   for as_base in sh bash ksh sh5; do
	     # Try only shells that exist, to save several forks.
	     as_shell=$as_dir$as_base
	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
		    as_run=a "$as_shell" -c "$as_bourne_compatible""$as_required" 2>/dev/null
then :
  CONFIG_SHELL=$as_shell as_have_required=yes
		   if as_run=a "$as_shell" -c "$as_bourne_compatible""$as_suggested" 2>/dev/null
then :
  break 2
fi
fi
	   done;;
       esac
  as_found=false
done
IFS=$as_save_IFS
if $as_found
then :

else $as_nop
  if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
	      as_run=a "$SHELL" -c "$as_bourne_compatible""$as_required" 2>/dev/null
then :
  CONFIG_SHELL=$SHELL as_have_required=yes
fi
fi


      if test "x$CONFIG_SHELL" != x
then :
  export CONFIG_SHELL
             # We cannot yet assume a decent shell, so we have to provide a
# neutralization value for shells without unset; and this also
# works around shells that cannot unset nonexistent variables.
# Preserve -v and -x to the replacement shell.
BASH_ENV=/dev/null
ENV=/dev/null
(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
case $- in # ((((
  *v*x* | *x*v* ) as_opts=-vx ;;
  *v* ) as_opts=-v ;;
  *x* ) as_opts=-x ;;
  * ) as_opts= ;;
esac
exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
# Admittedly, this is quite paranoid, since all the known shells bail
# out after a failed `exec'.
printf "%s\n" "$0: could not re-execute with $CONFIG_SHELL" >&2
exit 255
fi

    if test x$as_have_required = xno
then :
  printf "%s\n" "$0: This script requires a shell more modern than all"
  printf "%s\n" "$0: the shells that I found on your system."
  if test ${ZSH_VERSION+y} ; then
    printf "%s\n" "$0: In particular, zsh $ZSH_VERSION has bugs and should"
    printf "%s\n" "$0: be upgraded to zsh 4.3.4 or later."
  else
    printf "%s\n" "$0: Please tell bug-autoconf@gnu.org about your system,
$0: including any error possibly output before this
$0: message. Then install a modern shell, or manually run
$0: the script under such a shell if you do have one."
  fi
  exit 1
fi
fi
fi
SHELL=${CONFIG_SHELL-/bin/sh}
export SHELL
# Unset more variables known to interfere with behavior of common tools.
CLICOLOR_FORCE= GREP_OPTIONS=
unset CLICOLOR_FORCE GREP_OPTIONS

## --------------------- ##
## M4sh Shell Functions. ##
## --------------------- ##
# as_fn_unset VAR
# ---------------
# Portably unset VAR.
as_fn_unset ()
{
  { eval $1=; unset $1;}
}
as_unset=as_fn_unset


# as_fn_set_status STATUS
# -----------------------
# Set $? to STATUS, without forking.
as_fn_set_status ()
{
  return $1
} # as_fn_set_status

# as_fn_exit STATUS
# -----------------
# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
as_fn_exit ()
{
  set +e
  as_fn_set_status $1
  exit $1
} # as_fn_exit
# as_fn_nop
# ---------
# Do nothing but, unlike ":", preserve the value of $?.
as_fn_nop ()
{
  return $?
}
as_nop=as_fn_nop

# as_fn_mkdir_p
# -------------
# Create "$as_dir" as a directory, including parents if necessary.
as_fn_mkdir_p ()
{

  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || eval $as_mkdir_p || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`printf "%s\n" "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
printf "%s\n" X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"


} # as_fn_mkdir_p

# as_fn_executable_p FILE
# -----------------------
# Test if FILE is an executable regular file.
as_fn_executable_p ()
{
  test -f "$1" && test -x "$1"
} # as_fn_executable_p
# as_fn_append VAR VALUE
# ----------------------
# Append the text in VALUE to the end of the definition contained in VAR. Take
# advantage of any shell optimizations that allow amortized linear growth over
# repeated appends, instead of the typical quadratic growth present in naive
# implementations.
if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null
then :
  eval 'as_fn_append ()
  {
    eval $1+=\$2
  }'
else $as_nop
  as_fn_append ()
  {
    eval $1=\$$1\$2
  }
fi # as_fn_append

# as_fn_arith ARG...
# ------------------
# Perform arithmetic evaluation on the ARGs, and store the result in the
# global $as_val. Take advantage of shells that can avoid forks. The arguments
# must be portable across $(()) and expr.
if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null
then :
  eval 'as_fn_arith ()
  {
    as_val=$(( $* ))
  }'
else $as_nop
  as_fn_arith ()
  {
    as_val=`expr "$@" || test $? -eq 1`
  }
fi # as_fn_arith


# as_fn_error STATUS ERROR [LINENO LOG_FD]
# ----------------------------------------
# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
# script with STATUS, using 1 if that was 0.
as_fn_error ()
{
  as_status=$1; test $as_status -eq 0 && as_status=1
  if test "$4"; then
    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
    printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
  fi
  printf "%s\n" "$as_me: error: $2" >&2
  as_fn_exit $as_status
} # as_fn_error

if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi

as_me=`$as_basename -- "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
printf "%s\n" X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`

if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
  as_dirname=dirname
else
  as_dirname=false
fi

# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits


  as_lineno_1=$LINENO as_lineno_1a=$LINENO
  as_lineno_2=$LINENO as_lineno_2a=$LINENO
  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
  sed -n '
    p
    /[$]LINENO/=
  ' <$as_myself |
    sed '
      s/[$]LINENO.*/&-/
      t lineno
      b
      :lineno
      N
      :loop
      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
      t loop
      s/-\n.*//
    ' >$as_me.lineno &&
  chmod +x "$as_me.lineno" ||
    { printf "%s\n" "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }

  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
  # already done that, so ensure we don't try to do so again and fall
  # in an infinite loop.  This has already happened in practice.
  _as_can_reexec=no; export _as_can_reexec
  # Don't try to exec as it changes $[0], causing all sort of problems
  # (the dirname of $[0] is not the place where we might find the
  # original and so on.  Autoconf is especially sensitive to this).
  . "./$as_me.lineno"
  # Exit status is that of the last command.
  exit
}


# Determine whether it's possible to make 'echo' print without a newline.
# These variables are no longer used directly by Autoconf, but are AC_SUBSTed
# for compatibility with existing Makefiles.
ECHO_C= ECHO_N= ECHO_T=
case `echo -n x` in #(((((
-n*)
  case `echo 'xy\c'` in
  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
  xy)  ECHO_C='\c';;
  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
       ECHO_T='	';;
  esac;;
*)
  ECHO_N='-n';;
esac

# For backward compatibility with old third-party macros, we provide
# the shell variables $as_echo and $as_echo_n.  New code should use
# AS_ECHO(["message"]) and AS_ECHO_N(["message"]), respectively.
as_echo='printf %s\n'
as_echo_n='printf %s'


rm -f conf$$ conf$$.exe conf$$.file
if test -d conf$$.dir; then
  rm -f conf$$.dir/conf$$.file
else
  rm -f conf$$.dir
  mkdir conf$$.dir 2>/dev/null
fi
if (echo >conf$$.file) 2>/dev/null; then
  if ln -s conf$$.file conf$$ 2>/dev/null; then
    as_ln_s='ln -s'
    # ... but there are two gotchas:
    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
    # In both cases, we have to default to `cp -pR'.
    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
      as_ln_s='cp -pR'
  elif ln conf$$.file conf$$ 2>/dev/null; then
    as_ln_s=ln
  else
    as_ln_s='cp -pR'
  fi
else
  as_ln_s='cp -pR'
fi
rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
rmdir conf$$.dir 2>/dev/null

if mkdir -p . 2>/dev/null; then
  as_mkdir_p='mkdir -p "$as_dir"'
else
  test -d ./-p && rmdir ./-p
  as_mkdir_p=false
fi

as_test_x='test -x'
as_executable_p=as_fn_executable_p

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"





SHELL=${CONFIG_SHELL-/bin/sh}

# How were we run?
at_cli_args="$@"


# Not all shells have the 'times' builtin; the subshell is needed to make
# sure we discard the 'times: not found' message from the shell.
at_times_p=false
(times) >/dev/null 2>&1 && at_times_p=:

# CLI Arguments to pass to the debugging scripts.
at_debug_args=
# -e sets to true
at_errexit_p=false
# Shall we be verbose?  ':' means no, empty means yes.
at_verbose=:
at_quiet=
# Running several jobs in parallel, 0 means as many as test groups.
at_jobs=1
at_traceon=:
at_trace_echo=:
at_check_filter_trace=:

# Shall we keep the debug scripts?  Must be `:' when the suite is
# run by a debug script, so that the script doesn't remove itself.
at_debug_p=false
# Display help message?
at_help_p=false
# Display the version message?
at_version_p=false
# List test groups?
at_list_p=false
# --clean
at_clean=false
# Test groups to run
at_groups=
# Whether to rerun failed tests.
at_recheck=
# Whether a write failure occurred
at_write_fail=0

# The directory we run the suite in.  Default to . if no -C option.
at_dir=`pwd`
# An absolute reference to this testsuite script.
case $as_myself in
  [\\/]* | ?:[\\/]* ) at_myself=$as_myself ;;
  * ) at_myself=$at_dir/$as_myself ;;
esac
# Whether -C is in effect.
at_change_dir=false

# Whether to enable colored test results.
at_color=auto
# As many question marks as there are digits in the last test group number.
# Used to normalize the test group numbers so that `ls' lists them in
# numerical order.
at_format='??'
# Description of all the test groups.
at_help_all="1;multinode.at:3;ovn multinode basic test;;
2;multinode.at:83;ovn multinode pmtu - distributed router - geneve;;
3;multinode.at:217;ovn multinode pmtu - distributed router - vxlan;;
4;multinode.at:332;ovn multinode pmtu - gw_router_port - geneve;;
5;multinode.at:460;ovn multinode pmtu - gw_router_port - vxlan;;
6;multinode.at:581;ovn multinode pmtu - gw router - geneve;;
7;multinode.at:720;ovn multinode pmtu - gw router - vxlan;;
8;multinode.at:1140;ovn multinode pmtu - logical switch - \"geneve\";;
9;multinode.at:1140;ovn multinode NAT on a provider network with no localnet ports;;
10;multinode.at:1141;ovn multinode pmtu - logical switch - \"vxlan\";;
11;multinode.at:1141;ovn multinode NAT on a provider network with no localnet ports;;
12;multinode.at:1143;ovn provider network - always_tunnel;;
13;multinode.at:1498;ovn multinode load-balancer with multiple DGPs and multiple chassis;;
14;multinode.at:2018;ovn multinode load-balancer with multiple DGPs and multiple chassis - ECMP environment;;
15;multinode.at:2528;ovn multinode - Transit Router basic functionality;;
16;multinode.at:2759;Migration of container ports;;
17;multinode.at:3029;ovn multinode bgp unnumbered;;
18;multinode.at:3340;HA: Check for missing garp on leader when BFD goes back up;;
"
# List of the all the test groups.
at_groups_all=`printf "%s\n" "$at_help_all" | sed 's/;.*//'`

# at_fn_validate_ranges NAME...
# -----------------------------
# Validate and normalize the test group number contained in each variable
# NAME. Leading zeroes are treated as decimal.
at_fn_validate_ranges ()
{
  for at_grp
  do
    eval at_value=\$$at_grp
    if test $at_value -lt 1 || test $at_value -gt 18; then
      printf "%s\n" "invalid test group: $at_value" >&2
      exit 1
    fi
    case $at_value in
      0*) # We want to treat leading 0 as decimal, like expr and test, but
	  # AS_VAR_ARITH treats it as octal if it uses $(( )).
	  # With XSI shells, ${at_value#${at_value%%[1-9]*}} avoids the
	  # expr fork, but it is not worth the effort to determine if the
	  # shell supports XSI when the user can just avoid leading 0.
	  eval $at_grp='`expr $at_value + 0`' ;;
    esac
  done
}
# List of the tested programs.
at_tested='"ovs-vswitchd"
"ovs-vsctl"'


##
## Set up package specific options.
##

at_arg_rebuild=false
at_arg_given_rebuild=false


at_prev=
for at_option
do
  # If the previous option needs an argument, assign it.
  if test -n "$at_prev"; then
    at_option=$at_prev=$at_option
    at_prev=
  fi

  case $at_option in
  *=?*) at_optarg=`expr "X$at_option" : '[^=]*=\(.*\)'` ;;
  *)    at_optarg= ;;
  esac

  case $at_option in
    --help | -h )
	at_help_p=:
	;;

    --list | -l )
	at_list_p=:
	;;

    --version | -V )
	at_version_p=:
	;;

    --clean | -c )
	at_clean=:
	;;

    --color )
	at_color=always
	;;
    --color=* )
	case $at_optarg in
	no | never | none) at_color=never ;;
	auto | tty | if-tty) at_color=auto ;;
	always | yes | force) at_color=always ;;
	*) at_optname=`echo " $at_option" | sed 's/^ //; s/=.*//'`
	   as_fn_error $? "unrecognized argument to $at_optname: $at_optarg" ;;
	esac
	;;

    --debug | -d )
	at_debug_p=:
	;;

    --errexit | -e )
	at_debug_p=:
	at_errexit_p=:
	;;

    --verbose | -v )
	at_verbose=; at_quiet=:
	;;

    --trace | -x )
	at_traceon='set -x'
	at_trace_echo=echo
	at_check_filter_trace=at_fn_filter_trace
	;;

    [0-9] | [0-9][0-9] | [0-9][0-9][0-9] | [0-9][0-9][0-9][0-9])
	at_fn_validate_ranges at_option
	as_fn_append at_groups "$at_option$as_nl"
	;;

    # Ranges
    [0-9]- | [0-9][0-9]- | [0-9][0-9][0-9]- | [0-9][0-9][0-9][0-9]-)
	at_range_start=`echo $at_option |tr -d X-`
	at_fn_validate_ranges at_range_start
	at_range=`printf "%s\n" "$at_groups_all" | \
	  sed -ne '/^'$at_range_start'$/,$p'`
	as_fn_append at_groups "$at_range$as_nl"
	;;

    -[0-9] | -[0-9][0-9] | -[0-9][0-9][0-9] | -[0-9][0-9][0-9][0-9])
	at_range_end=`echo $at_option |tr -d X-`
	at_fn_validate_ranges at_range_end
	at_range=`printf "%s\n" "$at_groups_all" | \
	  sed -ne '1,/^'$at_range_end'$/p'`
	as_fn_append at_groups "$at_range$as_nl"
	;;

    [0-9]-[0-9] | [0-9]-[0-9][0-9] | [0-9]-[0-9][0-9][0-9] | \
    [0-9]-[0-9][0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9] | \
    [0-9][0-9]-[0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] )
	at_range_start=`expr $at_option : '\(.*\)-'`
	at_range_end=`expr $at_option : '.*-\(.*\)'`
	if test $at_range_start -gt $at_range_end; then
	  at_tmp=$at_range_end
	  at_range_end=$at_range_start
	  at_range_start=$at_tmp
	fi
	at_fn_validate_ranges at_range_start at_range_end
	at_range=`printf "%s\n" "$at_groups_all" | \
	  sed -ne '/^'$at_range_start'$/,/^'$at_range_end'$/p'`
	as_fn_append at_groups "$at_range$as_nl"
	;;

    # Directory selection.
    --directory | -C )
	at_prev=--directory
	;;
    --directory=* )
	at_change_dir=:
	at_dir=$at_optarg
	if test x- = "x$at_dir" ; then
	  at_dir=./-
	fi
	;;

    # Parallel execution.
    --jobs | -j )
	at_jobs=0
	;;
    --jobs=* | -j[0-9]* )
	if test -n "$at_optarg"; then
	  at_jobs=$at_optarg
	else
	  at_jobs=`expr X$at_option : 'X-j\(.*\)'`
	fi
	case $at_jobs in *[!0-9]*)
	  at_optname=`echo " $at_option" | sed 's/^ //; s/[0-9=].*//'`
	  as_fn_error $? "non-numeric argument to $at_optname: $at_jobs" ;;
	esac
	;;

    # Keywords.
    --keywords | -k )
	at_prev=--keywords
	;;
    --keywords=* )
	at_groups_selected=$at_help_all
	at_save_IFS=$IFS
	IFS=,
	set X $at_optarg
	shift
	IFS=$at_save_IFS
	for at_keyword
	do
	  at_invert=
	  case $at_keyword in
	  '!'*)
	    at_invert="-v"
	    at_keyword=`expr "X$at_keyword" : 'X!\(.*\)'`
	    ;;
	  esac
	  # It is on purpose that we match the test group titles too.
	  at_groups_selected=`printf "%s\n" "$at_groups_selected" |
	      grep -i $at_invert "^[1-9][^;]*;.*[; ]$at_keyword[ ;]"`
	done
	# Smash the keywords.
	at_groups_selected=`printf "%s\n" "$at_groups_selected" | sed 's/;.*//'`
	as_fn_append at_groups "$at_groups_selected$as_nl"
	;;
    --recheck)
	at_recheck=:
	;;
    --rebuild )
	at_optarg=:
	at_arg_rebuild=:
	at_arg_given_rebuild=:
		;;
    --no-rebuild )
	at_optarg=false
	at_arg_rebuild=false
	at_arg_given_rebuild=:
		;;


    *=*)
	at_envvar=`expr "x$at_option" : 'x\([^=]*\)='`
	# Reject names that are not valid shell variable names.
	case $at_envvar in
	  '' | [0-9]* | *[!_$as_cr_alnum]* )
	    as_fn_error $? "invalid variable name: \`$at_envvar'" ;;
	esac
	at_value=`printf "%s\n" "$at_optarg" | sed "s/'/'\\\\\\\\''/g"`
	# Export now, but save eval for later and for debug scripts.
	export $at_envvar
	as_fn_append at_debug_args " $at_envvar='$at_value'"
	;;

     *) printf "%s\n" "$as_me: invalid option: $at_option" >&2
	printf "%s\n" "Try \`$0 --help' for more information." >&2
	exit 1
	;;
  esac
done

# Verify our last option didn't require an argument
if test -n "$at_prev"
then :
  as_fn_error $? "\`$at_prev' requires an argument"
fi

# The file containing the suite.
at_suite_log=$at_dir/$as_me.log

# Selected test groups.
if test -z "$at_groups$at_recheck"; then
  at_groups=$at_groups_all
else
  if test -n "$at_recheck" && test -r "$at_suite_log"; then
    at_oldfails=`sed -n '
      /^Failed tests:$/,/^Skipped tests:$/{
	s/^[ ]*\([1-9][0-9]*\):.*/\1/p
      }
      /^Unexpected passes:$/,/^## Detailed failed tests/{
	s/^[ ]*\([1-9][0-9]*\):.*/\1/p
      }
      /^## Detailed failed tests/q
      ' "$at_suite_log"`
    as_fn_append at_groups "$at_oldfails$as_nl"
  fi
  # Sort the tests, removing duplicates.
  at_groups=`printf "%s\n" "$at_groups" | sort -nu | sed '/^$/d'`
fi

if test x"$at_color" = xalways \
   || { test x"$at_color" = xauto && test -t 1; }; then
  at_red=`printf '\033[0;31m'`
  at_grn=`printf '\033[0;32m'`
  at_lgn=`printf '\033[1;32m'`
  at_blu=`printf '\033[1;34m'`
  at_std=`printf '\033[m'`
else
  at_red= at_grn= at_lgn= at_blu= at_std=
fi

# Help message.
if $at_help_p; then
  cat <<_ATEOF || at_write_fail=1
Usage: $0 [OPTION]... [VARIABLE=VALUE]... [TESTS]

Run all the tests, or the selected TESTS, given by numeric ranges, and
save a detailed log file.  Upon failure, create debugging scripts.

Do not change environment variables directly.  Instead, set them via
command line arguments.  Set \`AUTOTEST_PATH' to select the executables
to exercise.  Each relative directory is expanded as build and source
directories relative to the top level of this distribution.
E.g., from within the build directory /tmp/foo-1.0, invoking this:

  $ $0 AUTOTEST_PATH=bin

is equivalent to the following, assuming the source directory is /src/foo-1.0:

  PATH=/tmp/foo-1.0/bin:/src/foo-1.0/bin:\$PATH $0
_ATEOF
cat <<_ATEOF || at_write_fail=1

Operation modes:
  -h, --help     print the help message, then exit
  -V, --version  print version number, then exit
  -c, --clean    remove all the files this test suite might create and exit
  -l, --list     describes all the tests, or the selected TESTS
_ATEOF
cat <<_ATEOF || at_write_fail=1

Execution tuning:
  -C, --directory=DIR
                 change to directory DIR before starting
      --color[=never|auto|always]
                 disable colored test results, or enable even without terminal
  -j, --jobs[=N]
                 Allow N jobs at once; infinite jobs with no arg (default 1)
  -k, --keywords=KEYWORDS
                 select the tests matching all the comma-separated KEYWORDS
                 multiple \`-k' accumulate; prefixed \`!' negates a KEYWORD
      --recheck  select all tests that failed or passed unexpectedly last time
  -e, --errexit  abort as soon as a test fails; implies --debug
  -v, --verbose  force more detailed output
                 default for debugging scripts
  -d, --debug    inhibit clean up and top-level logging
                 default for debugging scripts
  -x, --trace    enable tests shell tracing
_ATEOF
cat <<_ATEOF || at_write_fail=1

Other options:
_ATEOF

cat <<_ATEOF || at_write_fail=1
Do not use cached versions of databases
_ATEOF
cat <<_ATEOF || at_write_fail=1

Report bugs to <bugs@openvswitch.org>.
_ATEOF
  exit $at_write_fail
fi

# List of tests.
if $at_list_p; then
  cat <<_ATEOF || at_write_fail=1
ovn 25.03.90 test suite test groups:

 NUM: FILE-NAME:LINE     TEST-GROUP-NAME
      KEYWORDS

_ATEOF
  # Pass an empty line as separator between selected groups and help.
  printf "%s\n" "$at_groups$as_nl$as_nl$at_help_all" |
    awk 'NF == 1 && FS != ";" {
	   selected[$ 1] = 1
	   next
	 }
	 /^$/ { FS = ";" }
	 NF > 0 {
	   if (selected[$ 1]) {
	     printf " %3d: %-18s %s\n", $ 1, $ 2, $ 3
	     if ($ 4) {
	       lmax = 79
	       indent = "     "
	       line = indent
	       len = length (line)
	       n = split ($ 4, a, " ")
	       for (i = 1; i <= n; i++) {
		 l = length (a[i]) + 1
		 if (i > 1 && len + l > lmax) {
		   print line
		   line = indent " " a[i]
		   len = length (line)
		 } else {
		   line = line " " a[i]
		   len += l
		 }
	       }
	       if (n)
		 print line
	     }
	   }
	 }' || at_write_fail=1
  exit $at_write_fail
fi
if $at_version_p; then
  printf "%s\n" "$as_me (ovn 25.03.90)" &&
  cat <<\_ATEOF || at_write_fail=1

Copyright (C) 2021 Free Software Foundation, Inc.
This test suite is free software; the Free Software Foundation gives
unlimited permission to copy, distribute and modify it.

Copyright (c) 2022 Red Hat,

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at:

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
_ATEOF
  exit $at_write_fail
fi

# Should we print banners?  Yes if more than one test is run.
case $at_groups in #(
  *$as_nl* )
      at_print_banners=: ;; #(
  * ) at_print_banners=false ;;
esac
# Text for banner N, set to a single space once printed.
# Banner 1. multinode.at:1
# Category starts at test group 1.
at_banner_text_1="ovn multinode system tests using ovn-fake-multinode"

# Take any -C into account.
if $at_change_dir ; then
  test x != "x$at_dir" && cd "$at_dir" \
    || as_fn_error $? "unable to change directory"
  at_dir=`pwd`
fi

# Load the config files for any default variable assignments.
for at_file in atconfig atlocal
do
  test -r $at_file || continue
  . ./$at_file || as_fn_error $? "invalid content: $at_file"
done

# Autoconf <=2.59b set at_top_builddir instead of at_top_build_prefix:
: "${at_top_build_prefix=$at_top_builddir}"

# Perform any assignments requested during argument parsing.
eval "$at_debug_args"

# atconfig delivers names relative to the directory the test suite is
# in, but the groups themselves are run in testsuite-dir/group-dir.
if test -n "$at_top_srcdir"; then
  builddir=../..
  for at_dir_var in srcdir top_srcdir top_build_prefix
  do
    eval at_val=\$at_$at_dir_var
    case $at_val in
      [\\/$]* | ?:[\\/]* ) at_prefix= ;;
      *) at_prefix=../../ ;;
    esac
    eval "$at_dir_var=\$at_prefix\$at_val"
  done
fi

## -------------------- ##
## Directory structure. ##
## -------------------- ##

# This is the set of directories and files used by this script
# (non-literals are capitalized):
#
# TESTSUITE         - the testsuite
# TESTSUITE.log     - summarizes the complete testsuite run
# TESTSUITE.dir/    - created during a run, remains after -d or failed test
# + at-groups/      - during a run: status of all groups in run
# | + NNN/          - during a run: meta-data about test group NNN
# | | + check-line  - location (source file and line) of current AT_CHECK
# | | + status      - exit status of current AT_CHECK
# | | + stdout      - stdout of current AT_CHECK
# | | + stder1      - stderr, including trace
# | | + stderr      - stderr, with trace filtered out
# | | + test-source - portion of testsuite that defines group
# | | + times       - timestamps for computing duration
# | | + pass        - created if group passed
# | | + xpass       - created if group xpassed
# | | + fail        - created if group failed
# | | + xfail       - created if group xfailed
# | | + skip        - created if group skipped
# + at-stop         - during a run: end the run if this file exists
# + at-source-lines - during a run: cache of TESTSUITE line numbers for extraction
# + 0..NNN/         - created for each group NNN, remains after -d or failed test
# | + TESTSUITE.log - summarizes the group results
# | + ...           - files created during the group

# The directory the whole suite works in.
# Should be absolute to let the user `cd' at will.
at_suite_dir=$at_dir/$as_me.dir
# The file containing the suite ($at_dir might have changed since earlier).
at_suite_log=$at_dir/$as_me.log
# The directory containing helper files per test group.
at_helper_dir=$at_suite_dir/at-groups
# Stop file: if it exists, do not start new jobs.
at_stop_file=$at_suite_dir/at-stop
# The fifo used for the job dispatcher.
at_job_fifo=$at_suite_dir/at-job-fifo

if $at_clean; then
  test -d "$at_suite_dir" &&
    find "$at_suite_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
  rm -f -r "$at_suite_dir" "$at_suite_log"
  exit $?
fi

# Don't take risks: use only absolute directories in PATH.
#
# For stand-alone test suites (ie. atconfig was not found),
# AUTOTEST_PATH is relative to `.'.
#
# For embedded test suites, AUTOTEST_PATH is relative to the top level
# of the package.  Then expand it into build/src parts, since users
# may create executables in both places.
AUTOTEST_PATH=`printf "%s\n" "$AUTOTEST_PATH" | sed "s|:|$PATH_SEPARATOR|g"`
at_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $AUTOTEST_PATH $PATH
do
  IFS=$as_save_IFS
  case $as_dir in #(((
    '') as_dir=./ ;;
    */) ;;
    *) as_dir=$as_dir/ ;;
  esac
    test -n "$at_path" && as_fn_append at_path $PATH_SEPARATOR
case $as_dir in
  [\\/]* | ?:[\\/]* )
    as_fn_append at_path "$as_dir"
    ;;
  * )
    if test -z "$at_top_build_prefix"; then
      # Stand-alone test suite.
      as_fn_append at_path "$as_dir"
    else
      # Embedded test suite.
      as_fn_append at_path "$at_top_build_prefix$as_dir$PATH_SEPARATOR"
      as_fn_append at_path "$at_top_srcdir/$as_dir"
    fi
    ;;
esac
  done
IFS=$as_save_IFS


# Now build and simplify PATH.
#
# There might be directories that don't exist, but don't redirect
# builtins' (eg., cd) stderr directly: Ultrix's sh hates that.
at_new_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $at_path
do
  IFS=$as_save_IFS
  case $as_dir in #(((
    '') as_dir=./ ;;
    */) ;;
    *) as_dir=$as_dir/ ;;
  esac
    test -d "$as_dir" || continue
case $as_dir in
  [\\/]* | ?:[\\/]* ) ;;
  * ) as_dir=`(cd "$as_dir" && pwd) 2>/dev/null` ;;
esac
case $PATH_SEPARATOR$at_new_path$PATH_SEPARATOR in
  *$PATH_SEPARATOR$as_dir$PATH_SEPARATOR*) ;;
  $PATH_SEPARATOR$PATH_SEPARATOR) at_new_path=$as_dir ;;
  *) as_fn_append at_new_path "$PATH_SEPARATOR$as_dir" ;;
esac
  done
IFS=$as_save_IFS

PATH=$at_new_path
export PATH

# Setting up the FDs.



# 5 is the log file.  Not to be overwritten if `-d'.
if $at_debug_p; then
  at_suite_log=/dev/null
else
  : >"$at_suite_log"
fi
exec 5>>"$at_suite_log"

# Banners and logs.
printf "%s\n" "## ------------------------ ##
## ovn 25.03.90 test suite. ##
## ------------------------ ##"
{
  printf "%s\n" "## ------------------------ ##
## ovn 25.03.90 test suite. ##
## ------------------------ ##"
  echo

  printf "%s\n" "$as_me: command line was:"
  printf "%s\n" "  \$ $0 $at_cli_args"
  echo

  # If ChangeLog exists, list a few lines in case it might help determining
  # the exact version.
  if test -n "$at_top_srcdir" && test -f "$at_top_srcdir/ChangeLog"; then
    printf "%s\n" "## ---------- ##
## ChangeLog. ##
## ---------- ##"
    echo
    sed 's/^/| /;10q' "$at_top_srcdir/ChangeLog"
    echo
  fi

  {
cat <<_ASUNAME
## --------- ##
## Platform. ##
## --------- ##

hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
uname -m = `(uname -m) 2>/dev/null || echo unknown`
uname -r = `(uname -r) 2>/dev/null || echo unknown`
uname -s = `(uname -s) 2>/dev/null || echo unknown`
uname -v = `(uname -v) 2>/dev/null || echo unknown`

/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`

/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`

_ASUNAME

as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  case $as_dir in #(((
    '') as_dir=./ ;;
    */) ;;
    *) as_dir=$as_dir/ ;;
  esac
    printf "%s\n" "PATH: $as_dir"
  done
IFS=$as_save_IFS

}
  echo

  # Contents of the config files.
  for at_file in atconfig atlocal
  do
    test -r $at_file || continue
    printf "%s\n" "$as_me: $at_file:"
    sed 's/^/| /' $at_file
    echo
  done
} >&5


## ------------------------- ##
## Autotest shell functions. ##
## ------------------------- ##

# at_fn_banner NUMBER
# -------------------
# Output banner NUMBER, provided the testsuite is running multiple groups and
# this particular banner has not yet been printed.
at_fn_banner ()
{
  $at_print_banners || return 0
  eval at_banner_text=\$at_banner_text_$1
  test "x$at_banner_text" = "x " && return 0
  eval "at_banner_text_$1=\" \""
  if test -z "$at_banner_text"; then
    $at_first || echo
  else
    printf "%s\n" "$as_nl$at_banner_text$as_nl"
  fi
} # at_fn_banner

# at_fn_check_prepare_notrace REASON LINE
# ---------------------------------------
# Perform AT_CHECK preparations for the command at LINE for an untraceable
# command; REASON is the reason for disabling tracing.
at_fn_check_prepare_notrace ()
{
  $at_trace_echo "Not enabling shell tracing (command contains $1)"
  printf "%s\n" "$2" >"$at_check_line_file"
  at_check_trace=: at_check_filter=:
  : >"$at_stdout"; : >"$at_stderr"
}

# at_fn_check_prepare_trace LINE
# ------------------------------
# Perform AT_CHECK preparations for the command at LINE for a traceable
# command.
at_fn_check_prepare_trace ()
{
  printf "%s\n" "$1" >"$at_check_line_file"
  at_check_trace=$at_traceon at_check_filter=$at_check_filter_trace
  : >"$at_stdout"; : >"$at_stderr"
}

# at_fn_check_prepare_dynamic COMMAND LINE
# ----------------------------------------
# Decide if COMMAND at LINE is traceable at runtime, and call the appropriate
# preparation function.
at_fn_check_prepare_dynamic ()
{
  case $1 in
    *$as_nl*)
      at_fn_check_prepare_notrace 'an embedded newline' "$2" ;;
    *)
      at_fn_check_prepare_trace "$2" ;;
  esac
}

# at_fn_filter_trace
# ------------------
# Remove the lines in the file "$at_stderr" generated by "set -x" and print
# them to stderr.
at_fn_filter_trace ()
{
  mv "$at_stderr" "$at_stder1"
  grep '^ *+' "$at_stder1" >&2
  grep -v '^ *+' "$at_stder1" >"$at_stderr"
}

# at_fn_log_failure FILE-LIST
# ---------------------------
# Copy the files in the list on stdout with a "> " prefix, and exit the shell
# with a failure exit code.
at_fn_log_failure ()
{
  for file
    do printf "%s\n" "$file:"; sed 's/^/> /' "$file"; done
  echo 1 > "$at_status_file"
  exit 1
}

# at_fn_check_skip EXIT-CODE LINE
# -------------------------------
# Check whether EXIT-CODE is a special exit code (77 or 99), and if so exit
# the test group subshell with that same exit code. Use LINE in any report
# about test failure.
at_fn_check_skip ()
{
  case $1 in
    99) echo 99 > "$at_status_file"; at_failed=:
	printf "%s\n" "$2: hard failure"; exit 99;;
    77) echo 77 > "$at_status_file"; exit 77;;
  esac
}

# at_fn_check_status EXPECTED EXIT-CODE LINE
# ------------------------------------------
# Check whether EXIT-CODE is the EXPECTED exit code, and if so do nothing.
# Otherwise, if it is 77 or 99, exit the test group subshell with that same
# exit code; if it is anything else print an error message referring to LINE,
# and fail the test.
at_fn_check_status ()
{
  case $2 in
    $1 ) ;;
    77) echo 77 > "$at_status_file"; exit 77;;
    99) echo 99 > "$at_status_file"; at_failed=:
	printf "%s\n" "$3: hard failure"; exit 99;;
    *) printf "%s\n" "$3: exit code was $2, expected $1"
      at_failed=:;;
  esac
}

# at_fn_diff_devnull FILE
# -----------------------
# Emit a diff between /dev/null and FILE. Uses "test -s" to avoid useless diff
# invocations.
at_fn_diff_devnull ()
{
  test -s "$1" || return 0
  $at_diff "$at_devnull" "$1"
}

# at_fn_test NUMBER
# -----------------
# Parse out test NUMBER from the tail of this file.
at_fn_test ()
{
  eval at_sed=\$at_sed$1
  sed "$at_sed" "$at_myself" > "$at_test_source"
}

# at_fn_create_debugging_script
# -----------------------------
# Create the debugging script $at_group_dir/run which will reproduce the
# current test group.
at_fn_create_debugging_script ()
{
  {
    echo "#! /bin/sh" &&
    echo 'test ${ZSH_VERSION+y} && alias -g '\''${1+"$@"}'\''='\''"$@"'\''' &&
    printf "%s\n" "cd '$at_dir'" &&
    printf "%s\n" "exec \${CONFIG_SHELL-$SHELL} \"$at_myself\" -v -d $at_debug_args $at_group \${1+\"\$@\"}" &&
    echo 'exit 1'
  } >"$at_group_dir/run" &&
  chmod +x "$at_group_dir/run"
}

## -------------------------------- ##
## End of autotest shell functions. ##
## -------------------------------- ##


# Set ovs_base to the base directory in which the test is running and
# initialize the OVS_*DIR environment variables to point to this
# directory.
ovs_init() {
    ovs_base=`pwd`
    trap ovs_on_exit 0
    : > cleanup
    ovs_setenv
}

# Catch testsuite error condition and cleanup test environment by tearing down
# all interfaces and processes spawned.
# User has an option to leave the test environment in error state so that system
# can be poked around to get more information. User can enable this option by setting
# environment variable OVS_PAUSE_TEST=1. User needs to press CTRL-D to resume the
# cleanup operation.
ovs_pause() {
    echo "====================================================="
    echo "Set following environment variable to use various ovs utilities"
    echo "export OVS_RUNDIR=$ovs_base"
    echo "Press ENTER to continue: "
    read
}

ovs_on_exit () {
    rv=$?
    if [ ! -z "${OVS_PAUSE_TEST}" ] && [ -z $at_verbose ] && [ $rv != 0 ]; then
        trap '' INT
        ovs_pause
    fi
    . "$ovs_base/cleanup"
}

# With no parameter or an empty parameter, sets the OVS_*DIR
# environment variables to point to $ovs_base, the base directory in
# which the test is running.
#
# With a parameter, sets them to $ovs_base/$1.
ovs_setenv() {
    sandbox=$1
    ovs_dir=$ovs_base${1:+/$1}
    OVS_RUNDIR=$ovs_dir; export OVS_RUNDIR
    OVN_RUNDIR=$ovs_dir; export OVN_RUNDIR
    OVS_LOGDIR=$ovs_dir; export OVS_LOGDIR
    OVS_DBDIR=$ovs_dir; export OVS_DBDIR
    OVS_SYSCONFDIR=$ovs_dir; export OVS_SYSCONFDIR
    OVN_SYSCONFDIR=$ovs_dir; export OVN_SYSCONFDIR
    OVS_PKGDATADIR=$ovs_dir; export OVS_PKGDATADIR
    OVN_PKGDATADIR=$ovs_dir; export OVN_PKGDATADIR
}

# Prints the integers from $1 to $2, increasing by $3 (default 1) on stdout.
seq () {
    if test $# = 1; then
        set 1 $1
    fi
    while test $1 -le $2; do
        echo $1
        set `expr $1 + ${3-1}` $2 $3
    done
}

if test "$IS_WIN32" = "yes"; then
    pwd () {
        command pwd -W "$@"
    }

    diff () {
        command diff --strip-trailing-cr "$@"
    }

    # tskill is more effective than taskkill but it isn't always installed.
    if (tskill //?) >/dev/null 2>&1; then :; else
        tskill () { taskkill //F //PID $1 >/dev/null; }
    fi

    kill () {
        signal=
        retval=0
        for arg; do
            case $arg in
            -*) signal=$arg ;;
            [1-9][0-9]*)
                # tasklist always returns 0.
                # If pid does exist, there will be a line with the pid.
                if tasklist //fi "PID eq $arg" | grep $arg >/dev/null; then
                    if test "X$signal" != "X-0"; then
                        tskill $arg
                    fi
                else
                    retval=1
                fi
                ;;
            esac
        done
        return $retval
    }
fi

# parent_pid PID
#
# Prints the PID of the parent of process PID.
parent_pid () {
    # Using "ps" is portable to any POSIX system, but busybox "ps" (used in
    # e.g. Alpine Linux) is noncompliant, so we use a Linux-specific approach
    # when it's available.  We check the format of the status file to avoid
    # the NetBSD file with the same name but different contents.
    if egrep '^PPid:[[:space:]]*[0-9]*$' /proc/$1/status > /dev/null 2>&1; then
        sed -n 's/^PPid:	\([0-9]*\)/\1/p' /proc/$1/status
    else
        ps -o ppid= -p $1
    fi
}

# kill_ovs_vswitchd [PID]
#
# Signal the ovs-vswitchd daemon to exit gracefully and wait for it to
# terminate or kill it if that takes too long.
#
# It is used to cleanup all sorts of tests and results. It can't assume
# any state, including the availability of PID file which can be provided.
kill_ovs_vswitchd () {
    # Use provided PID or save the current PID if available.
    TMPPID=$1
    if test -z "$TMPPID"; then
        TMPPID=$(cat $OVS_RUNDIR/ovs-vswitchd.pid 2>/dev/null)
    fi

    # Tell the daemon to terminate gracefully
    ovs-appctl --timeout=10 -t ovs-vswitchd exit --cleanup 2>/dev/null

    # Nothing else to be done if there is no PID
    test -z "$TMPPID" && return

    for i in 1 2 3 4 5 6 7 8 9; do
        # Check if the daemon is alive.
        kill -0 $TMPPID 2>/dev/null || return

        # Fallback to whole number since POSIX doesn't require
        # fractional times to work.
        sleep 0.1 || sleep 1
    done

    # Make sure it is terminated.
    kill $TMPPID
}

# Normalize the output of 'wc' to match POSIX.
# POSIX says 'wc' should print "%d %d %d", but GNU prints "%7d %7d %7d".
# POSIX says 'wc -l' should print "%d %s", but BSD prints "%8d".
#
# This fixes all of those (it will screw up filenames that contain
# multiple sequential spaces, but that doesn't really matter).
wc () {
   command wc "$@" | tr -s ' ' ' ' | sed 's/^ *//'
}

uuidfilt () {
    $PYTHON "$top_srcdir"/tests/uuidfilt.py "$@"
}

# run_as PROGRAM_NAME COMMAND [ARG...]
#
# Runs a command with argv[0] set to PROGRAM_NAME, if possible, in a
# subshell.  Most utilities print argc[0] as part of their messages,
# so this makes it easier to figure out which particular utility
# prints a message if a bunch of identical processes are running.
#
# Not all shells support "exec -a NAME", so test for it.
if (exec -a myname true 2>/dev/null); then
    run_as () {
        (exec -a "$@")
    }
else
    run_as () {
        shift
        (exec "$@")
    }
fi


ovs_cleanup() {
    if test "$(echo sanitizers.*)" != 'sanitizers.*'; then
        echo "Undefined Behavior Sanitizer or Address Sanitizer reported errors in:" sanitizers.*
        cat sanitizers.*
        printf "%s\n" "ovs-macros.at:231" >"$at_check_line_file"
at_fn_check_skip 99 "$at_srcdir/ovs-macros.at:231"
    fi
}

ovs_wait () {
    echo "$1: waiting $2..." >&5

    # First try the condition without waiting.
    if ovs_wait_cond; then echo "$1: wait succeeded immediately" >&5; return 0; fi

    # Try a quick sleep, so that the test completes very quickly
    # in the normal case.  POSIX doesn't require fractional times to
    # work, so this might not work.
    sleep 0.1
    if ovs_wait_cond; then echo "$1: wait succeeded quickly" >&5; return 0; fi

    # Then wait up to OVS_CTL_TIMEOUT seconds.
    local timer
    for timer in `seq 1 "$OVS_CTL_TIMEOUT"`; do
        sleep 1
        if ovs_wait_cond; then echo "$1: wait succeeded after $timer seconds" >&5; return 0; fi
    done

    echo "$1: wait failed after $timer seconds" >&5
    ovs_wait_failed
    printf "%s\n" "ovs-macros.at:256" >"$at_check_line_file"
at_fn_check_skip 99 "$at_srcdir/ovs-macros.at:256"
}

check_ovs_wait_until_args() {
   printf "%s\n" "ovs-macros.at:260" >"$at_check_line_file"
(test $1 -ge 3) \
  && at_fn_check_skip 99 "$at_srcdir/ovs-macros.at:260"
      printf "%s\n" "ovs-macros.at:262" >"$at_check_line_file"
(test $1 -eq 2 && test "$2" -eq "$2" 2>/dev/null) \
  && at_fn_check_skip 99 "$at_srcdir/ovs-macros.at:262"
}


   on_exit () {
    if  echo "$1" | grep -qe '^ovn-nbctl'  ; then
      (echo "test -e ovn-nb/ovn-nb.sock && $1"; cat cleanup;) > cleanup.tmp
    elif  echo "$1" | grep -qe '^ovn-sbctl' ; then
      (echo "test -e ovn-sb/ovn-sb.sock && $1"; cat cleanup) > cleanup.tmp
    elif  echo "$1" | grep -qe '^ovs-ofctl' -qe '^ovs-dpctl' ; then
      (echo "test -e $OVS_RUNDIR/ovs-vswitchd.pid && $1"; cat cleanup) > cleanup.tmp
    else
      (echo "$1"; cat cleanup) > cleanup.tmp
    fi
    mv cleanup.tmp cleanup
}


ovsdb_client_wait() {
    ovsdb-client -vconsole:warn -vreconnect:err -vjsonrpc:err -vtimeval:off -vfile -vsyslog:off -vvlog:off --timeout=30 wait "$@"
}



# Strips 'n_packets=...' from ovs-ofctl output.
strip_n_packets () {
    sed 's/ n_packets=[0-9]*,//'
}

# Strips 'n_bytes=...' from ovs-ofctl output.
strip_n_bytes () {
    sed 's/ n_bytes=[0-9]*,//'
}

# Strips 'cookie=...' from ovs-ofctl output.
strip_cookie () {
    sed '
s/ cookie=0x[0-9a-fA-F]*,//
s/cookie=0x[0-9a-fA-F]*,//
'
}

# Strips 'nw_frag=yes|no' from ovs-ofctl (or similar) output.
strip_nw_frag () {
    sed '
s/nw_frag=yes,//
s/nw_frag=no,//
'
}

# Strips out uninteresting parts of ovs-ofctl output, as well as parts
# that vary from one run to another.
ofctl_strip () {
    sed '
s/ (xid=0x[0-9a-fA-F]*)//
s/ duration=[0-9.]*s,//
s/ cookie=0,//
s/ table=0,//
s/ n_packets=0,//
s/ n_bytes=0,//
s/ idle_age=[0-9]*,//
s/ hard_age=[0-9]*,//
s/dp_hash=0x[0-9a-f]*\//dp_hash=0x0\//
s/recirc_id=0x[0-9a-f]*,/recirc_id=0x0,/
s/[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9]Z|//
s/dir\/[0-9]*\/br0.mgmt/dir\/XXXX\/br0.mgmt/
'
}

# Strips out uninteresting parts of ovs-ofctl output, including n_packets=..
# n_bytes=..
ofctl_strip_all () {
    ofctl_strip | strip_n_packets | strip_n_bytes | strip_cookie | sort
}

# Filter (multiline) vconn debug messages from ovs-vswitchd.log.
# Use with vconn_sub() and ofctl_strip()
print_vconn_debug () { awk -F\| < ovs-vswitchd.log '
BEGIN { prt=0 }
/\|vconn\|DBG\|/ { sub(/[ \t]*$/, ""); print $3 "|" $4 "|" $5; prt=1; next }
$4 != "" { prt=0; next }
prt==1 { sub(/[ \t]*$/, ""); print $0 }
'
}

vconn_sub() {
    sed '
s/tcp:127.0.0.1:[0-9][0-9]*:/unix:/
s/unix#[0-9]*:/unix:/
'
}


# PARSE_LISTENING_PORT LOGFILE VARIABLE
#
# Parses the TCP or SSL/TLS port on which a server is listening from
# LOGFILE, given that the server was told to listen on a kernel-chosen
# port, and assigns the port number to shell VARIABLE.  You should
# specify the listening remote as ptcp:0:127.0.0.1 or
# pssl:0:127.0.0.1, or the equivalent with [::1] instead of 127.0.0.1.
#
# Here's an example of how to use this with ovsdb-server:
#
#    ovsdb-server --log-file --remote=ptcp:0:127.0.0.1 ...
#    PARSE_LISTENING_PORT([ovsdb-server.log], [TCP_PORT])
#    # Now $TCP_PORT holds the listening port.


start_daemon () {
    set "$@" -vconsole:off --detach --no-chdir --pidfile --log-file
    echo "$@"
    "$@"
    pidfile="$OVS_RUNDIR"/$1.pid
    on_exit "test -e \"$pidfile\" && kill \`cat \"$pidfile\"\`"
}

# sim_add SANDBOX
#
# Starts a new simulated Open vSwitch instance named SANDBOX.  Files related to
# the instance, such as logs, databases, sockets, and pidfiles, are created in
# a subdirectory of the main test directory also named SANDBOX.  Afterward, the
# "as" command (see below) can be used to run Open vSwitch utilities in the
# context of the new sandbox.
#
# The new sandbox starts out without any bridges.  Use ovs-vsctl in the context
# of the new sandbox to create a bridge, e.g.:
#
#     sim_add hv0           # Create sandbox hv0.
#     as hv0                # Set hv0 as default sandbox.
#     ovs-vsctl add-br br0  # Add bridge br0 inside hv0.
#
# or:
#
#     sim_add hv0
#     as hv0 ovs-vsctl add-br br0
PKIDIR="$(cd $abs_top_builddir/tests && pwd)"
sims=
sim_add () {
   echo "adding simulator '$1'"

   sims="$sims $1"

   # Create sandbox.
   local d="$ovs_base"/$1
   mkdir "$d" || return 1
   ovs_setenv $1

   # Create database and start ovsdb-server.
   : > "$d"/.conf.db.~lock~
   as $1 ovsdb-tool create "$d"/conf.db "$ovs_srcdir"/vswitchd/vswitch.ovsschema || return 1
   as $1 start_daemon ovsdb-server --remote=punix:"$d"/db.sock || return 1

   # Initialize database.
   as $1 ovs-vsctl --no-wait -- init || return 1

   # Start ovs-vswitchd
   as $1 start_daemon ovs-vswitchd --enable-dummy=system -vvconn -vofproto_dpif -vunixctl
   as $1 ovs-appctl vlog/disable-rate-limit vconn
   if test X$HAVE_OPENSSL = Xyes; then
      if test -f $PKIDIR/testpki-$1-privkey.pem; then
         as $1 ovs-vsctl set-ssl \
            $PKIDIR/testpki-$1-privkey.pem \
            $PKIDIR/testpki-$1-cert.pem \
            $PKIDIR/testpki-cacert.pem \
            || return 1
      else
         echo "WARNING: No certificate created for sim '$1', check TESTPKI_CNS variable in tests/automake.mk"
      fi
   fi
}

# "as $1" sets the OVS_*DIR environment variables to point to $ovs_base/$1.
#
# "as $1 COMMAND..." sets those variables in a subshell and invokes COMMAND
# there.
as() {
    if test "X$2" != X; then
        (ovs_setenv $1; shift; "$@")
    else
        ovs_setenv $1
    fi
}

# Strips 'xid=0x1234' from ovs-ofctl output.
strip_xids () {
    sed 's/ (xid=0x[0-9a-fA-F]*)//'
}

# Changes all 'used:...' to say 'used:0.0', to make output easier to compare.
strip_used () {
    sed 's/used:[0-9]\.[0-9]*/used:0.0/'
}

# Removes all 'duration=...' to make output easier to compare.
strip_duration () {
    sed 's/duration=[0-9]*\.[0-9]*s,//'
}

# Strips 'ufid:...' from output, to make it easier to compare.
# (ufids are random.)
strip_ufid () {
    sed 's/ufid:[-0-9a-f]* //'
}

check_logs () {
    local logs
    for log in ./$2/*.log; do
        case ${log} in # (
            '*.log'|*testsuite.log) ;; # (
            *) logs="${logs} ${log}" ;;
        esac
    done

    # We most notably ignore 'Broken pipe' warnings.  These often and
    # intermittently appear in ovsdb-server.log, because *ctl commands
    # (e.g. ovs-vsctl, ovn-nbctl) exit right after committing a change to the
    # database.  However, in reaction, some daemon may immediately update the
    # database, and this later update may cause database sending update back to
    # *ctl command if *ctl has not exited yet.  If *ctl command exits before
    # the database calls send, the send fails with 'Broken pipe' or
    # 'not connected' depending on system.  Also removes all 'connection reset'
    # warning logs for similar reasons (EPIPE, ENOTCONN or ECONNRESET can be
    # returned on a send depending on whether the peer had unconsumed data
    # when it closed the socket).
    #
    # We also ignore "Dropped # log messages..." messages.  Otherwise, even if
    # we ignore the messages that were rate-limited, we can end up failing just
    # because of the announcement that rate-limiting happened (and in a racy,
    # timing-dependent way, too).
    sed -n "$1
/reset by peer/d
/Broken pipe/d
/is not connected/d
/timeval.*Unreasonably long [0-9]*ms poll interval/d
/timeval.*faults: [0-9]* minor, [0-9]* major/d
/timeval.*disk: [0-9]* reads, [0-9]* writes/d
/timeval.*context switches: [0-9]* voluntary, [0-9]* involuntary/d
/ovs_rcu.*blocked [0-9]* ms waiting for .* to quiesce/d
/Dropped [0-9]* log messages/d
/.*Trying to release unknown interface.*/d
/setting extended ack support failed/d
/|WARN|/p
/|ERR|/p
/|EMER|/p" ${logs}
}

# add_of_br BRNUM [ARG...]
add_of_br () {
    local brnum=$1; shift
    local br=br$brnum
    local dpid=fedcba987654321$brnum
    local mac=aa:55:aa:55:00:0$brnum
    ovs-vsctl --timeout=20 \
        -- add-br $br \
        -- set bridge $br datapath-type=dummy \
                          fail-mode=secure \
                          other-config:datapath-id=$dpid \
                          other-config:hwaddr=$mac \
                          protocols="[OpenFlow10,OpenFlow11,OpenFlow12,\
                                       OpenFlow13,OpenFlow14,OpenFlow15]" \
        -- "$@"
}

# add_of_ports__ PORT_TYPE [--pcap] BRIDGE PNUM...
#
# Creates PORT_TYPE interfaces in BRIDGE named pPNUM, OpenFlow port number
# PNUM, and datapath port number PNUM (the latter is a consequence of
# the dummy implementation, which tries to assign datapath port
# numbers based on port names).
#
# If --pcap is supplied then packets received from the interface will
# be written to $port-rx.pcap and those sent to it to $port-tx.pcap.
add_of_ports__ () {
    local args
    local pcap=false
    local ptype=$1
    shift
    if test "$1" = --pcap; then
        pcap=:
    shift
    fi
    local br=$1; shift
    for pnum; do
        as_fn_append args " -- add-port $br p$pnum -- set Interface p$pnum type=$ptype ofport_request=$pnum"
    if $pcap; then
        as_fn_append args " -- set Interface p$pnum options:rxq_pcap=p$pnum-rx.pcap options:tx_pcap=p$pnum-tx.pcap"
    fi
    done
    echo ovs-vsctl $args
    ovs-vsctl $args
}

# add_of_ports [--pcap] BRIDGE PNUM...
#
add_of_ports () {
    add_of_ports__ dummy $@
}

# add_pmd_of_ports [--pcap] BRIDGE PNUM...
#
add_pmd_of_ports () {
    add_of_ports__ dummy-pmd $@
}

dump_diff__ () {
     local rcv_pcap=$1 exp_text=$2
     rcv_text=`echo "$rcv_pcap.packets" | sed 's/\.pcap//'`
     echo "Expected:"
     sort $exp_text
     echo "Received:"
     sort $rcv_text
     sort $exp_text -o $exp_text.sorted
     sort $rcv_text -o $rcv_text.sorted
     echo "Diff:"
     diff -u $exp_text.sorted $rcv_text.sorted
   }
   ovn_check_packets__ () {
     rcv_pcap=$1
     exp_text=$2
     cmd=${4-cat}
     echo "$3: checking packets in $1 against $2:"
     rcv_text=`echo "$rcv_pcap.packets" | sed 's/\.pcap//'`
     exp_n=`wc -l < "$exp_text"`
     check_ovs_wait_until_args "2" "dump_diff__ "$rcv_pcap" "$exp_text""
   ovs_wait_cond () {
    $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $rcv_pcap > rcv_tmp
        rcv_n=`wc -l < rcv_tmp`
        echo "rcv_n=$rcv_n exp_n=$exp_n"
        cat rcv_tmp > $rcv_text
        test $rcv_n -ge $exp_n
}
ovs_wait_failed () {
    :
    dump_diff__ "$rcv_pcap" "$exp_text"
}
ovs_wait "ovn-macros.at:12" "until \$PYTHON \"\$ovs_srcdir/utilities/ovs-pcap.in\" \$rcv_pcap > rcv_tmp
        rcv_n=\`wc -l < rcv_tmp\`
        echo \"rcv_n=\$rcv_n exp_n=\$exp_n\"
        cat rcv_tmp > \$rcv_text
        test \$rcv_n -ge \$exp_n"

     sort $exp_text | $cmd > expout
     cat rcv_tmp | $cmd > $rcv_text
   }
   ovn_check_packets_remove_broadcast__ () {
     rcv_pcap=$1
     exp_text=$2
     cmd=${4-cat}
     echo "$3: checking packets in $1 against $2:"
     rcv_text=`echo "$rcv_pcap.packets" | sed 's/\.pcap//'`
     exp_n=`wc -l < "$exp_text"`
     check_ovs_wait_until_args "2" "dump_diff__ "$rcv_pcap" "$exp_text""
   ovs_wait_cond () {
    $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $rcv_pcap > rcv_tmp
        sed -i '/ffffffffffff/d' rcv_tmp
        rcv_n=`wc -l < rcv_tmp`
        echo "rcv_n=$rcv_n exp_n=$exp_n"
        cat rcv_tmp > $rcv_text
        test $rcv_n -ge $exp_n
}
ovs_wait_failed () {
    :
    dump_diff__ "$rcv_pcap" "$exp_text"
}
ovs_wait "ovn-macros.at:12" "until \$PYTHON \"\$ovs_srcdir/utilities/ovs-pcap.in\" \$rcv_pcap > rcv_tmp
        sed -i '/ffffffffffff/d' rcv_tmp
        rcv_n=\`wc -l < rcv_tmp\`
        echo \"rcv_n=\$rcv_n exp_n=\$exp_n\"
        cat rcv_tmp > \$rcv_text
        test \$rcv_n -ge \$exp_n"

     sort $exp_text | $cmd > expout
     cat rcv_tmp | $cmd > $rcv_text
   }
   ovn_wait_packets__ () {
     rcv_pcap=$1
     exp_text=$2
     cmd=${4-cat}
     echo "$3: waiting packets from $2 at $1:"
     rcv_text=`echo "$rcv_pcap.packets" | sed 's/\.pcap//'`
     check_ovs_wait_until_args "2" "dump_diff__ "$rcv_pcap" "$exp_text""
   ovs_wait_cond () {
    $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $rcv_pcap > rcv_tmp
        sort $exp_text | $cmd > expout
        cat rcv_tmp | $cmd > $rcv_text
        test x"$(sort $rcv_text | comm -2 -3 expout -)" = "x"
}
ovs_wait_failed () {
    :
    dump_diff__ "$rcv_pcap" "$exp_text"
}
ovs_wait "ovn-macros.at:12" "until \$PYTHON \"\$ovs_srcdir/utilities/ovs-pcap.in\" \$rcv_pcap > rcv_tmp
        sort \$exp_text | \$cmd > expout
        cat rcv_tmp | \$cmd > \$rcv_text
        test x\"\$(sort \$rcv_text | comm -2 -3 expout -)\" = \"x\""

   }

   ovn_wait_packets_uniq__ () {
     rcv_pcap=$1
     exp_text=$2
     cmd=${4-cat}
     echo "$3: waiting for packets from $2 at $1:"
     rcv_text=`echo "$rcv_pcap.packets" | sed 's/\.pcap//'`
     check_ovs_wait_until_args "2" "dump_diff__ "$rcv_pcap" "$exp_text""
   ovs_wait_cond () {
    $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $rcv_pcap > $rcv_text
        sort $exp_text | $cmd > expout
        test x"$(sort $rcv_text | $cmd | uniq | comm -3 expout -)" = "x"
}
ovs_wait_failed () {
    :
    dump_diff__ "$rcv_pcap" "$exp_text"
}
ovs_wait "ovn-macros.at:12" "until \$PYTHON \"\$ovs_srcdir/utilities/ovs-pcap.in\" \$rcv_pcap > \$rcv_text
        sort \$exp_text | \$cmd > expout
        test x\"\$(sort \$rcv_text | \$cmd | uniq | comm -3 expout -)\" = \"x\""

   }

   ovn_wait_patch_port_flows () {
     for localnet in $1; do
       patch_port="patch-br-int-to-$localnet"
       for hv in $2; do
         echo "$3: waiting for flows for $patch_port on $hv"
         # Patch port might be created after ports are reported up
         check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {

             test 1 = $(as $hv ovs-vsctl show | grep "Port \b$patch_port\b" | wc -l)

}
ovs_wait_failed () {
    :

}
ovs_wait "ovn-macros.at:12" "until
             test 1 = \$(as \$hv ovs-vsctl show | grep \"Port \\b\$patch_port\\b\" | wc -l)
         "

         # Wait for a flow outputing to patch port
         check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {

             hv_patch_ofport=$(as $hv ovs-vsctl --bare --columns ofport find Interface name=$patch_port)
             echo "$patch_port=$hv_patch_ofport"
             test -n "$hv_patch_ofport" && test 1 -le $(as $hv ovs-ofctl dump-flows br-int | grep -c "output:\b$hv_patch_ofport\b")

}
ovs_wait_failed () {
    :

}
ovs_wait "ovn-macros.at:12" "until
             hv_patch_ofport=\$(as \$hv ovs-vsctl --bare --columns ofport find Interface name=\$patch_port)
             echo \"\$patch_port=\$hv_patch_ofport\"
             test -n \"\$hv_patch_ofport\" && test 1 -le \$(as \$hv ovs-ofctl dump-flows br-int | grep -c \"output:\\b\$hv_patch_ofport\\b\")
         "

       done
     done
   }

   ovn_wait_remote_output_flows () {
     hv1=$1
     hv2=$2
     echo "$3: waiting for flows for remote output on $hv1"
     # Wait for a flow outputing  to remote output
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {

         ofport=$(as $hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-${hv2}-0)
         echo "tunnel port=$ofport"
         test -n "$ofport" && test 1 -le $(as $hv1 ovs-ofctl dump-flows br-int | grep -c "output:$ofport")

}
ovs_wait_failed () {
    :

}
ovs_wait "ovn-macros.at:12" "until
         ofport=\$(as \$hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-\${hv2}-0)
         echo \"tunnel port=\$ofport\"
         test -n \"\$ofport\" && test 1 -le \$(as \$hv1 ovs-ofctl dump-flows br-int | grep -c \"output:\$ofport\")
     "

   }

   ovn_wait_remote_input_flows () {
     hv1=$1
     hv2=$2
     echo "$3: waiting for flows for remote input on $hv1"
     # Wait for a flow outputing  to remote input
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {

         ofport=$(as $hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-${hv2}-0)
         echo "tunnel port=$ofport"
         test -n "$ofport" && test 1 -le $(as $hv1 ovs-ofctl dump-flows br-int | grep -c "in_port=$ofport")

}
ovs_wait_failed () {
    :

}
ovs_wait "ovn-macros.at:12" "until
         ofport=\$(as \$hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-\${hv2}-0)
         echo \"tunnel port=\$ofport\"
         test -n \"\$ofport\" && test 1 -le \$(as \$hv1 ovs-ofctl dump-flows br-int | grep -c \"in_port=\$ofport\")
     "

   }

   # ovn_wait_for_bfd_up HV
   # BFD might be quite slow. While BFD is not up, all chassis will fight to claim the port
   # Wait for BFD between different chassis to be up
   ovn_wait_for_bfd_up() {
     for hv; do
       as $hv
       for chassis; do
         if test $hv != $chassis; then
             echo "checking bdf_status for $hv -> $chassis"
             check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {

                 bfd_status=$(as $hv ovs-vsctl get interface ovn-$chassis-0 bfd_status:state)
                 echo "bfd status = $bfd_status"
                 test "$bfd_status" = "up"

}
ovs_wait_failed () {
    :

}
ovs_wait "ovn-macros.at:12" "until
                 bfd_status=\$(as \$hv ovs-vsctl get interface ovn-\$chassis-0 bfd_status:state)
                 echo \"bfd status = \$bfd_status\"
                 test \"\$bfd_status\" = \"up\"
             "

         fi
       done
     done
   }



# ovn_init_db DATABASE [AZ]
#
# Creates and initializes the given DATABASE (one of "ovn-sb" or "ovn-nb"),
# starts its ovsdb-server instance, and sets the appropriate environment
# variable (OVN_SB_DB or OVN_NB_DB) so that ovn-sbctl or ovn-nbctl uses the
# database by default.
#
# Usually invoked from ovn_start.
ovn_init_db () {
    echo "${AZ:+$AZ: }creating $1 database"
    local as_d=$1
    if test -n "$2"; then
        as_d=$2/$as_d
    fi
    local d=$ovs_base/$as_d
    mkdir "$d" || return 1
    : > "$d"/.$1.db.~lock~
    as $as_d ovsdb-tool create "$d"/$1.db "$abs_top_srcdir"/$1.ovsschema

    local remote_in_db=
    if test X$HAVE_OPENSSL = Xyes -a X"$1" = X"ovn-sb"; then
        remote_in_db="--remote=db:OVN_Southbound,SB_Global,connections --private-key=$PKIDIR/testpki-test-privkey.pem --certificate=$PKIDIR/testpki-test-cert.pem --ca-cert=$PKIDIR/testpki-cacert.pem"
    fi

    as $as_d start_daemon ovsdb-server \
        -vjsonrpc \
        --remote=punix:"$d"/$1.sock \
        $remote_in_db \
        "$d"/$1.db

    local var=`echo $1_db | tr a-z- A-Z_`
    eval "$var=unix:\"\$d\"/\$1.sock"; export $var
}

# ovn_init_ic_db
#
# Creates and initializes ovn-ic-nb and ovn-ic-sb databases and starts their
# ovsdb-server instances, for OVN interconnection.
ovn_init_ic_db () {
    ovn_init_db ovn-ic-nb
    ovn_init_db ovn-ic-sb
}

# ovn_start_northd [--paused] (primary|backup) [AZ]
ovn_start_northd() {
    local northd_args=
    case $1 in
        --paused) northd_args=--dry-run; shift ;;
    esac
    local priority=$1
    local AZ=$2
    local msg_prefix=${AZ:+$AZ: }
    local d_prefix=${AZ:+$AZ/}

    local suffix=
    case $priority in
        backup) suffix=-backup ;;
    esac

    if test X$NORTHD_USE_PARALLELIZATION = Xyes; then
        northd_args="$northd_args --n-threads=4"
    fi

    local name=${d_prefix}northd${suffix}
    echo "${prefix}starting $name"
    test -d "$ovs_base/$name" || mkdir "$ovs_base/$name"
    as $name start_daemon ovn-northd $northd_args -vjsonrpc \
               --ovnnb-db=$OVN_NB_DB --ovnsb-db=$OVN_SB_DB
}

# ovn_start [--backup-northd=none|paused] [AZ]
#
# Creates and initializes ovn-sb and ovn-nb databases and starts their
# ovsdb-server instance, sets appropriate environment variables so that
# ovn-sbctl and ovn-nbctl use them by default, and starts ovn-northd running
# against them.
#
# Normally this starts only an active northd and no backup northd.  The following
# options are accepted to adjust that:
#   --backup-northd         Start a backup northd.
#   --backup-northd=paused  Start the backup northd in the paused state.
#   --use-tcp-to-sb         Use tcp to connect to sb.
ovn_start () {
    local backup_northd=false
    local backup_northd_options=
    case $1 in
        --backup-northd) backup_northd=true; shift ;;
        --backup-northd=paused) backup_northd=true; backup_northd_options=--paused; shift ;;
        --use-tcp-to-sb) use_tcp=true; shift ;;
    esac
    local AZ=$1
    local msg_prefix=${AZ:+$AZ: }
    local d_prefix=${AZ:+$AZ/}

    if test -n "$AZ"; then
        mkdir "$ovs_base"/$AZ
    fi

    ovn_init_db ovn-sb $1; ovn-sbctl init
    ovn_init_db ovn-nb $1; ovn-nbctl init
    if test -n "$1"; then
        check ovn-nbctl set NB_Global . name=$1
    fi

    ovn_start_northd primary $AZ
    if $backup_northd; then
        ovn_start_northd $backup_northd_options backup $AZ
    fi

    if test $use_tcp; then
        # Create the SB DB ptcp connection.
        ovn-sbctl \
            -- --id=@c create connection \
                target=\"ptcp:0:127.0.0.1\" \
            -- add SB_Global . connections @c
    elif test X$HAVE_OPENSSL = Xyes; then
        # Create the SB DB pssl+RBAC connection.
        ovn-sbctl \
            -- --id=@c create connection \
                target=\"pssl:0:127.0.0.1\" role=ovn-controller \
            -- add SB_Global . connections @c
        local d=$ovs_base
        if test -n "$AZ"; then
            d=$d/$AZ
        fi
        check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    TCP_PORT=`sed -n 's/.*0:.*: listening on port \([0-9]*\)$/\1/p' "$d/ovn-sb/ovsdb-server.log"` && test X != X"$TCP_PORT"
}
ovs_wait_failed () {
    :

}
ovs_wait "ovn-macros.at:632" "until TCP_PORT=\`sed -n 's/.*0:.*: listening on port \\([0-9]*\\)\$/\\1/p' \"\$d/ovn-sb/ovsdb-server.log\"\` && test X != X\"\$TCP_PORT\""

        var="SSL_OVN_SB_DB"
        eval "$var=ssl:127.0.0.1:\$TCP_PORT"; export $var
    fi

    if test -n "$AZ"; then
        check ovn-nbctl --wait=sb sync || exit $?

        echo "${msg_prefix}starting ovn-ic"
        mkdir "$ovs_base"/$d_prefix/ic
        as $d_prefix/ic start_daemon ovn-ic -v \
               --ovnnb-db=$OVN_NB_DB --ovnsb-db=$OVN_SB_DB \
               --ic-nb-db=unix:"$ovs_base"/ovn-ic-nb/ovn-ic-nb.sock \
               --ic-sb-db=unix:"$ovs_base"/ovn-ic-sb/ovn-ic-sb.sock
    fi
}

# Interconnection networks.
#
# When multiple sandboxed Open vSwitch instances exist, one will inevitably
# want to connect them together.  These commands allow for that.  Conceptually,
# an interconnection network is a switch for which these functions make it easy
# to plug into other switches in other sandboxed Open vSwitch instances.
# Interconnection networks are implemented as bridges in a switch named "main",
# so to use interconnection networks please avoid working with that switch
# directly.

# net_add NETWORK
#
# Creates a new interconnection network named NETWORK.
net_add () {
    test -d "$ovs_base"/main || sim_add main || return 1
    as main ovs-vsctl add-br "$1"
}

# net_attach NETWORK BRIDGE
#
# Adds a new port to BRIDGE in the default sandbox (as set with as()) and plugs
# it into the NETWORK interconnection network.  NETWORK must already have been
# created by a previous invocation of net_add.  The default sandbox must not be
# "main".
net_attach () {
    local net=$1 bridge=$2

    local port=${sandbox}_$bridge
    as main ovs-vsctl \
        -- add-port $net $port \
        -- set Interface $port options:pstream="punix:$ovs_base/main/$port.sock" options:rxq_pcap="$ovs_base/main/$port-rx.pcap" options:tx_pcap="$ovs_base/main/$port-tx.pcap" \
        || return 1

    ovs-vsctl \
        -- set Interface $bridge options:tx_pcap="$ovs_base/$sandbox/$bridge-tx.pcap" options:rxq_pcap="$ovs_base/$sandbox/$bridge-rx.pcap" \
        -- add-port $bridge ${bridge}_$net \
        -- set Interface ${bridge}_$net options:stream="unix:$ovs_base/main/$port.sock" options:rxq_pcap="$ovs_base/$sandbox/${bridge}_$net-rx.pcap" options:tx_pcap="$ovs_base/$sandbox/${bridge}_$net-tx.pcap" \
        || return 1
}

ovn_wait_for_encaps() {
    local systemid=$1

    if [ -f "${OVN_SYSCONFDIR}/system-id-override" ]; then
        systemid=$(cat ${OVN_SYSCONFDIR}/system-id-override)
    fi

    local encap=$(ovs-vsctl get Open_vSwitch . external_ids:ovn-encap-type-$systemid)
    if [ -z "$encap" ]; then
        encap=$(ovs-vsctl get Open_vSwitch . external_ids:ovn-encap-type)
    fi
    encap=$(tr -d '"' <<< $encap)

    local ip=$(ovs-vsctl get Open_vSwitch . external_ids:ovn-encap-ip-$systemid)
    if [ -z "$ip" ]; then
        ip=$(ovs-vsctl get Open_vSwitch . external_ids:ovn-encap-ip)
    fi
    ip=$(tr -d '"' <<< $ip)

    IFS="," read -r -a encap_types <<< "$encap"
    for e in "${encap_types[@]}"; do
        wait_column "$ip" sb:Encap ip chassis_name="$systemid" type="$e"
    done
}

# ovn_az_attach AZ NETWORK BRIDGE IP [MASKLEN] [ENCAP]
ovn_az_attach() {
    local az=$1 net=$2 bridge=$3 ip=$4 masklen=${5-24} encap=${6-geneve,vxlan}
    local systemid=${7-$sandbox} systemid_override=$8
    net_attach $net $bridge || return 1

    local expected_encap_id=$systemid
    local cli_args=""
    if [ -n "$systemid_override" ]; then
        cli_args="-n $systemid_override"
        expected_encap_id=$systemid_override
    fi

    mac=`ovs-vsctl get Interface $bridge mac_in_use | sed s/\"//g`
    arp_table="$arp_table $sandbox,$bridge,$ip,$mac"
    if test -z $(echo $ip | sed '/:/d'); then
        ipversion="6"
    else
        ipversion="4"
    fi
    ovs-appctl netdev-dummy/ip${ipversion}addr $bridge $ip/$masklen >/dev/null || return 1
    ovs-appctl ovs/route/add $ip/$masklen $bridge >/dev/null || return 1

    local ovn_remote
    if test X"$az" = XNONE; then
        if test X$HAVE_OPENSSL = Xyes; then
            ovn_remote=$SSL_OVN_SB_DB
        else
            ovn_remote=unix:$ovs_base/ovn-sb/ovn-sb.sock
        fi
    else
        ovn_remote=unix:$ovs_base/$az/ovn-sb/ovn-sb.sock
    fi
    ovs-vsctl \
        -- set Open_vSwitch . external-ids:hostname=$sandbox \
        -- set Open_vSwitch . external-ids:system-id=$systemid \
        -- set Open_vSwitch . external-ids:ovn-remote=$ovn_remote \
        -- set Open_vSwitch . external-ids:ovn-encap-type=$encap \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=$ip \
        -- --may-exist add-br br-int \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true \
        || return 1

    # currently this is the optimal place to add the ovn-monitor-all=true option,
    # this can be implemented in a different way by redefining the sim-add function
    # to add the ovn-related external-ids when we add a new simulated node via sim-add.
    #
    if test X$OVN_MONITOR_ALL = Xyes; then
        ovs-vsctl set open . external_ids:ovn-monitor-all=true
    fi

    start_daemon ovn-controller --enable-dummy-vif-plug ${cli_args} || return 1
    if test X"$az" = XNONE; then
        ovn_wait_for_encaps $expected_encap_id
    else
        ovn_as $az ovn_wait_for_encaps $expected_encap_id
    fi
}

# ovn_attach NETWORK BRIDGE IP [MASKLEN] [ENCAP]
#
# First, this command attaches BRIDGE to interconnection network NETWORK, just
# like "net_attach NETWORK BRIDGE".  Second, it configures (simulated) IP
# address IP (with network mask length MASKLEN, which defaults to 24) on
# BRIDGE.  Finally, it configures the Open vSwitch database to work with OVN
# and starts ovn-controller.
ovn_attach() {
    ovn_az_attach NONE $@
}

# This function is similar to ovn_attach but makes sure it doesn't
# mess with another controller settings
start_virtual_controller() {
    local net=$1 bridge=$2 int_bridge=$3 ip=$4 masklen=${5-24} encap=${6-geneve,vxlan} systemid=${7-$sandbox} cli_args=${@:8}
    net_attach $net $bridge || return 1

    mac=`ovs-vsctl get Interface $bridge mac_in_use | sed s/\"//g`
    arp_table="$arp_table $sandbox,$bridge,$ip,$mac"
    ovs-appctl netdev-dummy/ip4addr $bridge $ip/$masklen >/dev/null || return 1
    ovs-appctl ovs/route/add $ip/$masklen $bridge >/dev/null || return 1

    local ovn_remote
    if test X$HAVE_OPENSSL = Xyes; then
        ovn_remote=$SSL_OVN_SB_DB
    else
        ovn_remote=unix:$ovs_base/ovn-sb/ovn-sb.sock
    fi
    ovs-vsctl \
        -- set Open_vSwitch . external-ids:ovn-remote-$systemid=$ovn_remote \
        -- set Open_vSwitch . external-ids:ovn-encap-type-$systemid=$encap \
        -- set Open_vSwitch . external-ids:ovn-encap-ip-$systemid=$ip \
        -- set Open_vSwitch . external-ids:ovn-bridge-$systemid=$int_bridge \
        -- --may-exist add-br $int_bridge \
        -- set bridge $int_bridge fail-mode=secure other-config:disable-in-band=true \
        || return 1

    ovn-controller --enable-dummy-vif-plug ${cli_args} -vconsole:off --detach --no-chdir
    ovn_wait_for_encaps $systemid
}

# ovn_setenv AZ
ovn_setenv () {
    local d=$ovs_base/$1
    AZ_DIR="$d"/; export $var
    OVN_NB_DB=unix:"$d"/ovn-nb/ovn-nb.sock; export $var
    OVN_SB_DB=unix:"$d"/ovn-sb/ovn-sb.sock; export $var
}

# ovs_as AZ
ovn_as() {
    if test "X$2" != X; then
        (ovn_setenv $1; shift; "$@")
    else
        ovn_setenv $1
    fi
}

# OVN_POPULATE_ARP
#
# This pre-populates the ARP tables of all of the OVN instances that have been
# started with ovn_attach().  That means that packets sent from one hypervisor
# to another never get dropped or delayed by ARP resolution, which makes
# testing easier.
ovn_populate_arp__() {
    for e1 in $arp_table; do
        set `echo $e1 | sed 's/,/ /g'`; sb1=$1 br1=$2 ip=$3 mac=$4
        for e2 in $arp_table; do
            set `echo $e2 | sed 's/,/ /g'`; sb2=$1 br2=$2
            if test $sb1,$br1 != $sb2,$br2; then
                as $sb2 ovs-appctl tnl/neigh/set $br2 $ip $mac || return 1
            fi
        done
    done
}

# check COMMAND...
#
# Runs COMMAND and checks that it succeeds without any output.
check() {
    echo "$@"
    { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:856: \"\$@\""
at_fn_check_prepare_dynamic "\"$@\"" "ovn-macros.at:856"
( $at_check_trace; "$@"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:856"
$at_failed && at_fn_log_failure
$at_traceon; }

}

# Runs COMMAND and checks that it does not print anything else than uuid as output.
# It also fails if the output is empty.
check_uuid() {
    echo "$@"
    output=$("${@}")
    { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:864: echo \"\$output\" | grep ."
at_fn_check_prepare_notrace 'a shell pipeline' "ovn-macros.at:864"
( $at_check_trace; echo "$output" | grep .
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:864"
if $at_failed
then :
  echo "Unexpected empty output: check_uuid is expecting a UUID"
fi
$at_failed && at_fn_log_failure
$at_traceon; }

    { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:865: echo \"\$output\" | grep -vE '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\$'"
at_fn_check_prepare_notrace 'a shell pipeline' "ovn-macros.at:865"
( $at_check_trace; echo "$output" | grep -vE '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/ovn-macros.at:865"
$at_failed && at_fn_log_failure
$at_traceon; }

}

parse_db() {
    case $1 in
        (*:*) echo ${1%%:*} ;;
        (*) echo sb ;;
    esac
}

parse_table() {
    case $1 in
        (*:*) echo ${1##*:} ;;
        (*) echo $1 ;;
    esac
}

# count_rows TABLE [CONDITION...]
#
# Prints the number of rows in TABLE (that satisfy CONDITION).
# Uses the southbound db by default; set DB=nb for the northbound database.
count_rows() {
    local db=$(parse_db $1) table=$(parse_table $1); shift
    ovn-${db}ctl --format=table --no-headings find $table "$@" | wc -l
}

# check_row_count [DATABASE:]TABLE COUNT [CONDITION...]
#
# Checks that TABLE contains COUNT rows (that satisfy CONDITION).
# The default DATABASE is "sb".
check_row_count() {
    local db=$(parse_db $1) table=$(parse_table $1); shift
    local count=$1; shift
    local found=$(count_rows $db:$table "$@")
    echo
    echo "Checking for $count rows in $db $table${1+ with $*}... found $found"
    if test "$count" != "$found"; then
        ovn-${db}ctl list $table
        printf "%s\n" "ovn-macros.at:903" >"$at_check_line_file"
at_fn_check_skip 99 "$at_srcdir/ovn-macros.at:903"
    fi
}

# wait_row_count [DATABASE:]TABLE COUNT [CONDITION...]
#
# Waits until TABLE contains COUNT rows (that satisfy CONDITION).
# The default DATABASE is "sb".
wait_row_count() {
    local db=$(parse_db $1) table=$(parse_table $1); shift
    local count=$1; shift
    local a=$1 b=$2 c=$3 d=$4 e=$5
    echo "Waiting until $count rows in $db $table${1+ with $*}..."
    check_ovs_wait_until_args "2" "
      echo "$db table $table has the following rows. $(count_rows $db:$table $a $b $c $d $e) rows match instead of expected $count:"
      ovn-${db}ctl list $table"
   ovs_wait_cond () {
    test $count = $(count_rows $db:$table $a $b $c $d $e)
}
ovs_wait_failed () {
    :

      echo "$db table $table has the following rows. $(count_rows $db:$table $a $b $c $d $e) rows match instead of expected $count:"
      ovn-${db}ctl list $table
}
ovs_wait "ovn-macros.at:916" "until test \$count = \$(count_rows \$db:\$table \$a \$b \$c \$d \$e)"

}

# fetch_column [DATABASE:]TABLE COLUMN [CONDITION...]
#
# Fetches and prints all the values of COLUMN in the rows of TABLE
# (that satisfy CONDITION), sorting the results lexicographically.
# The default DATABASE is "sb".
fetch_column() {
    local db=$(parse_db $1) table=$(parse_table $1) column=${2-_uuid}; shift; shift
    # Using "echo" removes spaces and newlines.
    echo $(ovn-${db}ctl --bare --columns $column find $table "$@" | sort)
}

# check_column EXPECTED [DATABASE:]TABLE COLUMN [CONDITION...]
#
# Fetches all of the values of COLUMN in the rows of TABLE (that
# satisfy CONDITION), and compares them against EXPECTED (ignoring
# order).
#
# The default DATABASE is "sb".
check_column() {
    local expected=$1 db=$(parse_db $2) table=$(parse_table $2) column=${3-_uuid}; shift; shift; shift
    local found=$(ovn-${db}ctl --bare --columns $column find $table "$@")

    # Sort the expected and found values.
    local found=$(for d in $found; do echo $d; done | sort)
    local expected=$(for d in $expected; do echo $d; done | sort)

    echo
    echo "Checking values in $db $table${1+ with $*} against $expected... found $found"
    if test "$found" != "$expected"; then
        ovn-${db}ctl list $table
        printf "%s\n" "ovn-macros.at:951" >"$at_check_line_file"
at_fn_check_skip 99 "$at_srcdir/ovn-macros.at:951"
    fi
}

# wait_column EXPECTED [DATABASE:]TABLE [COLUMN [CONDITION...]]
#
# Wait until all of the values of COLUMN in the rows of TABLE (that
# satisfy CONDITION) equal EXPECTED (ignoring order).
#
# The default DATABASE is "sb".
#
# COLUMN defaults to _uuid if unspecified.
wait_column() {
    local expected=$(for d in $1; do echo $d; done | sort)
    local db=$(parse_db $2) table=$(parse_table $2) column=${3-_uuid}; shift; shift; shift
    local a=$1 b=$2 c=$3 d=$4 e=$5

    echo
    echo "Waiting until $column in $db $table${1+ with $*} is $expected..."
    check_ovs_wait_until_args "2" "
      echo "$column in $db table $table has value $found, from the following rows:"
      ovn-${db}ctl list $table"
   ovs_wait_cond () {

      found=$(ovn-${db}ctl --bare --columns $column find $table $a $b $c $d $e)
      found=$(for d in $found; do echo $d; done | sort)
      test "$expected" = "$found"

}
ovs_wait_failed () {
    :

      echo "$column in $db table $table has value $found, from the following rows:"
      ovn-${db}ctl list $table
}
ovs_wait "ovn-macros.at:970" "until
      found=\$(ovn-\${db}ctl --bare --columns \$column find \$table \$a \$b \$c \$d \$e)
      found=\$(for d in \$found; do echo \$d; done | sort)
      test \"\$expected\" = \"\$found\"
    "

}

# wait_for_ports_up [PORT...]
#
# With arguments, waits for specified Logical_Switch_Ports to come up.
# Without arguments, waits for all "plain" and router
# Logical_Switch_Ports to come up.
wait_for_ports_up() {
    if test $# = 0; then
        wait_row_count nb:Logical_Switch_Port 0 up!=true type='""'
        wait_row_count nb:Logical_Switch_Port 0 up!=true type=router
    else
        for port; do
            wait_row_count nb:Logical_Switch_Port 1 up=true name=$port
        done
    fi
}

# reset_pcap_file iface pcap_file
# Resets the pcap file associates with OVS interface.  should be used
# with dummy datapath.
reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    check rm -f dummy-*.pcap
    check ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    check rm -f ${pcap_file}*.pcap
    check ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

# Receive a packet on a dummy netdev interface. If we expect packets to be
# recorded, then wait until the pcap file reflects the change.
netdev_dummy_receive() {
    local interface="$1"
    local packet="$2"
    local hv="$3"
    local pcap_file="$4"

    if test -n "pcap_file" ; then
        ts_old=$(stat -c %y "$pcap_file")
    fi
    if test -n "$hv" ; then
        as "$hv" ovs-appctl netdev-dummy/receive "$interface" "$packet"
    else
        ovs-appctl netdev-dummy/receive "$interface" "$packet"
    fi
    if test -n "$pcap_file" ; then
        ovs_wait_cond () {
    if ts_new=$(stat -c %y "$pcap_file")
           test "$ts_new" = "$ts_old"; then return 1; else return 0; fi
}
ovs_wait_failed () {
    :

}
ovs_wait "ovn-macros.at:1026" "while ts_new=\$(stat -c %y \"\$pcap_file\")
           test \"\$ts_new\" = \"\$ts_old\""

    fi
}

# send_igmp_v3_report INPORT HV ETH_SRC IP_SRC IP_CSUM GROUP REC_TYPE
#                     IGMP_CSUM OUTFILE
#
# This shell function causes an IGMPv3 report to be received on INPORT of HV.
# The packet's content has Ethernet destination 01:00:5E:00:00:22 and source
# ETH_SRC (exactly 12 hex digits). Ethernet type is set to IP.
# GROUP is the IP multicast group to be joined/to leave (based on REC_TYPE).
# REC_TYPE == 04: join GROUP
# REC_TYPE == 03: leave GROUP
# The packet hexdump is also stored in OUTFILE.
#
send_igmp_v3_report() {
    local inport=$1 hv=$2 eth_src=$3 ip_src=$4 ip_chksum=$5 group=$6
    local rec_type=$7 igmp_chksum=$8 outfile=$9

    local eth_dst=01005e000016
    local ip_dst=$(ip_to_hex 224 0 0 22)
    local ip_ttl=01
    local ip_ra_opt=94040000

    local igmp_type=2200
    local num_rec=00000001
    local aux_dlen=00
    local num_src=0000

    local eth=${eth_dst}${eth_src}0800
    local ip=46c0002800004000${ip_ttl}02${ip_chksum}${ip_src}${ip_dst}${ip_ra_opt}
    local igmp=${igmp_type}${igmp_chksum}${num_rec}${rec_type}${aux_dlen}${num_src}${group}
    local packet=${eth}${ip}${igmp}

    echo ${packet} >> ${outfile}
    check as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

# store_igmp_v3_query ETH_SRC IP_SRC IP_CSUM OUTFILE
#
# This shell function builds an IGMPv3 general query from ETH_SRC and IP_SRC
# and stores the hexdump of the packet in OUTFILE.
#
store_igmp_v3_query() {
    local eth_src=$1 ip_src=$2 ip_chksum=$3 outfile=$4

    local eth_dst=01005e000001
    local ip_dst=$(ip_to_hex 224 0 0 1)
    local ip_ttl=01
    local igmp_type=11
    local max_resp=0a
    local igmp_chksum=eeeb
    local addr=00000000

    local eth=${eth_dst}${eth_src}0800
    local ip=4500002000004000${ip_ttl}02${ip_chksum}${ip_src}${ip_dst}
    local igmp=${igmp_type}${max_resp}${igmp_chksum}${addr}000a0000
    local packet=${eth}${ip}${igmp}

    echo ${packet} >> ${outfile}
}

# send_igmp_v3_query INPORT HV ETH_SRC IP_SRC IP_CSUM OUTFILE
#
# This shell function builds and sends an IGMPv3 general query from
# ETH_SRC and IP_SRC and stores the hexdump of the packet in OUTFILE.
#
send_igmp_v3_query() {
    local inport=$1 hv=$2 eth_src=$3 ip_src=$4 ip_chksum=$5 outfile=$6

    local eth_dst=01005e000001
    local ip_dst=$(ip_to_hex 224 0 0 1)
    local ip_ttl=01
    local igmp_type=11
    local max_resp=0a
    local igmp_chksum=eeeb
    local addr=00000000

    local eth=${eth_dst}${eth_src}0800
    local ip=4500002000004000${ip_ttl}02${ip_chksum}${ip_src}${ip_dst}
    local igmp=${igmp_type}${max_resp}${igmp_chksum}${addr}000a0000
    local packet=${eth}${ip}${igmp}

    echo ${packet} >> ${outfile}
    check as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

# send_ip_multicast_pkt INPORT HV ETH_SRC ETH_DST IP_SRC IP_DST IP_LEN TTL
#    IP_CHKSUM IP_PROTO DATA
#
# This shell function causes an IP multicast packet to be received on INPORT
# of HV.
# The hexdump of the packet is stored in OUTFILE.
#
send_ip_multicast_pkt() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4
    local ip_src=$5 ip_dst=$6 ip_len=$7 ip_ttl=$8 ip_chksum=$9 proto=${10}
    local data=${11}

    local eth=${eth_dst}${eth_src}0800
    local ip=450000${ip_len}95f14000${ip_ttl}${proto}${ip_chksum}${ip_src}${ip_dst}
    local packet=${eth}${ip}${data}

    check as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

# store_ip_multicast_pkt ETH_SRC ETH_DST IP_SRC IP_DST IP_LEN TTL
#    IP_CHKSUM IP_PROTO DATA OUTFILE
#
# This shell function builds an IP multicast packet and stores the hexdump of
# the packet in OUTFILE.
#
store_ip_multicast_pkt() {
    local eth_src=$1 eth_dst=$2
    local ip_src=$3 ip_dst=$4 ip_len=$5 ip_ttl=$6 ip_chksum=$7 proto=$8
    local data=$9 outfile=${10}

    local eth=${eth_dst}${eth_src}0800
    local ip=450000${ip_len}95f14000${ip_ttl}${proto}${ip_chksum}${ip_src}${ip_dst}
    local packet=${eth}${ip}${data}

    echo ${packet} >> ${outfile}
}

# send_mld_v2_report INPORT HV ETH_SRC IP_SRC GROUP REC_TYPE
#                    MLD_CSUM OUTFILE
#
# This shell function causes an MLDv2 report to be received on INPORT of HV.
# The packet's content has Ethernet destination 33:33:00:00:00:16 and source
# ETH_SRC (exactly 12 hex digits). Ethernet type is set to IPv6.
# GROUP is the IPv6 multicast group to be joined/to leave (based on REC_TYPE).
# REC_TYPE == 04: join GROUP
# REC_TYPE == 03: leave GROUP
# The packet hexdump is also stored in OUTFILE.
#
send_mld_v2_report() {
    local inport=$1 hv=$2 eth_src=$3 ip_src=$4 group=$5
    local rec_type=$6 mld_chksum=$7 outfile=$8

    local eth_dst=333300000016
    local ip_dst=ff020000000000000000000000000016
    local ip_ttl=01
    local ip_ra_opt=3a00050200000100

    local mld_type=8f
    local mld_code=00
    local num_rec=0001
    local aux_dlen=00
    local num_src=0000

    local eth=${eth_dst}${eth_src}86dd
    local ip=60000000002400${ip_ttl}${ip_src}${ip_dst}${ip_ra_opt}
    local mld=${mld_type}${mld_code}${mld_chksum}0000${num_rec}${rec_type}${aux_dlen}${num_src}${group}
    local packet=${eth}${ip}${mld}

    echo ${packet} >> ${outfile}
    check as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

# store_mld_query ETH_SRC IP_SRC OUTFILE
#
# This shell function builds an MLD general query from ETH_SRC and IP_SRC
# and stores the hexdump of the packet in OUTFILE.
#
store_mld_query() {
    local eth_src=$1 ip_src=$2 outfile=$3

    local eth_dst=333300000000
    local ip_dst=ff020000000000000000000000000001
    local ip_ttl=01
    local ip_ra_opt=3a00050200000000

    local mld_type=82
    local mld_code=00
    local max_resp=03e8
    local mld_chksum=7b3d
    local addr=00000000000000000000000000000000

    local eth=${eth_dst}${eth_src}86dd
    local ip=60000000002400${ip_ttl}${ip_src}${ip_dst}${ip_ra_opt}
    local mld=${mld_type}${mld_code}${mld_chksum}${max_resp}0000${addr}00010000
    local packet=${eth}${ip}${mld}

    echo ${packet} >> ${outfile}
}

# send_ip6_multicast_pkt INPORT HV ETH_SRC ETH_DST IP_SRC IP_DST IP_LEN TTL
#    IP_PROTO DATA
#
# This shell function causes an IP multicast packet to be received on INPORT
# of HV.
#
send_ip6_multicast_pkt() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4
    local ip_src=$5 ip_dst=$6 ip_len=$7 ip_ttl=$8 proto=$9
    local data=${10}

    local eth=${eth_dst}${eth_src}86dd
    local ip=60000000${ip_len}${proto}${ip_ttl}${ip_src}${ip_dst}
    local packet=${eth}${ip}${data}

    check as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

# store_ip6_multicast_pkt ETH_SRC ETH_DST IP_SRC IP_DST IP_LEN TTL
#    IP_PROTO DATA OUTFILE
#
# This shell function builds an IP multicast packet and stores the hexdump of
# the packet in OUTFILE.
#
store_ip6_multicast_pkt() {
    local eth_src=$1 eth_dst=$2
    local ip_src=$3 ip_dst=$4 ip_len=$5 ip_ttl=$6 proto=$7
    local data=$8 outfile=$9

    local eth=${eth_dst}${eth_src}86dd
    local ip=60000000${ip_len}${proto}${ip_ttl}${ip_src}${ip_dst}
    local packet=${eth}${ip}${data}

    echo ${packet} >> ${outfile}
}

hex_to_mac() {
    mac_hex=$1
    echo $mac_hex | sed 's/../&:/g;s/:$//'
}

send_garp() {
    printf "%s\n" "ovn-macros.at:1256" >"$at_check_line_file"
(test $HAVE_SCAPY = no) \
  && at_fn_check_skip 77 "$at_srcdir/ovn-macros.at:1256"
    local hv=$1 inport=$2 op=$3 eth_src=$4 eth_dst=$5 spa=$6 tpa=$7

    local packet=$(fmt_pkt "Ether(dst='${eth_dst}', src='${eth_src}')/ \
                      ARP(op=$op, hwsrc='${eth_src}', hwdst='${eth_src}', \
                      psrc='${spa}', pdst='${tpa}')")
    echo "Sending GARP($op) $eth_src $eth_dst $spa $tpa packet=$packet on $hv"
    check as $hv ovs-appctl netdev-dummy/receive $inport $packet
}

# Wrapper on top of ovn-trace, stripping some things and storing the trace
# output to a file called 'trace'.  For now it strips the rows starting
# with a '#'.  This should correspond to the flow key and might be displayed
# differently by different OVS library versions.
ovn_trace() {

    ovn-trace "$@" | tee trace | sed '/^# /d'
}

# Same as ovn_trace() except that it connects to an ovn-trace daemon.
ovn_trace_client() {
    target=$1; shift

    ovn-appctl -t $target trace "$@" | tee trace | sed '/^# /d'
}

# Receives a string with scapy python code that represents a packet.
# Returns a hex-string that contains bytes that reflect the packet symbolic
# description.
#
# Scapy docs: https://scapy.readthedocs.io/en/latest/usage.html
#
# Example of usage:
#
# packet=$(fmt_pkt "
#     Ether(dst='ff:ff:ff:ff:ff:ff', src='50:64:00:00:00:01') /
#     IPv6(src='abed::1', dst='ff02::1:ff00:2') /
#     ICMPv6ND_NS(tgt='abed::2')
# ")
#
# ovs-appctl netdev-dummy/receive $vif $packet
#
fmt_pkt() {
    ctlfile=$ovs_base/scapy.ctl
    if [ ! -S $ctlfile ]; then
        start_scapy_server
    fi
    while [ ! -S $ctlfile ]; do sleep 0.1; done
    ovs-appctl -t $ctlfile payload "$1"
}

start_scapy_server() {
    pidfile=$ovs_base/scapy.pid
    ctlfile=$ovs_base/scapy.ctl
    logfile=$ovs_base/scapy.log
    lockfile=$ovs_base/scapy.lock

    flock -n $lockfile "$top_srcdir"/tests/scapy-server.py \
        --pidfile=$pidfile --unixctl=$ctlfile --log-file=$logfile --detach \
    && on_exit "test -e \"$pidfile\" && ovs-appctl -t $ctlfile exit"
}

sleep_northd() {
  echo Northd going to sleep
  { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:1320: kill -STOP \$(cat northd/ovn-northd.pid)"
at_fn_check_prepare_notrace 'a $(...) command substitution' "ovn-macros.at:1320"
( $at_check_trace; kill -STOP $(cat northd/ovn-northd.pid)
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:1320"
$at_failed && at_fn_log_failure  \
"trace"
$at_traceon; }

  on_exit "test -e northd/ovn-northd.pid && kill -CONT $(cat northd/ovn-northd.pid)"
}

wake_up_northd() {
  echo Northd waking up
  { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:1326: kill -CONT \$(cat northd/ovn-northd.pid)"
at_fn_check_prepare_notrace 'a $(...) command substitution' "ovn-macros.at:1326"
( $at_check_trace; kill -CONT $(cat northd/ovn-northd.pid)
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:1326"
$at_failed && at_fn_log_failure  \
"trace"
$at_traceon; }

}

sleep_sb() {
  echo SB going to sleep
  { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:1331: kill -STOP \$(cat ovn-sb/ovsdb-server.pid)"
at_fn_check_prepare_notrace 'a $(...) command substitution' "ovn-macros.at:1331"
( $at_check_trace; kill -STOP $(cat ovn-sb/ovsdb-server.pid)
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:1331"
$at_failed && at_fn_log_failure  \
"trace"
$at_traceon; }

  on_exit "test -e ovn-sb/ovsdb-server.pid && kill -CONT $(cat ovn-sb/ovsdb-server.pid)"
}
wake_up_sb() {
  echo SB waking up
  { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:1336: kill -CONT \$(cat ovn-sb/ovsdb-server.pid)"
at_fn_check_prepare_notrace 'a $(...) command substitution' "ovn-macros.at:1336"
( $at_check_trace; kill -CONT $(cat ovn-sb/ovsdb-server.pid)
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:1336"
$at_failed && at_fn_log_failure  \
"trace"
$at_traceon; }

}
sleep_controller() {
  hv=$1
  echo Controller $hv going to sleep
  as $hv
  check ovn-appctl debug/pause
  check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    test x$(ovn-appctl -t ovn-controller debug/status) = "xpaused"
}
ovs_wait_failed () {
    :

}
ovs_wait "ovn-macros.at:1343" "until test x\$(ovn-appctl -t ovn-controller debug/status) = \"xpaused\""

}
wake_up_controller() {
  hv=$1
  as $hv
  echo Controller $hv waking up
  ovn-appctl debug/resume
  check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    test x$(ovn-appctl -t ovn-controller debug/status) = "xrunning"
}
ovs_wait_failed () {
    :

}
ovs_wait "ovn-macros.at:1350" "until test x\$(ovn-appctl -t ovn-controller debug/status) = \"xrunning\""

}
sleep_ovs() {
  hv=$1
  echo ovs $hv going to sleep
  { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:1355: kill -STOP \$(cat \$hv/ovs-vswitchd.pid)"
at_fn_check_prepare_notrace 'a $(...) command substitution' "ovn-macros.at:1355"
( $at_check_trace; kill -STOP $(cat $hv/ovs-vswitchd.pid)
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:1355"
$at_failed && at_fn_log_failure  \
"trace"
$at_traceon; }

  on_exit "test -e $hv/ovs-vswitchd.pid && kill -CONT $(cat $hv/ovs-vswitchd.pid)"
}

wake_up_ovs() {
  hv=$1
  echo ovs $hv going to wake-up
  { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:1362: kill -CONT \$(cat \$hv/ovs-vswitchd.pid)"
at_fn_check_prepare_notrace 'a $(...) command substitution' "ovn-macros.at:1362"
( $at_check_trace; kill -CONT $(cat $hv/ovs-vswitchd.pid)
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:1362"
$at_failed && at_fn_log_failure  \
"trace"
$at_traceon; }

}

sleep_ovsdb() {
  echo OVSDB $1 going to sleep
  { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:1367: kill -STOP \$(cat \$1/ovsdb-server.pid)"
at_fn_check_prepare_notrace 'a $(...) command substitution' "ovn-macros.at:1367"
( $at_check_trace; kill -STOP $(cat $1/ovsdb-server.pid)
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:1367"
$at_failed && at_fn_log_failure  \
"trace"
$at_traceon; }

  on_exit "test -e $1/ovsdb-server.pid && kill -CONT $(cat $1/ovsdb-server.pid)"
}
wake_up_ovsdb() {
  echo OVSDB $1 waking up
  { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:1372: kill -CONT \$(cat \$1/ovsdb-server.pid)"
at_fn_check_prepare_notrace 'a $(...) command substitution' "ovn-macros.at:1372"
( $at_check_trace; kill -CONT $(cat $1/ovsdb-server.pid)
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:1372"
$at_failed && at_fn_log_failure  \
"trace"
$at_traceon; }

}

stop_ovsdb_controller_updates() {
  TCP_PORT=$1
  echo Stopping updates from ovn-controller to ovsdb using port $TCP_PORT
  on_exit 'nft list tables | grep ovn-test && nft delete table ip ovn-test'
  # Report the test as skipped if proper nft related packages are not installed.
  printf "%s\n" "ovn-macros.at:1380" >"$at_check_line_file"
(! which nft) \
  && at_fn_check_skip 77 "$at_srcdir/ovn-macros.at:1380"
  { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:1381: nft add table ip ovn-test"
at_fn_check_prepare_trace "ovn-macros.at:1381"
( $at_check_trace; nft add table ip ovn-test
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:1381"
$at_failed && at_fn_log_failure  \
"trace"
$at_traceon; }

  { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:1382: nft 'add chain ip ovn-test INPUT { type filter hook input priority 0; policy accept; }'"
at_fn_check_prepare_trace "ovn-macros.at:1382"
( $at_check_trace; nft 'add chain ip ovn-test INPUT { type filter hook input priority 0; policy accept; }'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:1382"
$at_failed && at_fn_log_failure  \
"trace"
$at_traceon; }

  { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:1383: nft add rule ip ovn-test INPUT tcp dport \$TCP_PORT counter drop"
at_fn_check_prepare_dynamic "nft add rule ip ovn-test INPUT tcp dport $TCP_PORT counter drop" "ovn-macros.at:1383"
( $at_check_trace; nft add rule ip ovn-test INPUT tcp dport $TCP_PORT counter drop
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:1383"
$at_failed && at_fn_log_failure  \
"trace"
$at_traceon; }

}

restart_ovsdb_controller_updates() {
  TCP_PORT=$1
  echo Restarting updates from ovn-controller to ovsdb
  { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:1389: nft list ruleset | grep \$TCP_PORT"
at_fn_check_prepare_notrace 'a shell pipeline' "ovn-macros.at:1389"
( $at_check_trace; nft list ruleset | grep $TCP_PORT
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:1389"
$at_failed && at_fn_log_failure  \
"trace"
$at_traceon; }

  { set +x
printf "%s\n" "$at_srcdir/ovn-macros.at:1390: nft delete table ip ovn-test"
at_fn_check_prepare_trace "ovn-macros.at:1390"
( $at_check_trace; nft delete table ip ovn-test
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/ovn-macros.at:1390"
$at_failed && at_fn_log_failure  \
"trace"
$at_traceon; }

}

trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}

ovn_strip_lflows() {
     sed 's/table=[0-9]\{1,2\}\s\?/table=??/g' | sort
}

ovn_strip_collector_set() {
    sed 's/collector_set=[0-9]*,\?/collector_set=??,/g'
}




m_as() {
    c=$1
    shift
    podman exec $c "$@"
}

m_central_as () {
    podman exec ovn-central-az1 "$@"
}

multinode_nbctl () {
    m_as ovn-central-az1 ovn-nbctl "$@"
}

multinode_sbctl () {
    m_as ovn-central-az1 ovn-sbctl "$@"
}

check_fake_multinode_setup_by_nodes() {
    check m_as ovn-central-az1 ovn-nbctl --wait=sb sync
    for c; do
        { set +x
printf "%s\n" "$at_srcdir/multinode-macros.at:96: m_as \$c ovn-appctl -t ovn-controller version"
at_fn_check_prepare_dynamic "m_as $c ovn-appctl -t ovn-controller version" "multinode-macros.at:96"
( $at_check_trace; m_as $c ovn-appctl -t ovn-controller version
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/multinode-macros.at:96"
$at_failed && at_fn_log_failure
$at_traceon; }

        on_exit "m_as $c ovs-vsctl list Interface > interfaces-${c}.txt"
        on_exit "m_as $c ovs-vsctl show > ovs-${chassis}.txt"
        on_exit "m_as $c ovs-ofctl dump-flows br-int > flow-${c}.txt"
        on_exit "m_as $c ovs-vsctl get open . external_ids > extids-${c}.txt"
    done

    # Check $ENABLE_SSL variable, and use SSL if unset (default) or not set to "no".
    if [ "$ENABLE_SSL" != "no" ]; then
        REMOTE_PROT=ssl
        SSL_CERTS_PATH=/opt/ovn
        CONTROLLER_SSL_ARGS="--ovn-controller-ssl-key=${SSL_CERTS_PATH}/ovn-privkey.pem \
                             --ovn-controller-ssl-cert=${SSL_CERTS_PATH}/ovn-cert.pem \
                             --ovn-controller-ssl-ca-cert=${SSL_CERTS_PATH}/pki/switchca/cacert.pem"
        NORTHD_SSL_ARGS="--ovn-nb-db-ssl-key=${SSL_CERTS_PATH}/ovn-privkey.pem \
              --ovn-nb-db-ssl-cert=${SSL_CERTS_PATH}/ovn-cert.pem \
              --ovn-nb-db-ssl-ca-cert=${SSL_CERTS_PATH}/pki/switchca/cacert.pem \
              --ovn-sb-db-ssl-key=${SSL_CERTS_PATH}/ovn-privkey.pem \
              --ovn-sb-db-ssl-cert=${SSL_CERTS_PATH}/ovn-cert.pem \
              --ovn-sb-db-ssl-ca-cert=${SSL_CERTS_PATH}/pki/switchca/cacert.pem \
              --ovn-northd-ssl-key=${SSL_CERTS_PATH}/ovn-privkey.pem \
              --ovn-northd-ssl-cert=${SSL_CERTS_PATH}/ovn-cert.pem \
              --ovn-northd-ssl-ca-cert=${SSL_CERTS_PATH}/pki/switchca/cacert.pem"
    else
        REMOTE_PROT=tcp
        CONTROLLER_SSL_ARGS=""
        NORTHD_SSL_ARGS=""
    fi
        export CONTROLLER_SSL_ARGS
        export NORTHD_SSL_ARGS
        export REMOTE_PROT
}

check_fake_multinode_setup() {
    check_fake_multinode_setup_by_nodes                         \
        ovn-chassis-1 ovn-chassis-2 ovn-chassis-3 ovn-chassis-4 \
        ovn-gw-1 ovn-gw-2 ovn-gw-3 ovn-gw-4
}

cleanup_multinode_resources_by_nodes() {
    m_as ovn-central-az1 rm -f /etc/ovn/ovnnb_db.db
    m_as ovn-central-az1 /usr/share/ovn/scripts/ovn-ctl restart_northd
    check m_as ovn-central-az1 ovn-nbctl --wait=sb sync
    for c; do
        m_as $c ovs-vsctl del-br br-int
        m_as $c ip --all netns delete
    done
}

cleanup_multinode_resources() {
    cleanup_multinode_resources_by_nodes                        \
        ovn-chassis-1 ovn-chassis-2 ovn-chassis-3 ovn-chassis-4 \
        ovn-gw-1 ovn-gw-2 ovn-gw-3 ovn-gw-4
}

# multinode_cleanup_northd NODE
#
# Removes previously set nothd on specified node
multinode_cleanup_northd() {
    c=$1
    # Cleanup existing one
    m_as $c /usr/share/ovn/scripts/ovn-ctl stop_northd
    m_as $c sh -c "rm -f /etc/ovn/*.db"
}

# multinode_setup_northd NODE
#
# Sets up northd on specified node.
multinode_setup_northd() {
    c=$1

    multinode_cleanup_northd $c

    echo "Using ${NORTHD_SSL_ARGS} for northd".
    m_as $c /usr/share/ovn/scripts/ovn-ctl start_northd ${NORTHD_SSL_ARGS}
    m_as $c ovn-nbctl set-connection p${REMOTE_PROT}:6641
    m_as $c ovn-sbctl set-connection p${REMOTE_PROT}:6642
}

# multinode_setup_controller NODE ENCAP_IP REMOTE_IP [ENCAP_TYPE]
#
# Sets up controller on specified node.
multinode_setup_controller() {
    c=$1
    encap_ip=$3
    remote_ip=$4
    encap_type=${5:-"geneve"}

    # Cleanup existing one
    m_as $c /usr/share/openvswitch/scripts/ovs-ctl stop
    m_as $c /usr/share/ovn/scripts/ovn-ctl stop_controller
    m_as $c sh -c "rm -f /etc/openvswitch/*.db"

    m_as $c /usr/share/openvswitch/scripts/ovs-ctl start --system-id=$c
    echo "Using ${CONTROLLER_SSL_ARGS} for ovn-controller".
    m_as $c /usr/share/ovn/scripts/ovn-ctl start_controller ${CONTROLLER_SSL_ARGS}

    m_as $c ovs-vsctl set open . external_ids:ovn-encap-ip=$encap_ip
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=$encap_type
    m_as $c ovs-vsctl set open . external-ids:ovn-remote=${REMOTE_PROT}:$remote_ip:6642
    m_as $c ovs-vsctl set open . external-ids:ovn-openflow-probe-interval=60
    m_as $c ovs-vsctl set open . external-ids:ovn-remote-probe-interval=180000
    m_as $c ovs-vsctl set open . external-ids:ovn-bridge-datapath-type=system

    # Add back br-ex which was removed when removing ovs conf.db
    m_as $c ovs-vsctl --if-exists del-br br-ex
    m_as $c ovs-vsctl add-br br-ex
    m_as $c ip link set eth2 down
    m_as $c ovs-vsctl add-port br-ex eth2
    m_as $c ip link set eth2 up
}

# m_count_rows TABLE [CONDITION...]
#
# Prints the number of rows in TABLE (that satisfy CONDITION).
# Uses the southbound db by default; set DB=nb for the northbound database.
m_count_rows() {
    local db=$(parse_db $1) table=$(parse_table $1); shift
    m_central_as ovn-${db}ctl --format=table --no-headings find $table "$@" | wc -l
}

# m_check_row_count [DATABASE:]TABLE COUNT [CONDITION...]
#
# Checks that TABLE contains COUNT rows (that satisfy CONDITION).
# The default DATABASE is "sb".
m_check_row_count() {
    local db=$(parse_db $1) table=$(parse_table $1); shift
    local count=$1; shift
    local found=$(m_count_rows $db:$table "$@")
    echo
    echo "Checking for $count rows in $db $table${1+ with $*}... found $found"
    if test "$count" != "$found"; then
        m_central_as ovn-${db}ctl list $table
        printf "%s\n" "multinode-macros.at:229" >"$at_check_line_file"
at_fn_check_skip 99 "$at_srcdir/multinode-macros.at:229"
    fi
}

# m_wait_row_count [DATABASE:]TABLE COUNT [CONDITION...]
#
# Waits until TABLE contains COUNT rows (that satisfy CONDITION).
# The default DATABASE is "sb".
m_wait_row_count() {
    local db=$(parse_db $1) table=$(parse_table $1); shift
    local count=$1; shift
    local a=$1 b=$2 c=$3 d=$4 e=$5
    echo "Waiting until $count rows in $db $table${1+ with $*}..."
    check_ovs_wait_until_args "2" "
      echo "$db table $table has the following rows. $(m_count_rows $db:$table $a $b $c $d $e) rows match instead of expected $count:"
      m_central_as ovn-${db}ctl list $table"
   ovs_wait_cond () {
    test $count = $(m_count_rows $db:$table $a $b $c $d $e)
}
ovs_wait_failed () {
    :

      echo "$db table $table has the following rows. $(m_count_rows $db:$table $a $b $c $d $e) rows match instead of expected $count:"
      m_central_as ovn-${db}ctl list $table
}
ovs_wait "multinode-macros.at:242" "until test \$count = \$(m_count_rows \$db:\$table \$a \$b \$c \$d \$e)"

}

# m_wait_column EXPECTED [DATABASE:]TABLE [COLUMN [CONDITION...]]
#
# Wait until all of the values of COLUMN in the rows of TABLE (that
# satisfy CONDITION) equal EXPECTED (ignoring order).
#
# The default DATABASE is "sb".
#
# COLUMN defaults to _uuid if unspecified.
m_wait_column() {
    local expected=$(for d in $1; do echo $d; done | sort)
    local db=$(parse_db $2) table=$(parse_table $2) column=${3-_uuid}; shift; shift; shift
    local a=$1 b=$2 c=$3 d=$4 e=$5

    echo
    echo "Waiting until $column in $db $table${1+ with $*} is $expected..."
    check_ovs_wait_until_args "2" "
      echo "$column in $db table $table has value $found, from the following rows:"
      m_central_as ovn-${db}ctl list $table"
   ovs_wait_cond () {

      found=$(m_central_as ovn-${db}ctl --bare --columns $column find $table $a $b $c $d $e)
      found=$(for d in $found; do echo $d; done | sort)
      test "$expected" = "$found"

}
ovs_wait_failed () {
    :

      echo "$column in $db table $table has value $found, from the following rows:"
      m_central_as ovn-${db}ctl list $table
}
ovs_wait "multinode-macros.at:262" "until
      found=\$(m_central_as ovn-\${db}ctl --bare --columns \$column find \$table \$a \$b \$c \$d \$e)
      found=\$(for d in \$found; do echo \$d; done | sort)
      test \"\$expected\" = \"\$found\"
    "

}

# m_fetch_column [DATABASE:]TABLE COLUMN [CONDITION...]
#
# Fetches and prints all the values of COLUMN in the rows of TABLE
# (that satisfy CONDITION), sorting the results lexicographically.
# The default DATABASE is "sb".
m_fetch_column() {
    local db=$(parse_db $1) table=$(parse_table $1) column=${2-_uuid}; shift; shift
    # Using "echo" removes spaces and newlines.
    echo $(m_central_as ovn-${db}ctl --bare --columns $column find $table "$@" | sort)
}

# m_check_column EXPECTED [DATABASE:]TABLE COLUMN [CONDITION...]
#
# Fetches all of the values of COLUMN in the rows of TABLE (that
# satisfy CONDITION), and compares them against EXPECTED (ignoring
# order).
#
# The default DATABASE is "sb".
m_check_column() {
    local expected=$1 db=$(parse_db $2) table=$(parse_table $2) column=${3-_uuid}; shift; shift; shift
    local found=$(m_central_as ovn-${db}ctl --bare --columns $column find $table "$@")

    # Sort the expected and found values.
    local found=$(for d in $found; do echo $d; done | sort)
    local expected=$(for d in $expected; do echo $d; done | sort)

    echo
    echo "Checking values in $db $table${1+ with $*} against $expected... found $found"
    if test "$found" != "$expected"; then
        m_central_as ovn-${db}ctl list $table
        printf "%s\n" "multinode-macros.at:301" >"$at_check_line_file"
at_fn_check_skip 99 "$at_srcdir/multinode-macros.at:301"
    fi
}

# m_add_internal_port NODE NETNS OVS_BRIDGE PORT IP [GW]
#
# Adds an OVS internal PORT to OVS_BRIDGE on NODE and moves the resulting
# interface in the NETNS namespace.  It also configures it with the provided
# IP and (optionally) default gateway GW.
m_add_internal_port() {
    local node=$1 ns=$2 br=$3 port=$4 ip=$5 gw=$6

    if ! m_as $node ip netns list | grep $ns; then
        check m_as $node ip netns add $ns
        on_exit "m_as $node ip netns delete $ns"
    fi
    check m_as $node ovs-vsctl add-port $br $port -- set interface $port type=internal
    on_exit "m_as $node ovs-vsctl del-port $port"
    check m_as $node ip link set $port netns $ns
    check m_as $node ip netns exec $ns ip link set $port up
    check m_as $node ip netns exec $ns ip addr add $ip dev $port

    if test -n "$gw"; then
        check m_as $node ip netns exec $ns ip route add default via $gw dev $port
    fi
}

# m_wait_for_ports_up [PORT...]
#
# With arguments, waits for specified Logical_Switch_Ports to come up.
# Without arguments, waits for all "plain" and router
# Logical_Switch_Ports to come up.
m_wait_for_ports_up() {
    if test $# = 0; then
        m_wait_row_count nb:Logical_Switch_Port 0 up!=true type='""'
        m_wait_row_count nb:Logical_Switch_Port 0 up!=true type=router
    else
        for port; do
            m_wait_row_count nb:Logical_Switch_Port 1 up=true name=$port
        done
    fi
}

# m_kill fake_node name
#
# Helper to properly kill command in a node.
m_kill() {
    containers=$1
    command=$2
    for c in $containers; do
      podman exec $c ps -ef | grep -v grep | grep -q $command && \
        echo "Killing $command on $c" && podman exec $c killall $command
    done
}

m_is_fedora() {
    m_central_as grep -qi fedora /etc/os-release
}


   {
  printf "%s\n" "## ---------------- ##
## Tested programs. ##
## ---------------- ##"
  echo
} >&5

# Report what programs are being tested.
for at_program in : `eval echo $at_tested`
do
  case $at_program in #(
  :) :
    continue ;; #(
  [\\/]* | ?:[\\/]*) :
    at_program_=$at_program ;; #(
  *) :
    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  case $as_dir in #(((
    '') as_dir=./ ;;
    */) ;;
    *) as_dir=$as_dir/ ;;
  esac
    test -f "$as_dir$at_program" && break
  done
IFS=$as_save_IFS

    at_program_=$as_dir$at_program ;;
esac

  if test -f "$at_program_"; then
    {
      printf "%s\n" "$at_srcdir/multinode-testsuite.at:1: $at_program_ --version"
      "$at_program_" --version </dev/null
      echo
    } >&5 2>&1
  else
    as_fn_error $? "cannot find $at_program" "$LINENO" 5
  fi
done

{
  printf "%s\n" "## ------------------ ##
## Running the tests. ##
## ------------------ ##"
} >&5

at_start_date=`date`
at_start_time=`date +%s 2>/dev/null`
printf "%s\n" "$as_me: starting at: $at_start_date" >&5

# Create the master directory if it doesn't already exist.
as_dir="$at_suite_dir"; as_fn_mkdir_p ||
  as_fn_error $? "cannot create \`$at_suite_dir'" "$LINENO" 5

# Can we diff with `/dev/null'?  DU 5.0 refuses.
if diff /dev/null /dev/null >/dev/null 2>&1; then
  at_devnull=/dev/null
else
  at_devnull=$at_suite_dir/devnull
  >"$at_devnull"
fi

# Use `diff -u' when possible.
if at_diff=`diff -u "$at_devnull" "$at_devnull" 2>&1` && test -z "$at_diff"
then
  at_diff='diff -u'
else
  at_diff=diff
fi

# Get the last needed group.
for at_group in : $at_groups; do :; done

# Extract the start and end lines of each test group at the tail
# of this file
awk '
BEGIN { FS="" }
/^#AT_START_/ {
  start = NR
}
/^#AT_STOP_/ {
  test = substr ($ 0, 10)
  print "at_sed" test "=\"1," start "d;" (NR-1) "q\""
  if (test == "'"$at_group"'") exit
}' "$at_myself" > "$at_suite_dir/at-source-lines" &&
. "$at_suite_dir/at-source-lines" ||
  as_fn_error $? "cannot create test line number cache" "$LINENO" 5
rm -f "$at_suite_dir/at-source-lines"

# Set number of jobs for `-j'; avoid more jobs than test groups.
set X $at_groups; shift; at_max_jobs=$#
if test $at_max_jobs -eq 0; then
  at_jobs=1
fi
if test $at_jobs -ne 1 &&
   { test $at_jobs -eq 0 || test $at_jobs -gt $at_max_jobs; }; then
  at_jobs=$at_max_jobs
fi

# If parallel mode, don't output banners, don't split summary lines.
if test $at_jobs -ne 1; then
  at_print_banners=false
  at_quiet=:
fi

# Set up helper dirs.
rm -rf "$at_helper_dir" &&
mkdir "$at_helper_dir" &&
cd "$at_helper_dir" &&
{ test -z "$at_groups" || mkdir $at_groups; } ||
as_fn_error $? "testsuite directory setup failed" "$LINENO" 5

# Functions for running a test group.  We leave the actual
# test group execution outside of a shell function in order
# to avoid hitting zsh 4.x exit status bugs.

# at_fn_group_prepare
# -------------------
# Prepare for running a test group.
at_fn_group_prepare ()
{
  # The directory for additional per-group helper files.
  at_job_dir=$at_helper_dir/$at_group
  # The file containing the location of the last AT_CHECK.
  at_check_line_file=$at_job_dir/check-line
  # The file containing the exit status of the last command.
  at_status_file=$at_job_dir/status
  # The files containing the output of the tested commands.
  at_stdout=$at_job_dir/stdout
  at_stder1=$at_job_dir/stder1
  at_stderr=$at_job_dir/stderr
  # The file containing the code for a test group.
  at_test_source=$at_job_dir/test-source
  # The file containing dates.
  at_times_file=$at_job_dir/times

  # Be sure to come back to the top test directory.
  cd "$at_suite_dir"

  # Clearly separate the test groups when verbose.
  $at_first || $at_verbose echo

  at_group_normalized=$at_group

  eval 'while :; do
    case $at_group_normalized in #(
    '"$at_format"'*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done'


  # Create a fresh directory for the next test group, and enter.
  # If one already exists, the user may have invoked ./run from
  # within that directory; we remove the contents, but not the
  # directory itself, so that we aren't pulling the rug out from
  # under the shell's notion of the current directory.
  at_group_dir=$at_suite_dir/$at_group_normalized
  at_group_log=$at_group_dir/$as_me.log
  if test -d "$at_group_dir"
then
  find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx {} \;
  rm -fr "$at_group_dir"/* "$at_group_dir"/.[!.] "$at_group_dir"/.??*
fi ||
    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: test directory for $at_group_normalized could not be cleaned" >&5
printf "%s\n" "$as_me: WARNING: test directory for $at_group_normalized could not be cleaned" >&2;}
  # Be tolerant if the above `rm' was not able to remove the directory.
  as_dir="$at_group_dir"; as_fn_mkdir_p

  echo 0 > "$at_status_file"

  # In verbose mode, append to the log file *and* show on
  # the standard output; in quiet mode only write to the log.
  if test -z "$at_verbose"; then
    at_tee_pipe='tee -a "$at_group_log"'
  else
    at_tee_pipe='cat >> "$at_group_log"'
  fi
}

# at_fn_group_banner ORDINAL LINE DESC PAD [BANNER]
# -------------------------------------------------
# Declare the test group ORDINAL, located at LINE with group description DESC,
# and residing under BANNER. Use PAD to align the status column.
at_fn_group_banner ()
{
  at_setup_line="$2"
  test -n "$5" && at_fn_banner $5
  at_desc="$3"
  case $1 in
    [0-9])      at_desc_line="  $1: ";;
    [0-9][0-9]) at_desc_line=" $1: " ;;
    *)          at_desc_line="$1: "  ;;
  esac
  as_fn_append at_desc_line "$3$4"
  $at_quiet printf %s "$at_desc_line"
  echo "#                             -*- compilation -*-" >> "$at_group_log"
}

# at_fn_group_postprocess
# -----------------------
# Perform cleanup after running a test group.
at_fn_group_postprocess ()
{
  # Be sure to come back to the suite directory, in particular
  # since below we might `rm' the group directory we are in currently.
  cd "$at_suite_dir"

  if test ! -f "$at_check_line_file"; then
    sed "s/^ */$as_me: WARNING: /" <<_ATEOF
      A failure happened in a test group before any test could be
      run. This means that test suite is improperly designed.  Please
      report this failure to <bugs@openvswitch.org>.
_ATEOF
    printf "%s\n" "$at_setup_line" >"$at_check_line_file"
    at_status=99
  fi
  $at_verbose printf %s "$at_group. $at_setup_line: "
  printf %s "$at_group. $at_setup_line: " >> "$at_group_log"
  case $at_xfail:$at_status in
    yes:0)
	at_msg="UNEXPECTED PASS"
	at_res=xpass
	at_errexit=$at_errexit_p
	at_color=$at_red
	;;
    no:0)
	at_msg="ok"
	at_res=pass
	at_errexit=false
	at_color=$at_grn
	;;
    *:77)
	at_msg='skipped ('`cat "$at_check_line_file"`')'
	at_res=skip
	at_errexit=false
	at_color=$at_blu
	;;
    no:* | *:99)
	at_msg='FAILED ('`cat "$at_check_line_file"`')'
	at_res=fail
	at_errexit=$at_errexit_p
	at_color=$at_red
	;;
    yes:*)
	at_msg='expected failure ('`cat "$at_check_line_file"`')'
	at_res=xfail
	at_errexit=false
	at_color=$at_lgn
	;;
  esac
  echo "$at_res" > "$at_job_dir/$at_res"
  # In parallel mode, output the summary line only afterwards.
  if test $at_jobs -ne 1 && test -n "$at_verbose"; then
    printf "%s\n" "$at_desc_line $at_color$at_msg$at_std"
  else
    # Make sure there is a separator even with long titles.
    printf "%s\n" " $at_color$at_msg$at_std"
  fi
  at_log_msg="$at_group. $at_desc ($at_setup_line): $at_msg"
  case $at_status in
    0|77)
      # $at_times_file is only available if the group succeeded.
      # We're not including the group log, so the success message
      # is written in the global log separately.  But we also
      # write to the group log in case they're using -d.
      if test -f "$at_times_file"; then
	at_log_msg="$at_log_msg     ("`sed 1d "$at_times_file"`')'
	rm -f "$at_times_file"
      fi
      printf "%s\n" "$at_log_msg" >> "$at_group_log"
      printf "%s\n" "$at_log_msg" >&5

      # Cleanup the group directory, unless the user wants the files
      # or the success was unexpected.
      if $at_debug_p || test $at_res = xpass; then
	at_fn_create_debugging_script
	if test $at_res = xpass && $at_errexit; then
	  echo stop > "$at_stop_file"
	fi
      else
	if test -d "$at_group_dir"; then
	  find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
	  rm -fr "$at_group_dir"
	fi
	rm -f "$at_test_source"
      fi
      ;;
    *)
      # Upon failure, include the log into the testsuite's global
      # log.  The failure message is written in the group log.  It
      # is later included in the global log.
      printf "%s\n" "$at_log_msg" >> "$at_group_log"

      # Upon failure, keep the group directory for autopsy, and create
      # the debugging script.  With -e, do not start any further tests.
      at_fn_create_debugging_script
      if $at_errexit; then
	echo stop > "$at_stop_file"
      fi
      ;;
  esac
}


## ------------ ##
## Driver loop. ##
## ------------ ##


if (set -m && set +m && set +b) >/dev/null 2>&1; then
  set +b
  at_job_control_on='set -m' at_job_control_off='set +m' at_job_group=-
else
  at_job_control_on=: at_job_control_off=: at_job_group=
fi

for at_signal in 1 2 15; do
  trap 'set +x; set +e
	$at_job_control_off
	at_signal='"$at_signal"'
	echo stop > "$at_stop_file"
	trap "" $at_signal
	at_pgids=
	for at_pgid in `jobs -p 2>/dev/null`; do
	  at_pgids="$at_pgids $at_job_group$at_pgid"
	done
	test -z "$at_pgids" || kill -$at_signal $at_pgids 2>/dev/null
	wait
	if test "$at_jobs" -eq 1 || test -z "$at_verbose"; then
	  echo >&2
	fi
	at_signame=`kill -l $at_signal 2>&1 || echo $at_signal`
	set x $at_signame
	test 0 -gt 2 && at_signame=$at_signal
	{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: caught signal $at_signame, bailing out" >&5
printf "%s\n" "$as_me: WARNING: caught signal $at_signame, bailing out" >&2;}
	as_fn_arith 128 + $at_signal && exit_status=$as_val
	as_fn_exit $exit_status' $at_signal
done

rm -f "$at_stop_file"
at_first=:

if test $at_jobs -ne 1 &&
     rm -f "$at_job_fifo" &&
     test -n "$at_job_group" &&
     ( mkfifo "$at_job_fifo" && trap 'exit 1' PIPE STOP TSTP ) 2>/dev/null
then
  # FIFO job dispatcher.

  trap 'at_pids=
	for at_pid in `jobs -p`; do
	  at_pids="$at_pids $at_job_group$at_pid"
	done
	if test -n "$at_pids"; then
	  at_sig=TSTP
	  test ${TMOUT+y} && at_sig=STOP
	  kill -$at_sig $at_pids 2>/dev/null
	fi
	kill -STOP $$
	test -z "$at_pids" || kill -CONT $at_pids 2>/dev/null' TSTP

  echo
  # Turn jobs into a list of numbers, starting from 1.
  at_joblist=`printf "%s\n" "$at_groups" | sed -n 1,${at_jobs}p`

  set X $at_joblist
  shift
  for at_group in $at_groups; do
    $at_job_control_on 2>/dev/null
    (
      # Start one test group.
      $at_job_control_off
      if $at_first; then
	exec 7>"$at_job_fifo"
      else
	exec 6<&-
      fi
      trap 'set +x; set +e
	    trap "" PIPE
	    echo stop > "$at_stop_file"
	    echo >&7
	    as_fn_exit 141' PIPE
      at_fn_group_prepare
      if cd "$at_group_dir" &&
	 at_fn_test $at_group &&
	 . "$at_test_source"
      then :; else
	{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: unable to parse test group: $at_group" >&5
printf "%s\n" "$as_me: WARNING: unable to parse test group: $at_group" >&2;}
	at_failed=:
      fi
      at_fn_group_postprocess
      echo >&7
    ) &
    $at_job_control_off
    if $at_first; then
      at_first=false
      exec 6<"$at_job_fifo" 7>"$at_job_fifo"
    fi
    shift # Consume one token.
    if test $# -gt 0; then :; else
      read at_token <&6 || break
      set x $*
    fi
    test -f "$at_stop_file" && break
  done
  exec 7>&-
  # Read back the remaining ($at_jobs - 1) tokens.
  set X $at_joblist
  shift
  if test $# -gt 0; then
    shift
    for at_job
    do
      read at_token
    done <&6
  fi
  exec 6<&-
  wait
else
  # Run serially, avoid forks and other potential surprises.
  for at_group in $at_groups; do
    at_fn_group_prepare
    if cd "$at_group_dir" &&
       at_fn_test $at_group &&
       . "$at_test_source"; then :; else
      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: unable to parse test group: $at_group" >&5
printf "%s\n" "$as_me: WARNING: unable to parse test group: $at_group" >&2;}
      at_failed=:
    fi
    at_fn_group_postprocess
    test -f "$at_stop_file" && break
    at_first=false
  done
fi

# Wrap up the test suite with summary statistics.
cd "$at_helper_dir"

# Use ?..???? when the list must remain sorted, the faster * otherwise.
at_pass_list=`for f in */pass; do echo $f; done | sed '/\*/d; s,/pass,,'`
at_skip_list=`for f in */skip; do echo $f; done | sed '/\*/d; s,/skip,,'`
at_xfail_list=`for f in */xfail; do echo $f; done | sed '/\*/d; s,/xfail,,'`
at_xpass_list=`for f in ?/xpass ??/xpass ???/xpass ????/xpass; do
		 echo $f; done | sed '/?/d; s,/xpass,,'`
at_fail_list=`for f in ?/fail ??/fail ???/fail ????/fail; do
		echo $f; done | sed '/?/d; s,/fail,,'`

set X $at_pass_list $at_xpass_list $at_xfail_list $at_fail_list $at_skip_list
shift; at_group_count=$#
set X $at_xpass_list; shift; at_xpass_count=$#; at_xpass_list=$*
set X $at_xfail_list; shift; at_xfail_count=$#
set X $at_fail_list; shift; at_fail_count=$#; at_fail_list=$*
set X $at_skip_list; shift; at_skip_count=$#

as_fn_arith $at_group_count - $at_skip_count && at_run_count=$as_val
as_fn_arith $at_xpass_count + $at_fail_count && at_unexpected_count=$as_val
as_fn_arith $at_xfail_count + $at_fail_count && at_total_fail_count=$as_val

# Back to the top directory.
cd "$at_dir"
rm -rf "$at_helper_dir"

# Compute the duration of the suite.
at_stop_date=`date`
at_stop_time=`date +%s 2>/dev/null`
printf "%s\n" "$as_me: ending at: $at_stop_date" >&5
case $at_start_time,$at_stop_time in
  [0-9]*,[0-9]*)
    as_fn_arith $at_stop_time - $at_start_time && at_duration_s=$as_val
    as_fn_arith $at_duration_s / 60 && at_duration_m=$as_val
    as_fn_arith $at_duration_m / 60 && at_duration_h=$as_val
    as_fn_arith $at_duration_s % 60 && at_duration_s=$as_val
    as_fn_arith $at_duration_m % 60 && at_duration_m=$as_val
    at_duration="${at_duration_h}h ${at_duration_m}m ${at_duration_s}s"
    printf "%s\n" "$as_me: test suite duration: $at_duration" >&5
    ;;
esac

echo
printf "%s\n" "## ------------- ##
## Test results. ##
## ------------- ##"
echo
{
  echo
  printf "%s\n" "## ------------- ##
## Test results. ##
## ------------- ##"
  echo
} >&5

if test $at_run_count = 1; then
  at_result="1 test"
  at_were=was
else
  at_result="$at_run_count tests"
  at_were=were
fi
if $at_errexit_p && test $at_unexpected_count != 0; then
  if test $at_xpass_count = 1; then
    at_result="$at_result $at_were run, one passed"
  else
    at_result="$at_result $at_were run, one failed"
  fi
  at_result="$at_result unexpectedly and inhibited subsequent tests."
  at_color=$at_red
else
  # Don't you just love exponential explosion of the number of cases?
  at_color=$at_red
  case $at_xpass_count:$at_fail_count:$at_xfail_count in
    # So far, so good.
    0:0:0) at_result="$at_result $at_were successful." at_color=$at_grn ;;
    0:0:*) at_result="$at_result behaved as expected." at_color=$at_lgn ;;

    # Some unexpected failures
    0:*:0) at_result="$at_result $at_were run,
$at_fail_count failed unexpectedly." ;;

    # Some failures, both expected and unexpected
    0:*:1) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    0:*:*) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;

    # No unexpected failures, but some xpasses
    *:0:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly." ;;

    # No expected failures, but failures and xpasses
    *:1:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failure)." ;;
    *:*:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failures)." ;;

    # All of them.
    *:*:1) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    *:*:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;
  esac

  if test $at_skip_count = 0 && test $at_run_count -gt 1; then
    at_result="All $at_result"
  fi
fi

# Now put skips in the mix.
case $at_skip_count in
  0) ;;
  1) at_result="$at_result
1 test was skipped." ;;
  *) at_result="$at_result
$at_skip_count tests were skipped." ;;
esac

if test $at_unexpected_count = 0; then
  echo "$at_color$at_result$at_std"
  echo "$at_result" >&5
else
  echo "${at_color}ERROR: $at_result$at_std" >&2
  echo "ERROR: $at_result" >&5
  {
    echo
    printf "%s\n" "## ------------------------ ##
## Summary of the failures. ##
## ------------------------ ##"

    # Summary of failed and skipped tests.
    if test $at_fail_count != 0; then
      echo "Failed tests:"
      $SHELL "$at_myself" $at_fail_list --list
      echo
    fi
    if test $at_skip_count != 0; then
      echo "Skipped tests:"
      $SHELL "$at_myself" $at_skip_list --list
      echo
    fi
    if test $at_xpass_count != 0; then
      echo "Unexpected passes:"
      $SHELL "$at_myself" $at_xpass_list --list
      echo
    fi
    if test $at_fail_count != 0; then
      printf "%s\n" "## ---------------------- ##
## Detailed failed tests. ##
## ---------------------- ##"
      echo
      for at_group in $at_fail_list
      do
	at_group_normalized=$at_group

  eval 'while :; do
    case $at_group_normalized in #(
    '"$at_format"'*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done'

	cat "$at_suite_dir/$at_group_normalized/$as_me.log"
	echo
      done
      echo
    fi
    if test -n "$at_top_srcdir"; then
      sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## ${at_top_build_prefix}config.log ##
_ASBOX
      sed 's/^/| /' ${at_top_build_prefix}config.log
      echo
    fi
  } >&5

  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $as_me.log was created. ##
_ASBOX

  echo
  if $at_debug_p; then
    at_msg='per-test log files'
  else
    at_msg="\`${at_testdir+${at_testdir}/}$as_me.log'"
  fi
  at_msg1a=${at_xpass_list:+', '}
  at_msg1=$at_fail_list${at_fail_list:+" failed$at_msg1a"}
  at_msg2=$at_xpass_list${at_xpass_list:+" passed unexpectedly"}

  printf "%s\n" "Please send $at_msg and all information you think might help:

   To: <bugs@openvswitch.org>
   Subject: [ovn 25.03.90] $as_me: $at_msg1$at_msg2

You may investigate any problem if you feel able to do so, in which
case the test suite provides a good starting point.  Its output may
be found below \`${at_testdir+${at_testdir}/}$as_me.dir'.
"
  exit 1
fi

exit 0

## ------------- ##
## Actual tests. ##
## ------------- ##
#AT_START_1
at_fn_group_banner 1 'multinode.at:3' \
  "ovn multinode basic test" "                       " 1
at_xfail=no
(
  printf "%s\n" "1. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

# Test East-West switching
check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.0.3 24 10.0.0.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.0.4 24 10.0.0.1 1000::4/64 1000::a

m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:23: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:23"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:23"
$at_failed && at_fn_log_failure
$at_traceon; }



# Add ACLs to drop all traffic
check multinode_nbctl pg-add pg0 sw0-port1 sw0-port2
check multinode_nbctl acl-add pg0 to-lport 1001 "outport == @pg0 && ip4" drop
check multinode_nbctl --wait=sb sync

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:33: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4"
at_fn_check_prepare_trace "multinode.at:33"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_status \
1 $at_status "$at_srcdir/multinode.at:33"
$at_failed && at_fn_log_failure
$at_traceon; }



# Add ACLs to allow icmp traffic
check multinode_nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && icmp" allow-related
check multinode_nbctl --wait=sb sync

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:40: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:40"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:40"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create the second logical switch with one port
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 sw1-port1
check multinode_nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

# Create a logical router and attach both logical switches
check multinode_nbctl lr-add lr0
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check multinode_nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check multinode_nbctl lsp-add sw1 sw1-lr0
check multinode_nbctl lsp-set-type sw1-lr0 router
check multinode_nbctl lsp-set-addresses sw1-lr0 router
check multinode_nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

m_as ovn-chassis-2 /data/create_fake_vm.sh sw1-port1 sw1p1 40:54:00:00:00:03 1342 20.0.0.3 24 20.0.0.1 2000::4/64 1000::a

m_wait_for_ports_up sw1-port1

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:68: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:68"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:68"
$at_failed && at_fn_log_failure
$at_traceon; }



check multinode_nbctl lsp-set-addresses sw1-port1 unknown
m_wait_for_ports_up sw1-port1

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:76: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:76"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:76"
$at_failed && at_fn_log_failure
$at_traceon; }



ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_1
#AT_START_2
at_fn_group_banner 2 'multinode.at:83' \
  "ovn multinode pmtu - distributed router - geneve" "" 1
at_xfail=no
(
  printf "%s\n" "2. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

m_as ovn-chassis-1 ip link del sw0p1-p
m_as ovn-chassis-2 ip link del sw0p2-p
m_as ovn-chassis-2 ip link del sw1p1-p

# Reset geneve tunnels
for c in ovn-chassis-1 ovn-chassis-2 ovn-gw-1
do
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=geneve
done

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:101" "until m_as ovn-chassis-1 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:102" "until m_as ovn-chassis-2 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-1 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:103" "until m_as ovn-gw-1 ip link show | grep -q genev_sys"


# Test East-West switching
check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.0.3 24 10.0.0.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.0.4 24 10.0.0.1 1000::4/64 1000::a

m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:117: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:117"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:117"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create the second logical switch with one port
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 sw1-port1
check multinode_nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

# Create a logical router and attach both logical switches
check multinode_nbctl lr-add lr0
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check multinode_nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check multinode_nbctl lsp-add sw1 sw1-lr0
check multinode_nbctl lsp-set-type sw1-lr0 router
check multinode_nbctl lsp-set-addresses sw1-lr0 router
check multinode_nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

m_as ovn-chassis-2 /data/create_fake_vm.sh sw1-port1 sw1p1 40:54:00:00:00:03 1342 20.0.0.3 24 20.0.0.1 2000::3/64 2000::a

# create exteranl connection for N/S traffic
check multinode_nbctl ls-add public
check multinode_nbctl lsp-add public ln-lublic
check multinode_nbctl lsp-set-type ln-lublic localnet
check multinode_nbctl lsp-set-addresses ln-lublic unknown
check multinode_nbctl lsp-set-options ln-lublic network_name=public

check multinode_nbctl lrp-add lr0 lr0-public 00:11:22:00:ff:01 172.20.0.100/24
check multinode_nbctl lsp-add public public-lr0
check multinode_nbctl lsp-set-type public-lr0 router
check multinode_nbctl lsp-set-addresses public-lr0 router
check multinode_nbctl lsp-set-options public-lr0 router-port=lr0-public
check multinode_nbctl lrp-set-gateway-chassis lr0-public ovn-gw-1 10
check multinode_nbctl lr-route-add lr0 0.0.0.0/0 172.20.0.1

check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 10.0.0.0/24
check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 20.0.0.0/24

# create some ACLs
check multinode_nbctl acl-add sw0 from-lport 1002 'ip4 || ip6'  allow-related
check multinode_nbctl acl-add sw1 from-lport 1002 'ip4 || ip6'  allow-related

# create LB
check multinode_nbctl lb-add lb0 10.0.0.1:8080 10.0.0.4:8080 udp
check multinode_nbctl ls-lb-add sw0 lb0
podman exec ovn-chassis-2 ip netns exec sw0p2 nc -u -l 8080 >/dev/null 2>&1 & echo $! > nc.pid
     echo "kill \`cat nc.pid\` 2>/dev/null" >> cleanup



m_add_internal_port ovn-gw-1 ovn-ext0 br-ex ext0 172.20.0.1/24
m_add_internal_port ovn-gw-1 ovn-ext0 br-ex ext1 172.20.1.1/24
m_add_internal_port ovn-gw-1 ovn-ext2 br-ex ext2 172.20.1.2/24 172.20.1.1

m_as ovn-gw-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-chassis-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-chassis-2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex

m_wait_for_ports_up sw1-port1

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:180: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:180"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:180"
$at_failed && at_fn_log_failure
$at_traceon; }



# Change ptmu for the geneve tunnel
m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1200 dev eth1
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:187: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i \"message too long\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:187"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i "message too long"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:187"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:189: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:189"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:189"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:190: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:190"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:190"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:191: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:191"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:191"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1400 dev eth1
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:194: podman exec ovn-chassis-1 ip netns exec sw0p1 ping6 -c 5 -s 1450 -M do 2000::3 2>&1 | grep -q -i \"message too long\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:194"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping6 -c 5 -s 1450 -M do 2000::3 2>&1 | grep -q -i "message too long"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:194"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:196: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:196"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:196"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:201: podman exec ovn-gw-1 ip netns exec ovn-ext0 ip link set dev ext1 mtu 1000"
at_fn_check_prepare_trace "multinode.at:201"
( $at_check_trace; podman exec ovn-gw-1 ip netns exec ovn-ext0 ip link set dev ext1 mtu 1000
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:201"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:202: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 10 -s 1300 -M do 172.20.1.2 2>&1 |grep -q \"mtu = 1000\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:202"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 10 -s 1300 -M do 172.20.1.2 2>&1 |grep -q "mtu = 1000"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:202"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:204: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:204"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:204"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1000 dev eth1
for i in $(seq 30); do
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:211: podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'dd bs=512 count=2 if=/dev/urandom | nc -u 10.0.0.1 8080'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:211"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'dd bs=512 count=2 if=/dev/urandom | nc -u 10.0.0.1 8080'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_skip $at_status "$at_srcdir/multinode.at:211"
$at_failed && at_fn_log_failure
$at_traceon; }


done
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:213: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route get 10.0.0.1 dev sw0p1 | grep -q 'mtu 942'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:213"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route get 10.0.0.1 dev sw0p1 | grep -q 'mtu 942'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:213"
$at_failed && at_fn_log_failure
$at_traceon; }



ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_2
#AT_START_3
at_fn_group_banner 3 'multinode.at:217' \
  "ovn multinode pmtu - distributed router - vxlan" "" 1
at_xfail=no
(
  printf "%s\n" "3. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

m_as ovn-chassis-1 ip link del sw0p1-p
m_as ovn-chassis-2 ip link del sw0p2-p
m_as ovn-chassis-2 ip link del sw1p1-p

# Reset vxlan tunnels
for c in ovn-chassis-1 ovn-chassis-2 ovn-gw-1
do
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=vxlan
done

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip link show | grep -q vxlan_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:235" "until m_as ovn-chassis-1 ip link show | grep -q vxlan_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip link show | grep -q vxlan_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:236" "until m_as ovn-chassis-2 ip link show | grep -q vxlan_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-1 ip link show | grep -q vxlan_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:237" "until m_as ovn-gw-1 ip link show | grep -q vxlan_sys"


# Test East-West switching
check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.0.3 24 10.0.0.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.0.4 24 10.0.0.1 1000::4/64 1000::a

m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:251: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:251"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:251"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create the second logical switch with one port
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 sw1-port1
check multinode_nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

# Create a logical router and attach both logical switches
check multinode_nbctl lr-add lr0
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check multinode_nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check multinode_nbctl lsp-add sw1 sw1-lr0
check multinode_nbctl lsp-set-type sw1-lr0 router
check multinode_nbctl lsp-set-addresses sw1-lr0 router
check multinode_nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

m_as ovn-chassis-2 /data/create_fake_vm.sh sw1-port1 sw1p1 40:54:00:00:00:03 1342 20.0.0.3 24 20.0.0.1 2000::3/64 2000::a

# create exteranl connection for N/S traffic
check multinode_nbctl ls-add public
check multinode_nbctl lsp-add public ln-lublic
check multinode_nbctl lsp-set-type ln-lublic localnet
check multinode_nbctl lsp-set-addresses ln-lublic unknown
check multinode_nbctl lsp-set-options ln-lublic network_name=public

check multinode_nbctl lrp-add lr0 lr0-public 00:11:22:00:ff:01 172.20.0.100/24
check multinode_nbctl lsp-add public public-lr0
check multinode_nbctl lsp-set-type public-lr0 router
check multinode_nbctl lsp-set-addresses public-lr0 router
check multinode_nbctl lsp-set-options public-lr0 router-port=lr0-public
check multinode_nbctl lrp-set-gateway-chassis lr0-public ovn-gw-1 10
check multinode_nbctl lr-route-add lr0 0.0.0.0/0 172.20.0.1

check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 10.0.0.0/24
check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 20.0.0.0/24

# create some ACLs
check multinode_nbctl acl-add sw0 from-lport 1002 'ip4 || ip6'  allow-related
check multinode_nbctl acl-add sw1 from-lport 1002 'ip4 || ip6'  allow-related

m_add_internal_port ovn-gw-1 ovn-ext0 br-ex ext0 172.20.0.1/24
m_add_internal_port ovn-gw-1 ovn-ext0 br-ex ext1 172.20.1.1/24
m_add_internal_port ovn-gw-1 ovn-ext2 br-ex ext2 172.20.1.2/24 172.20.1.1

m_as ovn-gw-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-chassis-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-chassis-2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex

m_wait_for_ports_up sw1-port1

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:309: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:309"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:309"
$at_failed && at_fn_log_failure
$at_traceon; }



# Change ptmu for the vxlan tunnel
m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1200 dev eth1
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:316: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 |grep -q -i \"message too long\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:316"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 |grep -q -i "message too long"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:316"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:318: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:318"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:318"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:319: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:319"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:319"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:320: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:320"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:320"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:322: podman exec ovn-gw-1 ip netns exec ovn-ext0 ip link set dev ext1 mtu 1100"
at_fn_check_prepare_trace "multinode.at:322"
( $at_check_trace; podman exec ovn-gw-1 ip netns exec ovn-ext0 ip link set dev ext1 mtu 1100
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:322"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:323: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:323"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:323"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:328: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 20 -i 0.5 -s 1300 -M do 172.20.1.2 2>&1 |grep -q \"mtu = 1150\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:328"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 20 -i 0.5 -s 1300 -M do 172.20.1.2 2>&1 |grep -q "mtu = 1150"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:328"
$at_failed && at_fn_log_failure
$at_traceon; }



ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_3
#AT_START_4
at_fn_group_banner 4 'multinode.at:332' \
  "ovn multinode pmtu - gw_router_port - geneve" "   " 1
at_xfail=no
(
  printf "%s\n" "4. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

m_as ovn-chassis-1 ip link del sw0p1-p
m_as ovn-chassis-2 ip link del sw0p2-p
m_as ovn-chassis-2 ip link del sw1p1-p

# Reset geneve tunnels
for c in ovn-chassis-1 ovn-chassis-2 ovn-gw-1
do
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=geneve
done

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:350" "until m_as ovn-chassis-1 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:351" "until m_as ovn-chassis-2 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-1 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:352" "until m_as ovn-gw-1 ip link show | grep -q genev_sys"


# Test East-West switching
check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.0.3 24 10.0.0.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.0.4 24 10.0.0.1 1000::4/64 1000::a

m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:366: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:366"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:366"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create the second logical switch with one port
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 sw1-port1
check multinode_nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

# Create a logical router and attach both logical switches
check multinode_nbctl lr-add lr0
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check multinode_nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check multinode_nbctl lsp-add sw1 sw1-lr0
check multinode_nbctl lsp-set-type sw1-lr0 router
check multinode_nbctl lsp-set-addresses sw1-lr0 router
check multinode_nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

m_as ovn-chassis-2 /data/create_fake_vm.sh sw1-port1 sw1p1 40:54:00:00:00:03 1342 20.0.0.3 24 20.0.0.1 2000::3/64 2000::a

# create exteranl connection for N/S traffic
check multinode_nbctl ls-add public
check multinode_nbctl lsp-add public ln-lublic
check multinode_nbctl lsp-set-type ln-lublic localnet
check multinode_nbctl lsp-set-addresses ln-lublic unknown
check multinode_nbctl lsp-set-options ln-lublic network_name=public

check multinode_nbctl lrp-add lr0 lr0-public 00:11:22:00:ff:01 172.20.0.100/24
check multinode_nbctl lsp-add public public-lr0
check multinode_nbctl lsp-set-type public-lr0 router
check multinode_nbctl lsp-set-addresses public-lr0 router
check multinode_nbctl lsp-set-options public-lr0 router-port=lr0-public
check multinode_nbctl lrp-set-gateway-chassis lr0-public ovn-gw-1 10
check multinode_nbctl lr-route-add lr0 0.0.0.0/0 172.20.0.1

check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 10.0.0.0/24
check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 20.0.0.0/24

check multinode_nbctl lrp-set-gateway-chassis lr0-sw0 ovn-chassis-1 10
check multinode_nbctl lrp-set-gateway-chassis lr0-sw1 ovn-chassis-2 10

# create some ACLs
check multinode_nbctl acl-add sw0 from-lport 1002 'ip4 || ip6'  allow-related
check multinode_nbctl acl-add sw1 from-lport 1002 'ip4 || ip6'  allow-related

m_add_internal_port ovn-gw-1 ovn-ext0 br-ex ext0 172.20.0.1/24
m_add_internal_port ovn-gw-1 ovn-ext0 br-ex ext1 172.20.1.1/24
m_add_internal_port ovn-gw-1 ovn-ext2 br-ex ext2 172.20.1.2/24 172.20.1.1

m_as ovn-gw-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-chassis-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-chassis-2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex

m_wait_for_ports_up sw1-port1

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:427: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:427"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:427"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:432: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:432"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:432"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:433: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:433"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:433"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:434: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:434"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:434"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1200 dev eth1
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:437: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i \"message too long\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:437"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i "message too long"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:437"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:439: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:439"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:439"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:440: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:440"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:440"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:441: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:441"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:441"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1400 dev eth1
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:444: podman exec ovn-chassis-1 ip netns exec sw0p1 ping6 -c 5 -s 1450 -M do 2000::3 2>&1 | grep -q -i \"message too long\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:444"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping6 -c 5 -s 1450 -M do 2000::3 2>&1 | grep -q -i "message too long"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:444"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:446: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:446"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:446"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:447: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:447"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:447"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:448: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:448"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:448"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:450: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:450"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:450"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:455: podman exec ovn-gw-1 ip netns exec ovn-ext0 ip link set dev ext1 mtu 1100"
at_fn_check_prepare_trace "multinode.at:455"
( $at_check_trace; podman exec ovn-gw-1 ip netns exec ovn-ext0 ip link set dev ext1 mtu 1100
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:455"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:456: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 20 -i 0.5 -s 1300 -M do 172.20.1.2 2>&1 |grep -q \"mtu = 1100\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:456"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 20 -i 0.5 -s 1300 -M do 172.20.1.2 2>&1 |grep -q "mtu = 1100"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:456"
$at_failed && at_fn_log_failure
$at_traceon; }



ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_4
#AT_START_5
at_fn_group_banner 5 'multinode.at:460' \
  "ovn multinode pmtu - gw_router_port - vxlan" "    " 1
at_xfail=no
(
  printf "%s\n" "5. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

m_as ovn-chassis-1 ip link del sw0p1-p
m_as ovn-chassis-2 ip link del sw0p2-p
m_as ovn-chassis-2 ip link del sw1p1-p

# Reset geneve tunnels
for c in ovn-chassis-1 ovn-chassis-2 ovn-gw-1
do
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=vxlan
done

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip link show | grep -q vxlan_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:478" "until m_as ovn-chassis-1 ip link show | grep -q vxlan_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip link show | grep -q vxlan_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:479" "until m_as ovn-chassis-2 ip link show | grep -q vxlan_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-1 ip link show | grep -q vxlan_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:480" "until m_as ovn-gw-1 ip link show | grep -q vxlan_sys"


# Test East-West switching
check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.0.3 24 10.0.0.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.0.4 24 10.0.0.1 1000::4/64 1000::a

m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:494: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:494"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:494"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create the second logical switch with one port
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 sw1-port1
check multinode_nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

# Create a logical router and attach both logical switches
check multinode_nbctl lr-add lr0
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check multinode_nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check multinode_nbctl lsp-add sw1 sw1-lr0
check multinode_nbctl lsp-set-type sw1-lr0 router
check multinode_nbctl lsp-set-addresses sw1-lr0 router
check multinode_nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

m_as ovn-chassis-2 /data/create_fake_vm.sh sw1-port1 sw1p1 40:54:00:00:00:03 1342 20.0.0.3 24 20.0.0.1 2000::3/64 2000::a

# create exteranl connection for N/S traffic
check multinode_nbctl ls-add public
check multinode_nbctl lsp-add public ln-lublic
check multinode_nbctl lsp-set-type ln-lublic localnet
check multinode_nbctl lsp-set-addresses ln-lublic unknown
check multinode_nbctl lsp-set-options ln-lublic network_name=public

check multinode_nbctl lrp-add lr0 lr0-public 00:11:22:00:ff:01 172.20.0.100/24
check multinode_nbctl lsp-add public public-lr0
check multinode_nbctl lsp-set-type public-lr0 router
check multinode_nbctl lsp-set-addresses public-lr0 router
check multinode_nbctl lsp-set-options public-lr0 router-port=lr0-public
check multinode_nbctl lrp-set-gateway-chassis lr0-public ovn-gw-1 10
check multinode_nbctl lr-route-add lr0 0.0.0.0/0 172.20.0.1

check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 10.0.0.0/24
check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 20.0.0.0/24

check multinode_nbctl lrp-set-gateway-chassis lr0-sw0 ovn-chassis-1 10
check multinode_nbctl lrp-set-gateway-chassis lr0-sw1 ovn-chassis-2 10

# create some ACLs
check multinode_nbctl acl-add sw0 from-lport 1002 'ip4 || ip6'  allow-related
check multinode_nbctl acl-add sw1 from-lport 1002 'ip4 || ip6'  allow-related

m_add_internal_port ovn-gw-1 ovn-ext0 br-ex ext0 172.20.0.1/24
m_add_internal_port ovn-gw-1 ovn-ext0 br-ex ext1 172.20.1.1/24
m_add_internal_port ovn-gw-1 ovn-ext2 br-ex ext2 172.20.1.2/24 172.20.1.1

m_as ovn-gw-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-chassis-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-chassis-2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex

m_wait_for_ports_up sw1-port1

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:555: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:555"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:555"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:560: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:560"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:560"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:561: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:561"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:561"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:562: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:562"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:562"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1200 dev eth1
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:565: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i \"message too long\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:565"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i "message too long"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:565"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:567: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:567"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:567"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:568: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:568"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:568"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:569: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:569"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:569"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:571: podman exec ovn-gw-1 ip netns exec ovn-ext0 ip link set dev ext1 mtu 1100"
at_fn_check_prepare_trace "multinode.at:571"
( $at_check_trace; podman exec ovn-gw-1 ip netns exec ovn-ext0 ip link set dev ext1 mtu 1100
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:571"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:572: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:572"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:572"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:577: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 20 -i 0.5 -s 1300 -M do 172.20.1.2 2>&1 |grep -q \"mtu = 1150\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:577"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 20 -i 0.5 -s 1300 -M do 172.20.1.2 2>&1 |grep -q "mtu = 1150"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:577"
$at_failed && at_fn_log_failure
$at_traceon; }



ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_5
#AT_START_6
at_fn_group_banner 6 'multinode.at:581' \
  "ovn multinode pmtu - gw router - geneve" "        " 1
at_xfail=no
(
  printf "%s\n" "6. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

m_as ovn-chassis-1 ip link del sw0p1-p
m_as ovn-chassis-2 ip link del sw0p2-p
m_as ovn-chassis-2 ip link del sw1p1-p

# Reset geneve tunnels
for c in ovn-chassis-1 ovn-chassis-2 ovn-gw-1
do
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=geneve
done

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:599" "until m_as ovn-chassis-1 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:600" "until m_as ovn-chassis-2 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-1 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:601" "until m_as ovn-gw-1 ip link show | grep -q genev_sys"


# Test East-West switching
check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.0.3 24 10.0.0.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.0.4 24 10.0.0.1 1000::4/64 1000::a

m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:615: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:615"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:615"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create the second logical switch with one port
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 sw1-port1
check multinode_nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

# Create a logical router and attach both logical switches
check multinode_nbctl lr-add lr0 -- set Logical_Router lr0 options:chassis=ovn-gw-1
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check multinode_nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check multinode_nbctl lsp-add sw1 sw1-lr0
check multinode_nbctl lsp-set-type sw1-lr0 router
check multinode_nbctl lsp-set-addresses sw1-lr0 router
check multinode_nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

m_as ovn-chassis-2 /data/create_fake_vm.sh sw1-port1 sw1p1 40:54:00:00:00:03 1342 20.0.0.3 24 20.0.0.1 2000::3/64 2000::a

# create exteranl connection for N/S traffic
check multinode_nbctl ls-add public
check multinode_nbctl lsp-add public ln-lublic
check multinode_nbctl lsp-set-type ln-lublic localnet
check multinode_nbctl lsp-set-addresses ln-lublic unknown
check multinode_nbctl lsp-set-options ln-lublic network_name=public

check multinode_nbctl lrp-add lr0 lr0-public 00:11:22:00:ff:01 172.20.0.100/24
check multinode_nbctl lsp-add public public-lr0
check multinode_nbctl lsp-set-type public-lr0 router
check multinode_nbctl lsp-set-addresses public-lr0 router
check multinode_nbctl lsp-set-options public-lr0 router-port=lr0-public
check multinode_nbctl lr-route-add lr0 0.0.0.0/0 172.20.0.1

check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 10.0.0.0/24
check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 20.0.0.0/24

# create some ACLs
check multinode_nbctl acl-add sw0 from-lport 1002 'ip4 || ip6'  allow-related
check multinode_nbctl acl-add sw1 from-lport 1002 'ip4 || ip6'  allow-related

# create LB
check multinode_nbctl lb-add lb0 10.0.0.1:8080 20.0.0.3:8080 udp
check multinode_nbctl lr-lb-add lr0 lb0
podman exec ovn-chassis-2 ip netns exec sw1p1 nc -u -l 8080 >/dev/null 2>&1 & echo $! > nc.pid
     echo "kill \`cat nc.pid\` 2>/dev/null" >> cleanup



m_add_internal_port ovn-gw-1 ovn-ext0 br-ex ext0 172.20.0.1/24
m_add_internal_port ovn-gw-1 ovn-ext0 br-ex ext1 172.20.1.1/24
m_add_internal_port ovn-gw-1 ovn-ext2 br-ex ext2 172.20.1.2/24 172.20.1.1

m_as ovn-gw-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-chassis-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-chassis-2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex

m_wait_for_ports_up sw1-port1

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:677: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:677"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:677"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:682: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:682"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:682"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:683: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:683"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:683"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:684: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:684"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:684"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1200 dev eth1
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:687: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i \"message too long\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:687"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i "message too long"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:687"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:689: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:689"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:689"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:690: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:690"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:690"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:691: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:691"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:691"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1400 dev eth1
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:694: podman exec ovn-chassis-1 ip netns exec sw0p1 ping6 -c 5 -s 1450 -M do 2000::3 2>&1 | grep -q -i \"message too long\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:694"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping6 -c 5 -s 1450 -M do 2000::3 2>&1 | grep -q -i "message too long"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:694"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:696: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:696"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:696"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:697: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:697"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:697"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:698: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:698"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:698"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:700: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:700"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:700"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:705: podman exec ovn-gw-1 ip netns exec ovn-ext0 ip link set dev ext1 mtu 1100"
at_fn_check_prepare_trace "multinode.at:705"
( $at_check_trace; podman exec ovn-gw-1 ip netns exec ovn-ext0 ip link set dev ext1 mtu 1100
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:705"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:706: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 20 -i 0.5 -s 1300 -M do 172.20.1.2 2>&1 | grep -q \"mtu = 1100\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:706"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 20 -i 0.5 -s 1300 -M do 172.20.1.2 2>&1 | grep -q "mtu = 1100"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:706"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:708: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:708"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:708"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:709: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:709"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:709"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:710: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:710"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:710"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1000 dev eth1
for i in $(seq 30); do
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:714: podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'dd bs=512 count=2 if=/dev/urandom | nc -u 10.0.0.1 8080'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:714"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'dd bs=512 count=2 if=/dev/urandom | nc -u 10.0.0.1 8080'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_skip $at_status "$at_srcdir/multinode.at:714"
$at_failed && at_fn_log_failure
$at_traceon; }


done
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:716: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route get 10.0.0.1 dev sw0p1 | grep -q 'mtu 942'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:716"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route get 10.0.0.1 dev sw0p1 | grep -q 'mtu 942'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:716"
$at_failed && at_fn_log_failure
$at_traceon; }



ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_6
#AT_START_7
at_fn_group_banner 7 'multinode.at:720' \
  "ovn multinode pmtu - gw router - vxlan" "         " 1
at_xfail=no
(
  printf "%s\n" "7. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

m_as ovn-chassis-1 ip link del sw0p1-p
m_as ovn-chassis-2 ip link del sw0p2-p
m_as ovn-chassis-2 ip link del sw1p1-p

# Reset geneve tunnels
for c in ovn-chassis-1 ovn-chassis-2 ovn-gw-1
do
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=vxlan
done

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip link show | grep -q vxlan_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:738" "until m_as ovn-chassis-1 ip link show | grep -q vxlan_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip link show | grep -q vxlan_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:739" "until m_as ovn-chassis-2 ip link show | grep -q vxlan_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-1 ip link show | grep -q vxlan_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:740" "until m_as ovn-gw-1 ip link show | grep -q vxlan_sys"


# Test East-West switching
check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.0.3 24 10.0.0.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.0.4 24 10.0.0.1 1000::4/64 1000::a

m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:754: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:754"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:754"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create the second logical switch with one port
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 sw1-port1
check multinode_nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

# Create a logical router and attach both logical switches
check multinode_nbctl lr-add lr0 -- set Logical_Router lr0 options:chassis=ovn-gw-1
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check multinode_nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check multinode_nbctl lsp-add sw1 sw1-lr0
check multinode_nbctl lsp-set-type sw1-lr0 router
check multinode_nbctl lsp-set-addresses sw1-lr0 router
check multinode_nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

m_as ovn-chassis-2 /data/create_fake_vm.sh sw1-port1 sw1p1 40:54:00:00:00:03 1342 20.0.0.3 24 20.0.0.1 2000::3/64 2000::a

# create exteranl connection for N/S traffic
check multinode_nbctl ls-add public
check multinode_nbctl lsp-add public ln-lublic
check multinode_nbctl lsp-set-type ln-lublic localnet
check multinode_nbctl lsp-set-addresses ln-lublic unknown
check multinode_nbctl lsp-set-options ln-lublic network_name=public

check multinode_nbctl lrp-add lr0 lr0-public 00:11:22:00:ff:01 172.20.0.100/24
check multinode_nbctl lsp-add public public-lr0
check multinode_nbctl lsp-set-type public-lr0 router
check multinode_nbctl lsp-set-addresses public-lr0 router
check multinode_nbctl lsp-set-options public-lr0 router-port=lr0-public
check multinode_nbctl lr-route-add lr0 0.0.0.0/0 172.20.0.1

check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 10.0.0.0/24
check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 20.0.0.0/24

# create some ACLs
check multinode_nbctl acl-add sw0 from-lport 1002 'ip4 || ip6'  allow-related
check multinode_nbctl acl-add sw1 from-lport 1002 'ip4 || ip6'  allow-related

# create LB
check multinode_nbctl lb-add lb0 10.0.0.1:8080 20.0.0.3:8080 udp
check multinode_nbctl lr-lb-add lr0 lb0
podman exec ovn-chassis-2 ip netns exec sw1p1 nc -u -l 8080 >/dev/null 2>&1 & echo $! > nc.pid
     echo "kill \`cat nc.pid\` 2>/dev/null" >> cleanup



m_add_internal_port ovn-gw-1 ovn-ext0 br-ex ext0 172.20.0.1/24
m_add_internal_port ovn-gw-1 ovn-ext0 br-ex ext1 172.20.1.1/24
m_add_internal_port ovn-gw-1 ovn-ext2 br-ex ext2 172.20.1.2/24 172.20.1.1

m_as ovn-gw-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-chassis-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-chassis-2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex

m_wait_for_ports_up sw1-port1

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:816: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:816"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:816"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:821: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:821"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:821"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:822: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:822"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:822"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:823: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:823"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:823"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1200 dev eth1
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:826: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i \"message too long\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:826"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i "message too long"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:826"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:828: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:828"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:828"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:829: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:829"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:829"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:830: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:830"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:830"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:832: podman exec ovn-gw-1 ip netns exec ovn-ext0 ip link set dev ext1 mtu 1100"
at_fn_check_prepare_trace "multinode.at:832"
( $at_check_trace; podman exec ovn-gw-1 ip netns exec ovn-ext0 ip link set dev ext1 mtu 1100
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:832"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:833: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:833"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.1.2 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:833"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:838: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 20 -i 0.5 -s 1300 -M do 172.20.1.2 2>&1 | grep -q \"mtu = 1150\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:838"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 20 -i 0.5 -s 1300 -M do 172.20.1.2 2>&1 | grep -q "mtu = 1150"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:838"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:840: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:840"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:840"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:841: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:841"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:841"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:842: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:842"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:842"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1000 dev eth1
for i in $(seq 30); do
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:846: podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'dd bs=512 count=2 if=/dev/urandom | nc -u 10.0.0.1 8080'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:846"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'dd bs=512 count=2 if=/dev/urandom | nc -u 10.0.0.1 8080'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_skip $at_status "$at_srcdir/multinode.at:846"
$at_failed && at_fn_log_failure
$at_traceon; }


done
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:848: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route get 10.0.0.1 dev sw0p1 | grep -q 'mtu 950'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:848"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route get 10.0.0.1 dev sw0p1 | grep -q 'mtu 950'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:848"
$at_failed && at_fn_log_failure
$at_traceon; }



ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_7
#AT_START_8
at_fn_group_banner 8 'multinode.at:1140' \
  "ovn multinode pmtu - logical switch - \"geneve\"" " " 1
at_xfail=no
(
  printf "%s\n" "8. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init

    encap="geneve"
    if test "$encap" = "vxlan"; then
      encap_sys="vxlan_sys"
      overhead=50
    else
      encap_sys="genev_sys"
      overhead=58
    fi

# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

m_as ovn-chassis-1 ip link del sw0p1-p
m_as ovn-chassis-2 ip link del sw0p2-p

# Reset geneve tunnels
for c in ovn-chassis-1 ovn-chassis-2 ovn-gw-1
do
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=$encap
done

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip link show | grep -q $encap_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1140" "until m_as ovn-chassis-1 ip link show | grep -q \$encap_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip link show | grep -q $encap_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1140" "until m_as ovn-chassis-2 ip link show | grep -q \$encap_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-1 ip link show | grep -q $encap_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1140" "until m_as ovn-gw-1 ip link show | grep -q \$encap_sys"


# Test East-West switching
check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.0.3 24 10.0.0.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.0.4 24 10.0.0.1 1000::4/64 1000::a

# Create the second logical switch with one port
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 sw1-port1
check multinode_nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

# Create a logical router and attach both logical switches
check multinode_nbctl lr-add lr0
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check multinode_nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check multinode_nbctl lsp-add sw1 sw1-lr0
check multinode_nbctl lsp-set-type sw1-lr0 router
check multinode_nbctl lsp-set-addresses sw1-lr0 router
check multinode_nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

m_as ovn-chassis-2 /data/create_fake_vm.sh sw1-port1 sw1p1 40:54:00:00:00:03 1342 20.0.0.3 24 20.0.0.1 2000::3/64 2000::a

check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 10.0.0.0/24
check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 20.0.0.0/24

check multinode_nbctl lrp-set-gateway-chassis lr0-sw0 ovn-chassis-1 10
check multinode_nbctl lrp-set-gateway-chassis lr0-sw1 ovn-chassis-2 10

# create some ACLs
check multinode_nbctl acl-add sw0 from-lport 1002 'ip4 || ip6'  allow-related
check multinode_nbctl acl-add sw1 from-lport 1002 'ip4 || ip6'  allow-related

check multinode_nbctl lb-add lb0 10.0.0.1:8080 10.0.0.4:8080 udp
check multinode_nbctl ls-lb-add sw0 lb0
podman exec ovn-chassis-2 ip netns exec sw0p2 nc -u -l 8080 >/dev/null 2>&1 & echo $! > nc.pid
     echo "kill \`cat nc.pid\` 2>/dev/null" >> cleanup



m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



# Change ptmu for the geneve tunnel
m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1200 dev eth1
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 10.0.0.4 2>&1 | grep -q -i \"message too long\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 10.0.0.4 2>&1 | grep -q -i "message too long"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



# Change ptmu for the geneve tunnel
m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1100 dev eth1
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i \"message too long\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i "message too long"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1000 dev eth1
mtu=$((1000 - overhead))
for i in $(seq 30); do
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'dd bs=512 count=2 if=/dev/urandom | nc -u 10.0.0.1 8080'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'dd bs=512 count=2 if=/dev/urandom | nc -u 10.0.0.1 8080'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_skip $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }


done
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route get 10.0.0.1 dev sw0p1 | grep -q \"mtu \$mtu\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route get 10.0.0.1 dev sw0p1 | grep -q "mtu $mtu"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



# Reset back to geneve tunnels
for c in ovn-chassis-1 ovn-chassis-2 ovn-gw-1
do
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=geneve
done

ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_8
#AT_START_9
at_fn_group_banner 9 'multinode.at:1140' \
  "ovn multinode NAT on a provider network with no localnet ports" "" 1
at_xfail=no
(
  printf "%s\n" "9. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

m_as ovn-chassis-1 ip link del sw0p1-p
m_as ovn-chassis-2 ip link del sw0p2-p
m_as ovn-chassis-2 ip link del sw1p1-p

check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.0.3 24 10.0.0.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.0.4 24 10.0.0.1 1000::4/64 1000::a

m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create the second logical switch with one port
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 sw1-port1
check multinode_nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

# Create a logical router and attach both logical switches
check multinode_nbctl lr-add lr0
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check multinode_nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check multinode_nbctl lsp-add sw1 sw1-lr0
check multinode_nbctl lsp-set-type sw1-lr0 router
check multinode_nbctl lsp-set-addresses sw1-lr0 router
check multinode_nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

m_as ovn-chassis-2 /data/create_fake_vm.sh sw1-port1 sw1p1 40:54:00:00:00:03 1342 20.0.0.3 24 20.0.0.1 2000::3/64 2000::a

# create exteranl connection for N/S traffic
check multinode_nbctl ls-add public
check multinode_nbctl lsp-add public ln-public
check multinode_nbctl lsp-set-type ln-public localnet
check multinode_nbctl lsp-set-addresses ln-public unknown
check multinode_nbctl lsp-set-options ln-public network_name=public

check multinode_nbctl lrp-add lr0 lr0-public 00:11:22:00:ff:01 172.20.0.100/24
check multinode_nbctl lsp-add public public-lr0
check multinode_nbctl lsp-set-type public-lr0 router
check multinode_nbctl lsp-set-addresses public-lr0 router
check multinode_nbctl lsp-set-options public-lr0 router-port=lr0-public
check multinode_nbctl lrp-set-gateway-chassis lr0-public ovn-gw-1 10

check multinode_nbctl lr-nat-add lr0 dnat_and_snat 172.20.0.110 10.0.0.3 sw0-port1 30:54:00:00:00:03
check multinode_nbctl lr-nat-add lr0 dnat_and_snat 172.20.0.120 20.0.0.3
check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 10.0.0.0/24
check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 20.0.0.0/24

# Create a logical port pub-p1 and bind it in ovn-chassis-1
check multinode_nbctl lsp-add public public-port1
check multinode_nbctl lsp-set-addresses public-port1 "60:54:00:00:00:03 172.168.0.50"

m_as ovn-chassis-1 /data/create_fake_vm.sh public-port1 pubp1 60:54:00:00:00:03 1342 172.20.0.50 24 172.20.0.100

check multinode_nbctl --wait=hv sync

# First do basic ping tests before deleting the localnet port - ln-public.
# Once the localnet port is deleted from public ls, routing for 172.20.0.0/24
# is centralized on ovn-gw-1.

# This function checks the North-South traffic.
run_ns_traffic() {
   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec pubp1 arp -d 172.20.0.110"
at_fn_check_prepare_trace "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 arp -d 172.20.0.110
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_skip $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }


   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec pubp1 arp -d 172.20.0.120"
at_fn_check_prepare_trace "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 arp -d 172.20.0.120
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_skip $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.100 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.100 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.110 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.110 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.120 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.120 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.50 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.50 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-2 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.50 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-2 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.50 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



  # Now ping from pubp1 to 172.20.0.100, 172.20.0.110, 172.20.0.120, 10.0.0.3 and 20.0.0.3
   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 172.20.0.100 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 172.20.0.100 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 172.20.0.110 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 172.20.0.110 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 172.20.0.120 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 172.20.0.120 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 10.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 10.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1140: podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1140"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1140"
$at_failed && at_fn_log_failure
$at_traceon; }


}

# Test out the N-S traffic.
run_ns_traffic

# Delete the localnet port by changing the type of ln-public to VIF port.
check multinode_nbctl --wait=hv lsp-set-type ln-public ""

m_check_row_count Port_Binding 1 logical_port=cr-public-lr0
m_check_column chassisredirect Port_Binding type logical_port=cr-public-lr0

# Test out the N-S traffic.
run_ns_traffic

# Re-add the localnet port
check multinode_nbctl --wait=hv lsp-set-type ln-public localnet

m_check_row_count Port_Binding 0 logical_port=cr-public-lr0

# Test out the N-S traffic.
run_ns_traffic

# Delete the ln-public port this time.
check multinode_nbctl --wait=hv lsp-del ln-public

m_check_row_count Port_Binding 1 logical_port=cr-public-lr0
m_check_column chassisredirect Port_Binding type logical_port=cr-public-lr0

# Test out the N-S traffic.
run_ns_traffic

ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_9
#AT_START_10
at_fn_group_banner 10 'multinode.at:1141' \
  "ovn multinode pmtu - logical switch - \"vxlan\"" "  " 1
at_xfail=no
(
  printf "%s\n" "10. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init

    encap="vxlan"
    if test "$encap" = "vxlan"; then
      encap_sys="vxlan_sys"
      overhead=50
    else
      encap_sys="genev_sys"
      overhead=58
    fi

# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

m_as ovn-chassis-1 ip link del sw0p1-p
m_as ovn-chassis-2 ip link del sw0p2-p

# Reset geneve tunnels
for c in ovn-chassis-1 ovn-chassis-2 ovn-gw-1
do
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=$encap
done

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip link show | grep -q $encap_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1141" "until m_as ovn-chassis-1 ip link show | grep -q \$encap_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip link show | grep -q $encap_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1141" "until m_as ovn-chassis-2 ip link show | grep -q \$encap_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-1 ip link show | grep -q $encap_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1141" "until m_as ovn-gw-1 ip link show | grep -q \$encap_sys"


# Test East-West switching
check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.0.3 24 10.0.0.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.0.4 24 10.0.0.1 1000::4/64 1000::a

# Create the second logical switch with one port
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 sw1-port1
check multinode_nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

# Create a logical router and attach both logical switches
check multinode_nbctl lr-add lr0
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check multinode_nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check multinode_nbctl lsp-add sw1 sw1-lr0
check multinode_nbctl lsp-set-type sw1-lr0 router
check multinode_nbctl lsp-set-addresses sw1-lr0 router
check multinode_nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

m_as ovn-chassis-2 /data/create_fake_vm.sh sw1-port1 sw1p1 40:54:00:00:00:03 1342 20.0.0.3 24 20.0.0.1 2000::3/64 2000::a

check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 10.0.0.0/24
check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 20.0.0.0/24

check multinode_nbctl lrp-set-gateway-chassis lr0-sw0 ovn-chassis-1 10
check multinode_nbctl lrp-set-gateway-chassis lr0-sw1 ovn-chassis-2 10

# create some ACLs
check multinode_nbctl acl-add sw0 from-lport 1002 'ip4 || ip6'  allow-related
check multinode_nbctl acl-add sw1 from-lport 1002 'ip4 || ip6'  allow-related

check multinode_nbctl lb-add lb0 10.0.0.1:8080 10.0.0.4:8080 udp
check multinode_nbctl ls-lb-add sw0 lb0
podman exec ovn-chassis-2 ip netns exec sw0p2 nc -u -l 8080 >/dev/null 2>&1 & echo $! > nc.pid
     echo "kill \`cat nc.pid\` 2>/dev/null" >> cleanup



m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



# Change ptmu for the geneve tunnel
m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1200 dev eth1
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 10.0.0.4 2>&1 | grep -q -i \"message too long\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 10.0.0.4 2>&1 | grep -q -i "message too long"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



# Change ptmu for the geneve tunnel
m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1100 dev eth1
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i \"message too long\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -c 5 -s 1300 -M do 20.0.0.3 2>&1 | grep -q -i "message too long"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1"
at_fn_check_prepare_trace "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route flush dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add 10.0.0.0/24 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1"
at_fn_check_prepare_trace "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route add default via 10.0.0.1 dev sw0p1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 ip route change 170.168.0.0/16 mtu 1000 dev eth1
mtu=$((1000 - overhead))
for i in $(seq 30); do
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'dd bs=512 count=2 if=/dev/urandom | nc -u 10.0.0.1 8080'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'dd bs=512 count=2 if=/dev/urandom | nc -u 10.0.0.1 8080'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_skip $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }


done
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ip route get 10.0.0.1 dev sw0p1 | grep -q \"mtu \$mtu\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ip route get 10.0.0.1 dev sw0p1 | grep -q "mtu $mtu"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



# Reset back to geneve tunnels
for c in ovn-chassis-1 ovn-chassis-2 ovn-gw-1
do
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=geneve
done

ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_10
#AT_START_11
at_fn_group_banner 11 'multinode.at:1141' \
  "ovn multinode NAT on a provider network with no localnet ports" "" 1
at_xfail=no
(
  printf "%s\n" "11. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

m_as ovn-chassis-1 ip link del sw0p1-p
m_as ovn-chassis-2 ip link del sw0p2-p
m_as ovn-chassis-2 ip link del sw1p1-p

check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.0.3 24 10.0.0.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.0.4 24 10.0.0.1 1000::4/64 1000::a

m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create the second logical switch with one port
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 sw1-port1
check multinode_nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

# Create a logical router and attach both logical switches
check multinode_nbctl lr-add lr0
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check multinode_nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check multinode_nbctl lsp-add sw1 sw1-lr0
check multinode_nbctl lsp-set-type sw1-lr0 router
check multinode_nbctl lsp-set-addresses sw1-lr0 router
check multinode_nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

m_as ovn-chassis-2 /data/create_fake_vm.sh sw1-port1 sw1p1 40:54:00:00:00:03 1342 20.0.0.3 24 20.0.0.1 2000::3/64 2000::a

# create exteranl connection for N/S traffic
check multinode_nbctl ls-add public
check multinode_nbctl lsp-add public ln-public
check multinode_nbctl lsp-set-type ln-public localnet
check multinode_nbctl lsp-set-addresses ln-public unknown
check multinode_nbctl lsp-set-options ln-public network_name=public

check multinode_nbctl lrp-add lr0 lr0-public 00:11:22:00:ff:01 172.20.0.100/24
check multinode_nbctl lsp-add public public-lr0
check multinode_nbctl lsp-set-type public-lr0 router
check multinode_nbctl lsp-set-addresses public-lr0 router
check multinode_nbctl lsp-set-options public-lr0 router-port=lr0-public
check multinode_nbctl lrp-set-gateway-chassis lr0-public ovn-gw-1 10

check multinode_nbctl lr-nat-add lr0 dnat_and_snat 172.20.0.110 10.0.0.3 sw0-port1 30:54:00:00:00:03
check multinode_nbctl lr-nat-add lr0 dnat_and_snat 172.20.0.120 20.0.0.3
check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 10.0.0.0/24
check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 20.0.0.0/24

# Create a logical port pub-p1 and bind it in ovn-chassis-1
check multinode_nbctl lsp-add public public-port1
check multinode_nbctl lsp-set-addresses public-port1 "60:54:00:00:00:03 172.168.0.50"

m_as ovn-chassis-1 /data/create_fake_vm.sh public-port1 pubp1 60:54:00:00:00:03 1342 172.20.0.50 24 172.20.0.100

check multinode_nbctl --wait=hv sync

# First do basic ping tests before deleting the localnet port - ln-public.
# Once the localnet port is deleted from public ls, routing for 172.20.0.0/24
# is centralized on ovn-gw-1.

# This function checks the North-South traffic.
run_ns_traffic() {
   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec pubp1 arp -d 172.20.0.110"
at_fn_check_prepare_trace "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 arp -d 172.20.0.110
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_skip $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }


   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec pubp1 arp -d 172.20.0.120"
at_fn_check_prepare_trace "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 arp -d 172.20.0.120
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
at_fn_check_skip $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.100 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.100 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.110 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.110 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.120 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.120 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.50 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.50 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-2 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.50 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-2 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.50 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



  # Now ping from pubp1 to 172.20.0.100, 172.20.0.110, 172.20.0.120, 10.0.0.3 and 20.0.0.3
   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 172.20.0.100 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 172.20.0.100 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 172.20.0.110 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 172.20.0.110 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 172.20.0.120 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 172.20.0.120 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 10.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 10.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }



   { set +x
printf "%s\n" "$at_srcdir/multinode.at:1141: podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1141"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec pubp1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1141"
$at_failed && at_fn_log_failure
$at_traceon; }


}

# Test out the N-S traffic.
run_ns_traffic

# Delete the localnet port by changing the type of ln-public to VIF port.
check multinode_nbctl --wait=hv lsp-set-type ln-public ""

m_check_row_count Port_Binding 1 logical_port=cr-public-lr0
m_check_column chassisredirect Port_Binding type logical_port=cr-public-lr0

# Test out the N-S traffic.
run_ns_traffic

# Re-add the localnet port
check multinode_nbctl --wait=hv lsp-set-type ln-public localnet

m_check_row_count Port_Binding 0 logical_port=cr-public-lr0

# Test out the N-S traffic.
run_ns_traffic

# Delete the ln-public port this time.
check multinode_nbctl --wait=hv lsp-del ln-public

m_check_row_count Port_Binding 1 logical_port=cr-public-lr0
m_check_column chassisredirect Port_Binding type logical_port=cr-public-lr0

# Test out the N-S traffic.
run_ns_traffic

ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_11
#AT_START_12
at_fn_group_banner 12 'multinode.at:1143' \
  "ovn provider network - always_tunnel" "           " 1
at_xfail=no
(
  printf "%s\n" "12. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

m_as ovn-chassis-1 ip link del sw0p1-p
m_as ovn-chassis-2 ip link del sw0p2-p
m_as ovn-chassis-2 ip link del sw1p1-p

# Reset geneve tunnels
for c in ovn-chassis-1 ovn-chassis-2 ovn-gw-1
do
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=geneve
done

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1161" "until m_as ovn-chassis-1 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1162" "until m_as ovn-chassis-2 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-1 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1163" "until m_as ovn-gw-1 ip link show | grep -q genev_sys"


# The goal of this test case is to see the traffic works for
# E-W switching and routing when the logical switches has localnet ports
# and the option - always_tunnel=true is set.  When this option
# is set, traffic is tunneled to the destination chassis instead of using
# localnet ports.

check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.0.3 24 10.0.0.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.0.4 24 10.0.0.1 1000::4/64 1000::a

m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1182: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1182"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1182"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create the second logical switch with one port
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 sw1-port1
check multinode_nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

# Create a logical router and attach both logical switches
check multinode_nbctl lr-add lr0
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check multinode_nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check multinode_nbctl lsp-add sw1 sw1-lr0
check multinode_nbctl lsp-set-type sw1-lr0 router
check multinode_nbctl lsp-set-addresses sw1-lr0 router
check multinode_nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

m_as ovn-chassis-2 /data/create_fake_vm.sh sw1-port1 sw1p1 40:54:00:00:00:03 1342 20.0.0.3 24 20.0.0.1 2000::3/64 2000::a

# create exteranl connection for N/S traffic
check multinode_nbctl ls-add public
check multinode_nbctl lsp-add public ln-lublic
check multinode_nbctl lsp-set-type ln-lublic localnet
check multinode_nbctl lsp-set-addresses ln-lublic unknown
check multinode_nbctl lsp-set-options ln-lublic network_name=public

check multinode_nbctl lrp-add lr0 lr0-public 00:11:22:00:ff:01 172.20.0.100/24
check multinode_nbctl lsp-add public public-lr0
check multinode_nbctl lsp-set-type public-lr0 router
check multinode_nbctl lsp-set-addresses public-lr0 router
check multinode_nbctl lsp-set-options public-lr0 router-port=lr0-public
check multinode_nbctl lrp-set-gateway-chassis lr0-public ovn-gw-1 10
check multinode_nbctl lr-route-add lr0 0.0.0.0/0 172.20.0.1

check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 10.0.0.0/24
check multinode_nbctl lr-nat-add lr0 snat 172.20.0.100 20.0.0.0/24

# create localnet ports for sw0 and sw1
check multinode_nbctl lsp-add sw0 ln-sw0
check multinode_nbctl lsp-set-type ln-sw0 localnet
check multinode_nbctl lsp-set-addresses ln-sw0 unknown
check multinode_nbctl lsp-set-options ln-sw0 network_name=public
check multinode_nbctl set logical_switch_port ln-sw0 tag_request=100

check multinode_nbctl lsp-add sw1 ln-sw1
check multinode_nbctl lsp-set-type ln-sw1 localnet
check multinode_nbctl lsp-set-addresses ln-sw1 unknown
check multinode_nbctl lsp-set-options ln-sw1 network_name=public
check multinode_nbctl set logical_switch_port ln-sw1 tag_request=101

check multinode_nbctl --wait=hv sync


     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei genev_sys_6081 icmp >ch1_genev.tcpdump 2>ch1_genev.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_genev.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1241" "until grep -q \"listening\" ch1_genev.stderr"




     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei eth2 icmp >ch1_eth2.tcpdump 2>ch1_eth2.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_eth2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1242" "until grep -q \"listening\" ch1_eth2.stderr"




 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1244: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1244"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1244"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1249: cat ch1_eth2.tcpdump | cut -d  ' ' -f2-22"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1249"
( $at_check_trace; cat ch1_eth2.tcpdump | cut -d  ' ' -f2-22
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "50:54:00:00:00:03 > 50:54:00:00:00:04, ethertype 802.1Q (0x8100), length 102: vlan 100, p 0, ethertype IPv4 (0x0800), 10.0.0.3 > 10.0.0.4: ICMP echo request,
50:54:00:00:00:04 > 50:54:00:00:00:03, ethertype 802.1Q (0x8100), length 102: vlan 100, p 0, ethertype IPv4 (0x0800), 10.0.0.4 > 10.0.0.3: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1249"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1254: cat ch1_genev.tcpdump"
at_fn_check_prepare_trace "multinode.at:1254"
( $at_check_trace; cat ch1_genev.tcpdump
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1254"
$at_failed && at_fn_log_failure
$at_traceon; }


m_as ovn-chassis-1 killall tcpdump
rm -f *.tcpdump
rm -f *.stderr


     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei genev_sys_6081 icmp >ch1_genev.tcpdump 2>ch1_genev.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_genev.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1261" "until grep -q \"listening\" ch1_genev.stderr"




     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei eth2 icmp >ch1_eth2.tcpdump 2>ch1_eth2.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_eth2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1262" "until grep -q \"listening\" ch1_eth2.stderr"




 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1264: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1264"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1264"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1269: cat ch1_eth2.tcpdump | cut -d  ' ' -f2-22"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1269"
( $at_check_trace; cat ch1_eth2.tcpdump | cut -d  ' ' -f2-22
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "00:00:00:00:ff:02 > 40:54:00:00:00:03, ethertype 802.1Q (0x8100), length 102: vlan 101, p 0, ethertype IPv4 (0x0800), 10.0.0.3 > 20.0.0.3: ICMP echo request,
00:00:00:00:ff:01 > 50:54:00:00:00:03, ethertype 802.1Q (0x8100), length 102: vlan 100, p 0, ethertype IPv4 (0x0800), 20.0.0.3 > 10.0.0.3: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1269"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1274: cat ch1_genev.tcpdump"
at_fn_check_prepare_trace "multinode.at:1274"
( $at_check_trace; cat ch1_genev.tcpdump
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1274"
$at_failed && at_fn_log_failure
$at_traceon; }


# Set the option always_tunnel=true.
# Traffic from sw0p1 to sw0p2 should be tunneled.
check multinode_nbctl set NB_Global . options:always_tunnel=true
check multinode_nbctl --wait=hv sync

m_as ovn-chassis-1 killall tcpdump
rm -f *.tcpdump
rm -f *.stderr


     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei genev_sys_6081 icmp >ch1_genev.tcpdump 2>ch1_genev.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_genev.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1286" "until grep -q \"listening\" ch1_genev.stderr"




     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei eth2 icmp >ch1_eth2.tcpdump 2>ch1_eth2.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_eth2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1287" "until grep -q \"listening\" ch1_eth2.stderr"




 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1289: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1289"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1289"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1294: cat ch1_genev.tcpdump | cut -d  ' ' -f2-15"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1294"
( $at_check_trace; cat ch1_genev.tcpdump | cut -d  ' ' -f2-15
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "50:54:00:00:00:03 > 50:54:00:00:00:04, ethertype IPv4 (0x0800), length 98: 10.0.0.3 > 10.0.0.4: ICMP echo request,
50:54:00:00:00:04 > 50:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 10.0.0.4 > 10.0.0.3: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1294"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1299: cat ch1_eth2.tcpdump"
at_fn_check_prepare_trace "multinode.at:1299"
( $at_check_trace; cat ch1_eth2.tcpdump
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1299"
$at_failed && at_fn_log_failure
$at_traceon; }


m_as ovn-chassis-1 killall tcpdump
rm -f *.tcpdump
rm -f *.stderr


     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei genev_sys_6081 icmp >ch1_genev.tcpdump 2>ch1_genev.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_genev.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1306" "until grep -q \"listening\" ch1_genev.stderr"




     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei eth2 icmp >ch1_eth2.tcpdump 2>ch1_eth2.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_eth2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1307" "until grep -q \"listening\" ch1_eth2.stderr"




 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1309: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1309"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1309"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1314: cat ch1_genev.tcpdump | cut -d  ' ' -f2-15"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1314"
( $at_check_trace; cat ch1_genev.tcpdump | cut -d  ' ' -f2-15
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "00:00:00:00:ff:02 > 40:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 10.0.0.3 > 20.0.0.3: ICMP echo request,
00:00:00:00:ff:01 > 50:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 20.0.0.3 > 10.0.0.3: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1314"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1319: cat ch1_eth2.tcpdump"
at_fn_check_prepare_trace "multinode.at:1319"
( $at_check_trace; cat ch1_eth2.tcpdump
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1319"
$at_failed && at_fn_log_failure
$at_traceon; }


m_as ovn-chassis-1 killall tcpdump
rm -f *.tcpdump
rm -f *.stderr

# Delete ln-sw1.
check multinode_nbctl --wait=hv lsp-del ln-sw1
# Traffic from sw0p1 to sw1p1 should be tunneled.


     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei genev_sys_6081 icmp >ch1_genev.tcpdump 2>ch1_genev.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_genev.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1330" "until grep -q \"listening\" ch1_genev.stderr"




     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei eth2 icmp >ch1_eth2.tcpdump 2>ch1_eth2.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_eth2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1331" "until grep -q \"listening\" ch1_eth2.stderr"




 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1333: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1333"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.0.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1333"
$at_failed && at_fn_log_failure
$at_traceon; }



{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1338: cat ch1_genev.tcpdump | cut -d  ' ' -f2-15"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1338"
( $at_check_trace; cat ch1_genev.tcpdump | cut -d  ' ' -f2-15
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "00:00:00:00:ff:02 > 40:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 10.0.0.3 > 20.0.0.3: ICMP echo request,
00:00:00:00:ff:01 > 50:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 20.0.0.3 > 10.0.0.3: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1338"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1343: cat ch1_eth2.tcpdump"
at_fn_check_prepare_trace "multinode.at:1343"
( $at_check_trace; cat ch1_eth2.tcpdump
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1343"
$at_failed && at_fn_log_failure
$at_traceon; }


m_as ovn-chassis-1 killall tcpdump
rm -f *.tcpdump
rm -f *.stderr

# Make sure that traffic from sw0 still goes out of localnet port
# for IPs not managed by OVN.
# Create a fake vm in br-ex on ovn-gw-1 with IP - 10.0.0.10
m_add_internal_port ovn-gw-1 sw0-p10 br-ex sw0-p10 10.0.0.10/24
m_as ovn-gw-1 ovs-vsctl set port sw0-p10 tag=100
m_as ovn-gw-1 ip netns exec sw0-p10 ip link set sw0-p10 address 32:31:8c:da:64:4f

# Ping from sw0p1 (on ovn-chassis-1) tp sw0-p10 which is in ovn-gw-1 on
# external bridge.  The traffic path is
# sw0p1 -> br-int -> localnet port (vlan tagged 100) -> br-ex -> eth2 of ovn-chassis-1 to
# eth2 of ovn-gw-1  -> br-ex -> sw0-p10


     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei genev_sys_6081 icmp >ch1_genev.tcpdump 2>ch1_genev.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_genev.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1362" "until grep -q \"listening\" ch1_genev.stderr"




     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei eth2 icmp >ch1_eth2.tcpdump 2>ch1_eth2.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_eth2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1363" "until grep -q \"listening\" ch1_eth2.stderr"




     podman exec ovn-gw-1 tcpdump -l -c 2 -neei eth2 icmp >gw1_eth2.tcpdump 2>gw1_eth2.stderr &
     echo "podman exec ovn-gw-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-gw-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" gw1_eth2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1364" "until grep -q \"listening\" gw1_eth2.stderr"




 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1366: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.10 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1366"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.0.10 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1366"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 killall tcpdump
m_as ovn-gw-1 killall tcpdump

{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1374: cat ch1_eth2.tcpdump | cut -d  ' ' -f2-22"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1374"
( $at_check_trace; cat ch1_eth2.tcpdump | cut -d  ' ' -f2-22
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "50:54:00:00:00:03 > 32:31:8c:da:64:4f, ethertype 802.1Q (0x8100), length 102: vlan 100, p 0, ethertype IPv4 (0x0800), 10.0.0.3 > 10.0.0.10: ICMP echo request,
32:31:8c:da:64:4f > 50:54:00:00:00:03, ethertype 802.1Q (0x8100), length 102: vlan 100, p 0, ethertype IPv4 (0x0800), 10.0.0.10 > 10.0.0.3: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1374"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1379: cat ch1_genev.tcpdump"
at_fn_check_prepare_trace "multinode.at:1379"
( $at_check_trace; cat ch1_genev.tcpdump
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1379"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1383: cat gw1_eth2.tcpdump | cut -d  ' ' -f2-22"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1383"
( $at_check_trace; cat gw1_eth2.tcpdump | cut -d  ' ' -f2-22
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "50:54:00:00:00:03 > 32:31:8c:da:64:4f, ethertype 802.1Q (0x8100), length 102: vlan 100, p 0, ethertype IPv4 (0x0800), 10.0.0.3 > 10.0.0.10: ICMP echo request,
32:31:8c:da:64:4f > 50:54:00:00:00:03, ethertype 802.1Q (0x8100), length 102: vlan 100, p 0, ethertype IPv4 (0x0800), 10.0.0.10 > 10.0.0.3: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1383"
$at_failed && at_fn_log_failure
$at_traceon; }


rm -f *.tcpdump
rm -f *.stderr

# Add dnat_and_snat entry for 10.0.0.3 <-> 172.20.0.110
check multinode_nbctl --wait=hv lr-nat-add lr0 dnat_and_snat 172.20.0.110 10.0.0.3 sw0-port1 30:54:00:00:00:03

# Ping from sw1-p1 to 172.20.0.110
# Traffic path is
# sw1-p1 in ovn-chassis-2 -> tunnel -> ovn-gw-1 -> In ovn-gw-1 SNAT 20.0.0.3 to 172.20.0.100 ->
#  -> ln-public -> br-ex -> eth2 -> ovn-chassis-1 -> br-ex -> ln-public -> br-int ->
#  -> DNAT 172.20.0.110 to 10.0.0.3 -> sw0-p1 with src ip 172.20.0.100 and dst ip 10.0.0.3.


     podman exec ovn-chassis-2 tcpdump -l -c 2 -neei genev_sys_6081 icmp >ch2_genev.tcpdump 2>ch2_genev.stderr &
     echo "podman exec ovn-chassis-2 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-2 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch2_genev.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1400" "until grep -q \"listening\" ch2_genev.stderr"




     podman exec ovn-chassis-2 tcpdump -l -c 2 -neei eth2 icmp >ch2_eth2.tcpdump 2>ch2_eth2.stderr &
     echo "podman exec ovn-chassis-2 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-2 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch2_eth2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1401" "until grep -q \"listening\" ch2_eth2.stderr"




     podman exec ovn-gw-1 tcpdump -l -c 2 -neei genev_sys_6081 icmp >gw1_geneve.tcpdump 2>gw1_geneve.stderr &
     echo "podman exec ovn-gw-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-gw-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" gw1_geneve.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1402" "until grep -q \"listening\" gw1_geneve.stderr"




     podman exec ovn-gw-1 tcpdump -l -c 2 -neei eth2 icmp >gw1_eth2.tcpdump 2>gw1_eth2.stderr &
     echo "podman exec ovn-gw-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-gw-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" gw1_eth2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1403" "until grep -q \"listening\" gw1_eth2.stderr"




     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei genev_sys_6081 icmp >ch1_genev.tcpdump 2>ch1_genev.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_genev.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1404" "until grep -q \"listening\" ch1_genev.stderr"




     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei eth2 icmp >ch1_eth2.tcpdump 2>ch1_eth2.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_eth2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1405" "until grep -q \"listening\" ch1_eth2.stderr"




 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1407: podman exec ovn-chassis-2 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.110 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1407"
( $at_check_trace; podman exec ovn-chassis-2 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.110 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1407"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 killall tcpdump
m_as ovn-chassis-2 killall tcpdump
m_as ovn-gw-1 killall tcpdump

{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1416: cat ch2_genev.tcpdump | cut -d  ' ' -f2-15"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1416"
( $at_check_trace; cat ch2_genev.tcpdump | cut -d  ' ' -f2-15
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "00:11:22:00:ff:01 > 30:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 20.0.0.3 > 172.20.0.110: ICMP echo request,
00:00:00:00:ff:02 > 40:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 172.20.0.110 > 20.0.0.3: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1416"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1421: cat gw1_geneve.tcpdump | cut -d  ' ' -f2-15"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1421"
( $at_check_trace; cat gw1_geneve.tcpdump | cut -d  ' ' -f2-15
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "00:11:22:00:ff:01 > 30:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 20.0.0.3 > 172.20.0.110: ICMP echo request,
00:00:00:00:ff:02 > 40:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 172.20.0.110 > 20.0.0.3: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1421"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1426: cat gw1_eth2.tcpdump | cut -d  ' ' -f2-15"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1426"
( $at_check_trace; cat gw1_eth2.tcpdump | cut -d  ' ' -f2-15
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "00:11:22:00:ff:01 > 30:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 172.20.0.100 > 172.20.0.110: ICMP echo request,
30:54:00:00:00:03 > 00:11:22:00:ff:01, ethertype IPv4 (0x0800), length 98: 172.20.0.110 > 172.20.0.100: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1426"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1431: cat ch1_eth2.tcpdump | cut -d  ' ' -f2-15"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1431"
( $at_check_trace; cat ch1_eth2.tcpdump | cut -d  ' ' -f2-15
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "00:11:22:00:ff:01 > 30:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 172.20.0.100 > 172.20.0.110: ICMP echo request,
30:54:00:00:00:03 > 00:11:22:00:ff:01, ethertype IPv4 (0x0800), length 98: 172.20.0.110 > 172.20.0.100: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1431"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1436: cat ch1_genev.tcpdump"
at_fn_check_prepare_trace "multinode.at:1436"
( $at_check_trace; cat ch1_genev.tcpdump
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1436"
$at_failed && at_fn_log_failure
$at_traceon; }


rm -f *.tcpdump
rm -f *.stderr

# Now clear the logical_port of dnat_and_snat entry.  ovn-gw-1 should handle the DNAT.
check multinode_nbctl lr-nat-del lr0 dnat_and_snat 172.20.0.110
check multinode_nbctl --wait=hv lr-nat-add lr0 dnat_and_snat 172.20.0.110 10.0.0.3
# Ping from sw1-p1 to 172.20.0.110
# Traffic path is
# sw1-p1 in ovn-chassis-2 -> tunnel -> ovn-gw-1 -> In ovn-gw-1 SNAT 20.0.0.3 to 172.20.0.100 ->
#  DNAT 172.20.0.110 -> 10.0.0.3 -> tunnel -> ovn-chassis-1 -> br-int -> sw0p1


     podman exec ovn-chassis-2 tcpdump -l -c 2 -neei genev_sys_6081 icmp >ch2_genev.tcpdump 2>ch2_genev.stderr &
     echo "podman exec ovn-chassis-2 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-2 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch2_genev.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1451" "until grep -q \"listening\" ch2_genev.stderr"




     podman exec ovn-chassis-2 tcpdump -l -c 2 -neei eth2 icmp >ch2_eth2.tcpdump 2>ch2_eth2.stderr &
     echo "podman exec ovn-chassis-2 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-2 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch2_eth2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1452" "until grep -q \"listening\" ch2_eth2.stderr"




     podman exec ovn-gw-1 tcpdump -l -c 4 -neei genev_sys_6081 icmp >gw1_geneve.tcpdump 2>gw1_geneve.stderr &
     echo "podman exec ovn-gw-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-gw-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" gw1_geneve.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1453" "until grep -q \"listening\" gw1_geneve.stderr"




     podman exec ovn-gw-1 tcpdump -l -c 4 -neei eth2 icmp >gw1_eth2.tcpdump 2>gw1_eth2.stderr &
     echo "podman exec ovn-gw-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-gw-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" gw1_eth2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1454" "until grep -q \"listening\" gw1_eth2.stderr"




     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei genev_sys_6081 icmp >ch1_genev.tcpdump 2>ch1_genev.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_genev.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1455" "until grep -q \"listening\" ch1_genev.stderr"




     podman exec ovn-chassis-1 tcpdump -l -c 2 -neei eth2 icmp >ch1_eth2.tcpdump 2>ch1_eth2.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_eth2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1456" "until grep -q \"listening\" ch1_eth2.stderr"




 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1458: podman exec ovn-chassis-2 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.110 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1458"
( $at_check_trace; podman exec ovn-chassis-2 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 172.20.0.110 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1458"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-chassis-1 killall tcpdump
m_as ovn-chassis-2 killall tcpdump
m_as ovn-gw-1 killall tcpdump

{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1467: cat ch2_genev.tcpdump | cut -d  ' ' -f2-15"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1467"
( $at_check_trace; cat ch2_genev.tcpdump | cut -d  ' ' -f2-15
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "00:11:22:00:ff:01 > 00:11:22:00:ff:01, ethertype IPv4 (0x0800), length 98: 20.0.0.3 > 172.20.0.110: ICMP echo request,
00:00:00:00:ff:02 > 40:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 172.20.0.110 > 20.0.0.3: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1467"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1472: cat ch1_eth2.tcpdump"
at_fn_check_prepare_trace "multinode.at:1472"
( $at_check_trace; cat ch1_eth2.tcpdump
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1472"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1476: cat gw1_geneve.tcpdump | cut -d  ' ' -f2-15"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1476"
( $at_check_trace; cat gw1_geneve.tcpdump | cut -d  ' ' -f2-15
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "00:11:22:00:ff:01 > 00:11:22:00:ff:01, ethertype IPv4 (0x0800), length 98: 20.0.0.3 > 172.20.0.110: ICMP echo request,
00:00:00:00:ff:01 > 50:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 172.20.0.100 > 10.0.0.3: ICMP echo request,
00:11:22:00:ff:01 > 00:11:22:00:ff:01, ethertype IPv4 (0x0800), length 98: 10.0.0.3 > 172.20.0.100: ICMP echo reply,
00:00:00:00:ff:02 > 40:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 172.20.0.110 > 20.0.0.3: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1476"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1483: cat gw1_eth2.tcpdump"
at_fn_check_prepare_trace "multinode.at:1483"
( $at_check_trace; cat gw1_eth2.tcpdump
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1483"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1487: cat ch1_genev.tcpdump | cut -d  ' ' -f2-15"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1487"
( $at_check_trace; cat ch1_genev.tcpdump | cut -d  ' ' -f2-15
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "00:00:00:00:ff:01 > 50:54:00:00:00:03, ethertype IPv4 (0x0800), length 98: 172.20.0.100 > 10.0.0.3: ICMP echo request,
00:11:22:00:ff:01 > 00:11:22:00:ff:01, ethertype IPv4 (0x0800), length 98: 10.0.0.3 > 172.20.0.100: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1487"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1492: cat ch1_eth2.tcpdump"
at_fn_check_prepare_trace "multinode.at:1492"
( $at_check_trace; cat ch1_eth2.tcpdump
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1492"
$at_failed && at_fn_log_failure
$at_traceon; }


ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_12
#AT_START_13
at_fn_group_banner 13 'multinode.at:1498' \
  "ovn multinode load-balancer with multiple DGPs and multiple chassis" "" 1
at_xfail=no
(
  printf "%s\n" "13. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running.
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

# Reset geneve tunnels
for c in ovn-chassis-1 ovn-chassis-2 ovn-chassis-3 ovn-chassis-4 ovn-gw-1 ovn-gw-2
do
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=geneve
done

# Network topology
#
#             publicp1 (ovn-chassis-3) (20.0.1.3/24)
#                |
#              overlay
#                |
#      DGP public1 (ovn-gw-1) (20.0.1.1/24)
#                |
#                |
#                |
#               lr0 ------- sw0 --- sw0p1 (ovn-chassis-1) 10.0.1.3/24
#                |           |
#                |           + ---  sw0p2 (ovn-chassis-2) 10.0.1.4/24
#                |
#      DGP public2 (ovn-gw-2) (30.0.1.1/24)
#                |
#              overlay
#                |
#             publicp2 (ovn-chassis-4) (30.0.1.3/24)

# Delete already used ovs-ports
m_as ovn-chassis-1 ip link del sw0p1-p
m_as ovn-chassis-2 ip link del sw0p2-p
m_as ovn-chassis-2 ip link del sw1p1-p
m_as ovn-chassis-3 ip link del publicp1-p
m_as ovn-chassis-4 ip link del publicp2-p

# Create East-West switch for LB backends
check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.1.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.1.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.1.3 24 10.0.1.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.1.4 24 10.0.1.1 1000::4/64 1000::a

m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1551: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.1.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1551"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.1.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1551"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1556: podman exec ovn-chassis-2 ip netns exec sw0p2 ping -q -c 3 -i 0.3 -w 2 10.0.1.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1556"
( $at_check_trace; podman exec ovn-chassis-2 ip netns exec sw0p2 ping -q -c 3 -i 0.3 -w 2 10.0.1.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1556"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create a logical router and attach to sw0
check multinode_nbctl lr-add lr0
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.1.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

# create external connection for N/S traffic using multiple DGPs
check multinode_nbctl ls-add public

# create external connection for N/S traffic
# DGP public1
check multinode_nbctl lsp-add public ln-public-1
check multinode_nbctl lsp-set-type ln-public-1 localnet
check multinode_nbctl lsp-set-addresses ln-public-1 unknown
check multinode_nbctl lsp-set-options ln-public-1 network_name=public1

# DGP public2
check multinode_nbctl lsp-add public ln-public-2
check multinode_nbctl lsp-set-type ln-public-2 localnet
check multinode_nbctl lsp-set-addresses ln-public-2 unknown
check multinode_nbctl lsp-set-options ln-public-2 network_name=public2

# Attach DGP public1 to GW-1 and chassis-3 (overlay connectivity)
m_as ovn-gw-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public1:br-ex
m_as ovn-chassis-3 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public1:br-ex

# Attach DGP public2 to GW-2 and chassis-4 (overlay connectivity)
m_as ovn-gw-2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public2:br-ex
m_as ovn-chassis-4 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public2:br-ex

# Create the external LR0 port to the DGP public1
check multinode_nbctl lsp-add public public-port1
check multinode_nbctl lsp-set-addresses public-port1 "40:54:00:00:00:03 20.0.1.3 2000::3"

check multinode_nbctl lrp-add lr0 lr0-public-p1 00:00:00:00:ff:02 20.0.1.1/24 2000::a/64
check multinode_nbctl lsp-add public public-lr0-p1
check multinode_nbctl lsp-set-type public-lr0-p1 router
check multinode_nbctl lsp-set-addresses public-lr0-p1 router
check multinode_nbctl lsp-set-options public-lr0-p1 router-port=lr0-public-p1
check multinode_nbctl lrp-set-gateway-chassis lr0-public-p1 ovn-gw-1 10

# Create a VM on ovn-chassis-3 in the same public1 overlay
m_as ovn-chassis-3 /data/create_fake_vm.sh public-port1 publicp1 40:54:00:00:00:03 1342 20.0.1.3 24 20.0.1.1 2000::4/64 2000::a

m_wait_for_ports_up public-port1

# Create the external LR0 port to the DGP public2
check multinode_nbctl lsp-add public public-port2
check multinode_nbctl lsp-set-addresses public-port2 "60:54:00:00:00:03 30.0.1.3 3000::3"

check multinode_nbctl lrp-add lr0 lr0-public-p2 00:00:00:00:ff:03 30.0.1.1/24 3000::a/64
check multinode_nbctl lsp-add public public-lr0-p2
check multinode_nbctl lsp-set-type public-lr0-p2 router
check multinode_nbctl lsp-set-addresses public-lr0-p2 router
check multinode_nbctl lsp-set-options public-lr0-p2 router-port=lr0-public-p2
check multinode_nbctl lrp-set-gateway-chassis lr0-public-p2 ovn-gw-2 10

# Create a VM on ovn-chassis-4 in the same public2 overlay
m_as ovn-chassis-4 /data/create_fake_vm.sh public-port2 publicp2 60:54:00:00:00:03 1342 30.0.1.3 24 30.0.1.1 3000::4/64 3000::a

m_wait_for_ports_up public-port2

# Add SNAT rules using gateway-port
check multinode_nbctl --gateway-port lr0-public-p1 lr-nat-add lr0 snat 20.0.1.1 10.0.1.0/24
check multinode_nbctl --gateway-port lr0-public-p2 lr-nat-add lr0 snat 30.0.1.1 10.0.1.0/24

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1629: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.1.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1629"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.1.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1629"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1634: podman exec ovn-chassis-2 ip netns exec sw0p2 ping -q -c 3 -i 0.3 -w 2 30.0.1.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1634"
( $at_check_trace; podman exec ovn-chassis-2 ip netns exec sw0p2 ping -q -c 3 -i 0.3 -w 2 30.0.1.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:1634"
$at_failed && at_fn_log_failure
$at_traceon; }



# create LB
check multinode_nbctl lb-add lb0 "172.16.0.100:80" "10.0.1.3:80,10.0.1.4:80"
check multinode_nbctl lr-lb-add lr0 lb0
check multinode_nbctl ls-lb-add sw0 lb0

# Set use_stateless_nat to true
check multinode_nbctl set load_balancer lb0 options:use_stateless_nat=true
check multinode_nbctl set load_balancer lb0 selection_fields="ip_src,tp_src"

# Start backend http services
podman exec ovn-chassis-1 ip netns exec sw0p1 python3 -m http.server --bind 10.0.1.3 80 >/dev/null 2>&1 & echo $! > http1.pid
     echo "kill \`cat http1.pid\` 2>/dev/null" >> cleanup


podman exec ovn-chassis-2 ip netns exec sw0p2 python3 -m http.server --bind 10.0.1.4 80 >/dev/null 2>&1 & echo $! > http2.pid
     echo "kill \`cat http2.pid\` 2>/dev/null" >> cleanup



# wait for http server be ready
check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip netns exec sw0p1 ss -tulpn | grep LISTEN | grep 10.0.1.3:80
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1653" "until m_as ovn-chassis-1 ip netns exec sw0p1 ss -tulpn | grep LISTEN | grep 10.0.1.3:80"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip netns exec sw0p2 ss -tulpn | grep LISTEN | grep 10.0.1.4:80
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:1654" "until m_as ovn-chassis-2 ip netns exec sw0p2 ss -tulpn | grep LISTEN | grep 10.0.1.4:80"


# Flush conntrack entries for easier output parsing of next test.
m_as ovn-gw-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-2 ovs-appctl dpctl/flush-conntrack

podman exec ovn-chassis-3 ip netns exec publicp1 sh -c 'curl -v 172.16.0.100:80 --retry 0 --connect-timeout 1 --max-time 1 --local-port 59002 2> curl.out'
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1661: podman exec ovn-chassis-3 ip netns exec publicp1 sh -c 'cat -v curl.out' | sed 's/\\(.*\\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\\n/' | sed 's/\\(.*\\)200 OK/200 OK\\n/' | grep -i -e connected -e \"200 OK\" | uniq "
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1661"
( $at_check_trace; podman exec ovn-chassis-3 ip netns exec publicp1 sh -c 'cat -v curl.out' | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1661"
$at_failed && at_fn_log_failure
$at_traceon; }



podman exec ovn-chassis-4 ip netns exec publicp2 sh -c 'curl -v 172.16.0.100:80 --retry 0 --connect-timeout 1 --max-time 1 --local-port 59003 2> curl.out'
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:1667: podman exec ovn-chassis-4 ip netns exec publicp2 sh -c 'cat -v curl.out' | sed 's/\\(.*\\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\\n/' | sed 's/\\(.*\\)200 OK/200 OK\\n/' | grep -i -e connected -e \"200 OK\" | uniq "
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1667"
( $at_check_trace; podman exec ovn-chassis-4 ip netns exec publicp2 sh -c 'cat -v curl.out' | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1667"
$at_failed && at_fn_log_failure
$at_traceon; }



m_as ovn-gw-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-2 ovs-appctl dpctl/flush-conntrack

podman exec ovn-chassis-3 ip netns exec publicp1 sh -c 'curl -v 172.16.0.100:80 --retry 0 --connect-timeout 1 --max-time 1 --local-port 59001'
cat >wait-expected-stdout <<'_ATEOF'
tcp,orig=(src=20.0.1.3,dst=<cleared>,sport=59001,dport=80),reply=(src=<cleared>,dst=20.0.1.3,sport=80,dport=59001),zone=<cleared>,mark=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=20.0.1.3,dst=<cleared>,sport=59001,dport=80),reply=(src=<cleared>,dst=20.0.1.3,sport=80,dport=59001),zone=<cleared>,protoinfo=(state=<cleared>)
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-gw-1 ovs-appctl dpctl/dump-conntrack | grep -F "dst=20.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1676" "for output from m_as ovn-gw-1 ovs-appctl dpctl/dump-conntrack | grep -F "dst=20.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort"



podman exec ovn-chassis-4 ip netns exec publicp2 sh -c 'curl -v 172.16.0.100:80 --retry 0 --connect-timeout 1 --max-time 1 --local-port 59000'
cat >wait-expected-stdout <<'_ATEOF'
tcp,orig=(src=30.0.1.3,dst=<cleared>,sport=59000,dport=80),reply=(src=<cleared>,dst=30.0.1.3,sport=80,dport=59000),zone=<cleared>,mark=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=30.0.1.3,dst=<cleared>,sport=59000,dport=80),reply=(src=<cleared>,dst=30.0.1.3,sport=80,dport=59000),zone=<cleared>,protoinfo=(state=<cleared>)
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-gw-2 ovs-appctl dpctl/dump-conntrack | grep -F "dst=30.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1683" "for output from m_as ovn-gw-2 ovs-appctl dpctl/dump-conntrack | grep -F "dst=30.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort"



# create a big file on web servers for download
podman exec ovn-chassis-1 ip netns exec sw0p1 dd bs=512 count=200000 if=/dev/urandom of=download_file
podman exec ovn-chassis-2 ip netns exec sw0p2 dd bs=512 count=200000 if=/dev/urandom of=download_file

# Flush conntrack entries for easier output parsing of next test.
m_as ovn-chassis-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-chassis-2 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-2 ovs-appctl dpctl/flush-conntrack

podman exec ovn-chassis-3 ip netns exec publicp1 sh -c 'curl -v -O 172.16.0.100:80/download_file --retry 0 --connect-timeout 1 --max-time 1 --local-port 59004 2>curl.out'

gw1_ct=$(m_as ovn-gw-1 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw2_ct=$(m_as ovn-gw-2 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
chassis1_ct=$(m_as ovn-chassis-1 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
chassis2_ct=$(m_as ovn-chassis-2 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
chassis1_flow=$(m_as ovn-chassis-1 ovs-dpctl dump-flows | sed ':a;N;$!ba;s/\n/\\n/g')
chassis2_flow=$(m_as ovn-chassis-2 ovs-dpctl dump-flows | sed ':a;N;$!ba;s/\n/\\n/g')

cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 ip netns exec publicp1 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1708" "for output from m_as ovn-chassis-3 ip netns exec publicp1 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



# Check if we have only one backend for the same connection - orig + dest ports
cat >wait-expected-stdout <<'_ATEOF'
tcp,orig=(src=20.0.1.3,dst=<cleared>,sport=59004,dport=80),reply=(src=<cleared>,dst=20.0.1.3,sport=80,dport=59004),zone=<cleared>,mark=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=20.0.1.3,dst=<cleared>,sport=59004,dport=80),reply=(src=<cleared>,dst=20.0.1.3,sport=80,dport=59004),zone=<cleared>,protoinfo=(state=<cleared>)
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    echo -e $gw1_ct | grep -F "dst=20.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1714" "for output from echo -e \$gw1_ct | grep -F "dst=20.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort"



# Check if gw-2 is empty to ensure that the traffic only come from/to the originator chassis via DGP public1
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1721: echo -e \$gw2_ct | grep \"20.0.1.3\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1721"
( $at_check_trace; echo -e $gw2_ct | grep "20.0.1.3" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1721"
$at_failed && at_fn_log_failure
$at_traceon; }


# Check the backend IP from ct entries on gw-1 (DGP public1)
backend_check=$(echo -e $chassis1_ct | grep "10.0.1.3,sport=59004,dport=80" -c)

if [ $backend_check -gt 0 ]; then
# Backend resides on ovn-chassis-1
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1730: echo -e \$chassis1_ct | grep -F \"dst=20.0.1.3,\" | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp"
at_fn_check_prepare_notrace 'an embedded newline' "multinode.at:1730"
( $at_check_trace; echo -e $chassis1_ct | grep -F "dst=20.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "tcp,orig=(src=20.0.1.3,dst=10.0.1.3,sport=59004,dport=80),reply=(src=10.0.1.3,dst=20.0.1.3,sport=80,dport=59004),zone=<cleared>,protoinfo=(state=<cleared>)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1730"
$at_failed && at_fn_log_failure
$at_traceon; }


# Ensure that the traffic only come from ovn-chassis-1
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1736: echo -e \$chassis2_ct | grep \"20.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1736"
( $at_check_trace; echo -e $chassis2_ct | grep "20.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1736"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1739: echo -e \$chassis2_flow | grep \"20.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1739"
( $at_check_trace; echo -e $chassis2_flow | grep "20.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1739"
$at_failed && at_fn_log_failure
$at_traceon; }

else
# Backend resides on ovn-chassis-2
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1744: echo -e \$chassis2_ct | grep -F \"dst=20.0.1.3,\" | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp"
at_fn_check_prepare_notrace 'an embedded newline' "multinode.at:1744"
( $at_check_trace; echo -e $chassis2_ct | grep -F "dst=20.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "tcp,orig=(src=20.0.1.3,dst=10.0.1.4,sport=59004,dport=80),reply=(src=10.0.1.4,dst=20.0.1.3,sport=80,dport=59004),zone=<cleared>,protoinfo=(state=<cleared>)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1744"
$at_failed && at_fn_log_failure
$at_traceon; }


# Ensure that the traffic only come from ovn-chassis-2
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1750: echo -e \$chassis1_ct | grep \"20.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1750"
( $at_check_trace; echo -e $chassis1_ct | grep "20.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1750"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1753: echo -e \$chassis1_flow | grep \"20.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1753"
( $at_check_trace; echo -e $chassis1_flow | grep "20.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1753"
$at_failed && at_fn_log_failure
$at_traceon; }

fi

# Flush conntrack entries for easier output parsing of next test.
m_as ovn-chassis-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-chassis-2 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-2 ovs-appctl dpctl/flush-conntrack

# Check the flows again for a new source port
podman exec ovn-chassis-3 ip netns exec publicp1 sh -c 'curl -v -O 172.16.0.100:80/download_file --retry 0 --connect-timeout 1 --max-time 1 --local-port 59005 2>curl.out'

gw1_ct=$(m_as ovn-gw-1 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw2_ct=$(m_as ovn-gw-2 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
chassis1_ct=$(m_as ovn-chassis-1 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
chassis2_ct=$(m_as ovn-chassis-2 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
chassis1_flow=$(m_as ovn-chassis-1 ovs-dpctl dump-flows | sed ':a;N;$!ba;s/\n/\\n/g')
chassis2_flow=$(m_as ovn-chassis-2 ovs-dpctl dump-flows | sed ':a;N;$!ba;s/\n/\\n/g')

cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 ip netns exec publicp1 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1774" "for output from m_as ovn-chassis-3 ip netns exec publicp1 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



# Check if we have only one backend for the same connection - orig + dest ports
cat >wait-expected-stdout <<'_ATEOF'
tcp,orig=(src=20.0.1.3,dst=<cleared>,sport=59005,dport=80),reply=(src=<cleared>,dst=20.0.1.3,sport=80,dport=59005),zone=<cleared>,mark=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=20.0.1.3,dst=<cleared>,sport=59005,dport=80),reply=(src=<cleared>,dst=20.0.1.3,sport=80,dport=59005),zone=<cleared>,protoinfo=(state=<cleared>)
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    echo -e $gw1_ct | grep -F "dst=20.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1780" "for output from echo -e \$gw1_ct | grep -F "dst=20.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort"



# Check if gw-2 is empty to ensure that the traffic only come from/to the originator chassis via DGP public1
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1787: echo -e \$gw2_ct | grep \"20.0.1.3\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1787"
( $at_check_trace; echo -e $gw2_ct | grep "20.0.1.3" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1787"
$at_failed && at_fn_log_failure
$at_traceon; }


# Check the backend IP from ct entries on gw-1 (DGP public1)
backend_check=$(echo -e $chassis1_ct | grep "10.0.1.3,sport=59005,dport=80" -c)

if [ $backend_check -gt 0 ]; then
# Backend resides on ovn-chassis-1
# Ensure that the traffic only come from ovn-chassis-1
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1797: echo -e \$chassis2_ct | grep \"20.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1797"
( $at_check_trace; echo -e $chassis2_ct | grep "20.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1797"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1800: echo -e \$chassis2_flow | grep \"20.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1800"
( $at_check_trace; echo -e $chassis2_flow | grep "20.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1800"
$at_failed && at_fn_log_failure
$at_traceon; }

else
# Backend resides on ovn-chassis-2
# Ensure that the traffic only come from ovn-chassis-2
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1806: echo -e \$chassis1_ct | grep \"20.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1806"
( $at_check_trace; echo -e $chassis1_ct | grep "20.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1806"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1809: echo -e \$chassis1_flow | grep \"20.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1809"
( $at_check_trace; echo -e $chassis1_flow | grep "20.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1809"
$at_failed && at_fn_log_failure
$at_traceon; }

fi

# Flush conntrack entries for easier output parsing of next test.
m_as ovn-chassis-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-chassis-2 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-2 ovs-appctl dpctl/flush-conntrack

# Start a new test using the second DGP as origin (public2)
podman exec ovn-chassis-4 ip netns exec publicp2 sh -c 'curl -v -O 172.16.0.100:80/download_file --retry 0 --connect-timeout 1 --max-time 1 --local-port 59006 2>curl.out'

gw1_ct=$(m_as ovn-gw-1 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw2_ct=$(m_as ovn-gw-2 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
chassis1_ct=$(m_as ovn-chassis-1 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
chassis2_ct=$(m_as ovn-chassis-2 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
chassis1_flow=$(m_as ovn-chassis-1 ovs-dpctl dump-flows | sed ':a;N;$!ba;s/\n/\\n/g')
chassis2_flow=$(m_as ovn-chassis-2 ovs-dpctl dump-flows | sed ':a;N;$!ba;s/\n/\\n/g')

cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-4 ip netns exec publicp2 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1830" "for output from m_as ovn-chassis-4 ip netns exec publicp2 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



# Check if we have only one backend for the same connection - orig + dest ports
cat >wait-expected-stdout <<'_ATEOF'
tcp,orig=(src=30.0.1.3,dst=<cleared>,sport=59006,dport=80),reply=(src=<cleared>,dst=30.0.1.3,sport=80,dport=59006),zone=<cleared>,mark=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=30.0.1.3,dst=<cleared>,sport=59006,dport=80),reply=(src=<cleared>,dst=30.0.1.3,sport=80,dport=59006),zone=<cleared>,protoinfo=(state=<cleared>)
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    echo -e $gw2_ct | grep -F "dst=30.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1836" "for output from echo -e \$gw2_ct | grep -F "dst=30.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort"



# Check if gw-1 is empty to ensure that the traffic only come from/to the originator chassis via DGP public2
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1843: echo -e \$gw1_ct | grep \"30.0.1.3\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1843"
( $at_check_trace; echo -e $gw1_ct | grep "30.0.1.3" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1843"
$at_failed && at_fn_log_failure
$at_traceon; }


# Check the backend IP from ct entries on gw-2 (DGP public2)
backend_check=$(echo -e $chassis1_ct | grep "10.0.1.3,sport=59006,dport=80" -c)

if [ $backend_check -gt 0 ]; then
# Backend resides on ovn-chassis-1
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1852: echo -e \$chassis1_ct | grep -F \"dst=30.0.1.3,\" | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp"
at_fn_check_prepare_notrace 'an embedded newline' "multinode.at:1852"
( $at_check_trace; echo -e $chassis1_ct | grep -F "dst=30.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "tcp,orig=(src=30.0.1.3,dst=10.0.1.3,sport=59006,dport=80),reply=(src=10.0.1.3,dst=30.0.1.3,sport=80,dport=59006),zone=<cleared>,protoinfo=(state=<cleared>)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1852"
$at_failed && at_fn_log_failure
$at_traceon; }


# Ensure that the traffic only come from ovn-chassis-1
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1858: echo -e \$chassis2_ct | grep \"30.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1858"
( $at_check_trace; echo -e $chassis2_ct | grep "30.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1858"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1861: echo -e \$chassis2_flow | grep \"30.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1861"
( $at_check_trace; echo -e $chassis2_flow | grep "30.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1861"
$at_failed && at_fn_log_failure
$at_traceon; }

else
# Backend resides on ovn-chassis-2
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1866: echo -e \$chassis2_ct | grep -F \"dst=30.0.1.3,\" | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp"
at_fn_check_prepare_notrace 'an embedded newline' "multinode.at:1866"
( $at_check_trace; echo -e $chassis2_ct | grep -F "dst=30.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "tcp,orig=(src=30.0.1.3,dst=10.0.1.4,sport=59006,dport=80),reply=(src=10.0.1.4,dst=30.0.1.3,sport=80,dport=59006),zone=<cleared>,protoinfo=(state=<cleared>)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1866"
$at_failed && at_fn_log_failure
$at_traceon; }


# Ensure that the traffic only come from ovn-chassis-2
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1872: echo -e \$chassis1_ct | grep \"30.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1872"
( $at_check_trace; echo -e $chassis1_ct | grep "30.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1872"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1875: echo -e \$chassis1_flow | grep \"30.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1875"
( $at_check_trace; echo -e $chassis1_flow | grep "30.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1875"
$at_failed && at_fn_log_failure
$at_traceon; }

fi

# Flush conntrack entries for easier output parsing of next test.
m_as ovn-chassis-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-chassis-2 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-2 ovs-appctl dpctl/flush-conntrack

# Check the flows again for a new source port using the second DGP as origin (public2)
podman exec ovn-chassis-4 ip netns exec publicp2 sh -c 'curl -v -O 172.16.0.100:80/download_file --retry 0 --connect-timeout 1 --max-time 1 --local-port 59007 2>curl.out'

gw1_ct=$(m_as ovn-gw-1 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw2_ct=$(m_as ovn-gw-2 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
chassis1_ct=$(m_as ovn-chassis-1 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
chassis2_ct=$(m_as ovn-chassis-2 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
chassis1_flow=$(m_as ovn-chassis-1 ovs-dpctl dump-flows | sed ':a;N;$!ba;s/\n/\\n/g')
chassis2_flow=$(m_as ovn-chassis-2 ovs-dpctl dump-flows | sed ':a;N;$!ba;s/\n/\\n/g')

cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-4 ip netns exec publicp2 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1896" "for output from m_as ovn-chassis-4 ip netns exec publicp2 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



# Check if we have only one backend for the same connection - orig + dest ports
cat >wait-expected-stdout <<'_ATEOF'
tcp,orig=(src=30.0.1.3,dst=<cleared>,sport=59007,dport=80),reply=(src=<cleared>,dst=30.0.1.3,sport=80,dport=59007),zone=<cleared>,mark=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=30.0.1.3,dst=<cleared>,sport=59007,dport=80),reply=(src=<cleared>,dst=30.0.1.3,sport=80,dport=59007),zone=<cleared>,protoinfo=(state=<cleared>)
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    echo -e $gw2_ct | grep -F "dst=30.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1902" "for output from echo -e \$gw2_ct | grep -F "dst=30.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort"



# Check if gw-1 is empty to ensure that the traffic only come from/to the originator chassis via DGP public2
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1909: echo -e \$gw1_ct | grep \"30.0.1.3\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1909"
( $at_check_trace; echo -e $gw1_ct | grep "30.0.1.3" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1909"
$at_failed && at_fn_log_failure
$at_traceon; }


# Check the backend IP from ct entries on gw-1 (DGP public1)
backend_check=$(echo -e $chassis1_ct | grep "10.0.1.3,sport=59007,dport=80" -c)

if [ $backend_check -gt 0 ]; then
# Backend resides on ovn-chassis-1
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1918: echo -e \$chassis1_ct | grep -F \"dst=30.0.1.3,\" | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp"
at_fn_check_prepare_notrace 'an embedded newline' "multinode.at:1918"
( $at_check_trace; echo -e $chassis1_ct | grep -F "dst=30.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "tcp,orig=(src=30.0.1.3,dst=10.0.1.3,sport=59007,dport=80),reply=(src=10.0.1.3,dst=30.0.1.3,sport=80,dport=59007),zone=<cleared>,protoinfo=(state=<cleared>)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1918"
$at_failed && at_fn_log_failure
$at_traceon; }


# Ensure that the traffic only come from ovn-chassis-1
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1924: echo -e \$chassis2_ct | grep \"30.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1924"
( $at_check_trace; echo -e $chassis2_ct | grep "30.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1924"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1927: echo -e \$chassis2_flow | grep \"30.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1927"
( $at_check_trace; echo -e $chassis2_flow | grep "30.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1927"
$at_failed && at_fn_log_failure
$at_traceon; }

else
# Backend resides on ovn-chassis-2
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1932: echo -e \$chassis2_ct | grep -F \"dst=30.0.1.3,\" | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp"
at_fn_check_prepare_notrace 'an embedded newline' "multinode.at:1932"
( $at_check_trace; echo -e $chassis2_ct | grep -F "dst=30.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "tcp,orig=(src=30.0.1.3,dst=10.0.1.4,sport=59007,dport=80),reply=(src=10.0.1.4,dst=30.0.1.3,sport=80,dport=59007),zone=<cleared>,protoinfo=(state=<cleared>)
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:1932"
$at_failed && at_fn_log_failure
$at_traceon; }


# Ensure that the traffic only come from ovn-chassis-2
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1938: echo -e \$chassis1_ct | grep \"30.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1938"
( $at_check_trace; echo -e $chassis1_ct | grep "30.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1938"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
printf "%s\n" "$at_srcdir/multinode.at:1941: echo -e \$chassis1_flow | grep \"30.0.1.3\" | grep \"dport=80\" -c"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:1941"
( $at_check_trace; echo -e $chassis1_flow | grep "30.0.1.3" | grep "dport=80" -c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:1941"
$at_failed && at_fn_log_failure
$at_traceon; }

fi

# Check multiple requests coming from DGP's public1 and public2

podman exec ovn-chassis-4 ip netns exec publicp2 sh -c 'curl -v -O 172.16.0.100:80/download_file --retry 0 --connect-timeout 1 --max-time 1 2>curl.out'
cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-4 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1949" "for output from m_as ovn-chassis-4 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



podman exec ovn-chassis-3 ip netns exec publicp1 sh -c 'curl -v -O 172.16.0.100:80/download_file --retry 0 --connect-timeout 1 --max-time 1 2>curl.out'
cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1955" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



podman exec ovn-chassis-4 ip netns exec publicp2 sh -c 'curl -v -O 172.16.0.100:80/download_file --retry 0 --connect-timeout 1 --max-time 1 2>curl.out'
cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-4 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1961" "for output from m_as ovn-chassis-4 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



podman exec ovn-chassis-3 ip netns exec publicp1 sh -c 'curl -v -O 172.16.0.100:80/download_file --retry 0 --connect-timeout 1 --max-time 1 2>curl.out'
cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1967" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



# Remove the LB and change the VIP port - different from the backend ports
check multinode_nbctl lb-del lb0

# create LB again
check multinode_nbctl lb-add lb0 "172.16.0.100:9000" "10.0.1.3:80,10.0.1.4:80"
check multinode_nbctl lr-lb-add lr0 lb0
check multinode_nbctl ls-lb-add sw0 lb0

# Set use_stateless_nat to true
check multinode_nbctl set load_balancer lb0 options:use_stateless_nat=true
check multinode_nbctl set load_balancer lb0 selection_fields="ip_src,tp_src"

m_as ovn-gw-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-2 ovs-appctl dpctl/flush-conntrack

# Check end-to-end request using a new port for VIP
podman exec ovn-chassis-3 ip netns exec publicp1 sh -c 'curl -v -O 172.16.0.100:9000/download_file --retry 0 --connect-timeout 1 --max-time 1 --local-port 59008 2>curl.out'
cat >wait-expected-stdout <<'_ATEOF'
tcp,orig=(src=20.0.1.3,dst=<cleared>,sport=59008,dport=80),reply=(src=<cleared>,dst=20.0.1.3,sport=80,dport=59008),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=20.0.1.3,dst=<cleared>,sport=59008,dport=9000),reply=(src=<cleared>,dst=20.0.1.3,sport=80,dport=59008),zone=<cleared>,mark=<cleared>,protoinfo=(state=<cleared>)
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-gw-1 ovs-appctl dpctl/dump-conntrack | grep -F "dst=20.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1989" "for output from m_as ovn-gw-1 ovs-appctl dpctl/dump-conntrack | grep -F "dst=20.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort"



cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 9000
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 9000/Connected to 172.16.0.100 (172.16.0.100) port 9000\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:1995" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 9000/Connected to 172.16.0.100 (172.16.0.100) port 9000\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



m_as ovn-gw-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-2 ovs-appctl dpctl/flush-conntrack

# Check end-to-end request using a new port for VIP
podman exec ovn-chassis-4 ip netns exec publicp2 sh -c 'curl -v -O 172.16.0.100:9000/download_file --retry 0 --connect-timeout 1 --max-time 1 --local-port 59008 2>curl.out'
cat >wait-expected-stdout <<'_ATEOF'
tcp,orig=(src=30.0.1.3,dst=<cleared>,sport=59008,dport=80),reply=(src=<cleared>,dst=30.0.1.3,sport=80,dport=59008),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=30.0.1.3,dst=<cleared>,sport=59008,dport=9000),reply=(src=<cleared>,dst=30.0.1.3,sport=80,dport=59008),zone=<cleared>,mark=<cleared>,protoinfo=(state=<cleared>)
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-gw-2 ovs-appctl dpctl/dump-conntrack | grep -F "dst=30.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2005" "for output from m_as ovn-gw-2 ovs-appctl dpctl/dump-conntrack | grep -F "dst=30.0.1.3," | sed -e 's/id=[0-9]*/id=<cleared>/g' -e 's/state=[0-9_A-Z]*/state=<cleared>/g' | sort | uniq | sed -e 's/zone=[[0-9]]*/zone=<cleared>/' -e 's/mark=[[0-9]]*/mark=<cleared>/'  | \\
grep tcp | sed -E -e 's/10.0.1.3|10.0.1.4/<cleared>/g' | sort"



cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 9000
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 9000/Connected to 172.16.0.100 (172.16.0.100) port 9000\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2011" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 9000/Connected to 172.16.0.100 (172.16.0.100) port 9000\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_13
#AT_START_14
at_fn_group_banner 14 'multinode.at:2018' \
  "ovn multinode load-balancer with multiple DGPs and multiple chassis - ECMP environment" "" 1
at_xfail=no
(
  printf "%s\n" "14. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

# Reset geneve tunnels
for c in ovn-chassis-1 ovn-chassis-2 ovn-chassis-3 ovn-gw-1 ovn-gw-2 ovn-gw-3 ovn-gw-4
do
    m_as $c ovs-vsctl set open . external-ids:ovn-encap-type=geneve
done

# Network topology
#                                      VM ovn-chassis-3 (40.0.2.3/24)
#                                                   |
#                                                  sw1
#                                                   |
#                                                  lr1
#                                                   |
#                     +.............................|.............................+
#                     |                                                           |
#      DGP publicp3 (ovn-gw-3) (20.0.1.2/24)                     DGP publicp4 (ovn-gw-4) (20.0.2.4/24)
#                     |                                                           |
#                     +.............................+.............................+
#                     |                                                           |
#                     | (public_right)                               (public_left)|
#                     +.............................+.............................+
#                     |                                                           |
#      DGP public1 (ovn-gw-1) (20.0.1.1/24)                      DGP public2 (ovn-gw-2) (20.0.2.2/24)
#                     |                                                           |
#                     +.............................+.............................+
#                                                   |
#                                                  lr0 (lb0 VIP 172.16.0.100)
#                                                   |
#                                                  sw0
#                                                   |
#                     +.............................+.............................+
#                     |                                                           |
#      sw0p1 (ovn-chassis-1) 10.0.2.3/24                         sw0p2 (ovn-chassis-2) 10.0.2.4/24


# Delete already used ovs-ports
m_as ovn-chassis-1 ip link del sw0p1-p
m_as ovn-chassis-2 ip link del sw0p2-p
m_as ovn-chassis-2 ip link del sw1p1-p
m_as ovn-chassis-3 ip link del sw1p1-p

# Create East-West switch for LB backends
check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 sw0-port1
check multinode_nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.2.3 1000::3"
check multinode_nbctl lsp-add sw0 sw0-port2
check multinode_nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.2.4 1000::4"

m_as ovn-chassis-1 /data/create_fake_vm.sh sw0-port1 sw0p1 50:54:00:00:00:03 1342 10.0.2.3 24 10.0.2.1 1000::3/64 1000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh sw0-port2 sw0p2 50:54:00:00:00:04 1342 10.0.2.4 24 10.0.2.1 1000::4/64 1000::a

# Create sw1 for ovn-chassis-3 VM
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 sw1-port1
check multinode_nbctl lsp-set-addresses sw1-port1 "70:54:00:00:00:03 40.0.2.3 5000::3"

m_as ovn-chassis-3 /data/create_fake_vm.sh sw1-port1 sw1p1 70:54:00:00:00:03 1342 40.0.2.3 24 40.0.2.1 5000::3/64 5000::a

m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2086: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.2.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2086"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 10.0.2.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:2086"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2091: podman exec ovn-chassis-2 ip netns exec sw0p2 ping -q -c 3 -i 0.3 -w 2 10.0.2.3 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2091"
( $at_check_trace; podman exec ovn-chassis-2 ip netns exec sw0p2 ping -q -c 3 -i 0.3 -w 2 10.0.2.3 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:2091"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create a logical router and attach to sw0
check multinode_nbctl lr-add lr0
check multinode_nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.2.1/24 1000::a/64
check multinode_nbctl lsp-add sw0 sw0-lr0
check multinode_nbctl lsp-set-type sw0-lr0 router
check multinode_nbctl lsp-set-addresses sw0-lr0 router
check multinode_nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

# create external connection for N/S traffic using multiple DGPs
check multinode_nbctl ls-add public_right
check multinode_nbctl ls-add public_left

# create external connection for N/S traffic
# DGP public1
check multinode_nbctl lsp-add public_right ln-public-1
check multinode_nbctl lsp-set-type ln-public-1 localnet
check multinode_nbctl lsp-set-addresses ln-public-1 unknown
check multinode_nbctl lsp-set-options ln-public-1 network_name=public1

# DGP public2
check multinode_nbctl lsp-add public_left ln-public-2
check multinode_nbctl lsp-set-type ln-public-2 localnet
check multinode_nbctl lsp-set-addresses ln-public-2 unknown
check multinode_nbctl lsp-set-options ln-public-2 network_name=public2

# Attach DGP public1 to GW-1 public1 (overlay connectivity)
m_as ovn-gw-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public1:br-ex

# Attach DGP public2 to GW-2 public2 (overlay connectivity)
m_as ovn-gw-2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public2:br-ex

check multinode_nbctl lrp-add lr0 lr0-public-p1 40:54:00:00:00:01 20.0.1.1/24 2000::1/64
check multinode_nbctl lsp-add public_right public-lr0-p1
check multinode_nbctl lsp-set-type public-lr0-p1 router
check multinode_nbctl lsp-set-addresses public-lr0-p1 router
check multinode_nbctl lsp-set-options public-lr0-p1 router-port=lr0-public-p1
check multinode_nbctl lrp-set-gateway-chassis lr0-public-p1 ovn-gw-1 10

m_wait_for_ports_up

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2136: podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.1.1 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2136"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec sw0p1 ping -q -c 3 -i 0.3 -w 2 20.0.1.1 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:2136"
$at_failed && at_fn_log_failure
$at_traceon; }



check multinode_nbctl lrp-add lr0 lr0-public-p2 40:54:00:00:00:02 20.0.2.2/24 2000::2/64
check multinode_nbctl lsp-add public_left public-lr0-p2
check multinode_nbctl lsp-set-type public-lr0-p2 router
check multinode_nbctl lsp-set-addresses public-lr0-p2 router
check multinode_nbctl lsp-set-options public-lr0-p2 router-port=lr0-public-p2
check multinode_nbctl lrp-set-gateway-chassis lr0-public-p2 ovn-gw-2 10

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2148: podman exec ovn-chassis-2 ip netns exec sw0p2 ping -q -c 3 -i 0.3 -w 2 20.0.2.2 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2148"
( $at_check_trace; podman exec ovn-chassis-2 ip netns exec sw0p2 ping -q -c 3 -i 0.3 -w 2 20.0.2.2 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:2148"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create a logical router and attach to sw1
check multinode_nbctl lr-add lr1
check multinode_nbctl lrp-add lr1 lr1-sw1 00:00:00:00:ff:02 40.0.2.1/24 5000::a/64
check multinode_nbctl lsp-add sw1 sw1-lr1
check multinode_nbctl lsp-set-type sw1-lr1 router
check multinode_nbctl lsp-set-addresses sw1-lr1 router
check multinode_nbctl lsp-set-options sw1-lr1 router-port=lr1-sw1

# create external connection for N/S traffic
# DGP public3
check multinode_nbctl lsp-add public_right ln-public-3
check multinode_nbctl lsp-set-type ln-public-3 localnet
check multinode_nbctl lsp-set-addresses ln-public-3 unknown
check multinode_nbctl lsp-set-options ln-public-3 network_name=public3

# Attach DGP public3 to GW-3 public3 (overlay connectivity)
m_as ovn-gw-3 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public3:br-ex

check multinode_nbctl lrp-add lr1 lr1-public-p3 40:54:00:00:00:03 20.0.1.2/24 2000::3/64
check multinode_nbctl lsp-add public_right public-lr1-p3
check multinode_nbctl lsp-set-type public-lr1-p3 router
check multinode_nbctl lsp-set-addresses public-lr1-p3 router
check multinode_nbctl lsp-set-options public-lr1-p3 router-port=lr1-public-p3
check multinode_nbctl lrp-set-gateway-chassis lr1-public-p3 ovn-gw-3 10

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2178: podman exec ovn-chassis-3 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 40.0.2.1 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2178"
( $at_check_trace; podman exec ovn-chassis-3 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 40.0.2.1 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:2178"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2183: podman exec ovn-chassis-3 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 20.0.1.2 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2183"
( $at_check_trace; podman exec ovn-chassis-3 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 20.0.1.2 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:2183"
$at_failed && at_fn_log_failure
$at_traceon; }



# Add a default route for multiple DGPs using ECMP - first step
check multinode_nbctl --ecmp lr-route-add lr0 40.0.2.0/24 20.0.1.2
check multinode_nbctl --ecmp lr-route-add lr1 0.0.0.0/0 20.0.1.1

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2192: podman exec ovn-chassis-3 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 20.0.1.1 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2192"
( $at_check_trace; podman exec ovn-chassis-3 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 20.0.1.1 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:2192"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2197: podman exec ovn-chassis-3 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 20.0.2.2 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2197"
( $at_check_trace; podman exec ovn-chassis-3 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 20.0.2.2 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:2197"
$at_failed && at_fn_log_failure
$at_traceon; }



# Configure the second DGP for the lr1
# DGP public4
check multinode_nbctl lsp-add public_left ln-public-4
check multinode_nbctl lsp-set-type ln-public-4 localnet
check multinode_nbctl lsp-set-addresses ln-public-4 unknown
check multinode_nbctl lsp-set-options ln-public-4 network_name=public4

# Attach DGP public4 to GW-2 public4 (overlay connectivity)
m_as ovn-gw-4 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public4:br-ex

check multinode_nbctl lrp-add lr1 lr1-public-p4 40:54:00:00:00:04 20.0.2.4/24 2000::4/64
check multinode_nbctl lsp-add public_left public-lr1-p4
check multinode_nbctl lsp-set-type public-lr1-p4 router
check multinode_nbctl lsp-set-addresses public-lr1-p4 router
check multinode_nbctl lsp-set-options public-lr1-p4 router-port=lr1-public-p4
check multinode_nbctl lrp-set-gateway-chassis lr1-public-p4 ovn-gw-4 10

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2219: podman exec ovn-chassis-3 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 20.0.2.4 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2219"
( $at_check_trace; podman exec ovn-chassis-3 ip netns exec sw1p1 ping -q -c 3 -i 0.3 -w 2 20.0.2.4 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:2219"
$at_failed && at_fn_log_failure
$at_traceon; }



# Add a default route for multiple DGPs using ECMP - second step (multipath)
check multinode_nbctl --ecmp lr-route-add lr0 40.0.2.0/24 20.0.2.4
check multinode_nbctl --ecmp lr-route-add lr1 0.0.0.0/0 20.0.2.2

# Start backend http services
podman exec ovn-chassis-1 ip netns exec sw0p1 python3 -m http.server --bind 10.0.2.3 80 >/dev/null 2>&1 & echo $! > http1.pid
     echo "kill \`cat http1.pid\` 2>/dev/null" >> cleanup


podman exec ovn-chassis-2 ip netns exec sw0p2 python3 -m http.server --bind 10.0.2.4 80 >/dev/null 2>&1 & echo $! > http2.pid
     echo "kill \`cat http2.pid\` 2>/dev/null" >> cleanup



# wait for http server be ready
check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip netns exec sw0p1 ss -tulpn | grep LISTEN | grep 10.0.2.3:80
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2233" "until m_as ovn-chassis-1 ip netns exec sw0p1 ss -tulpn | grep LISTEN | grep 10.0.2.3:80"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip netns exec sw0p2 ss -tulpn | grep LISTEN | grep 10.0.2.4:80
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2234" "until m_as ovn-chassis-2 ip netns exec sw0p2 ss -tulpn | grep LISTEN | grep 10.0.2.4:80"


# create a big file on web servers for download
podman exec ovn-chassis-1 ip netns exec sw0p1 dd bs=512 count=200000 if=/dev/urandom of=download_file
podman exec ovn-chassis-2 ip netns exec sw0p2 dd bs=512 count=200000 if=/dev/urandom of=download_file

# create LB
check multinode_nbctl lb-add lb0 "172.16.0.100:80" "10.0.2.3:80,10.0.2.4:80"
check multinode_nbctl lr-lb-add lr0 lb0
check multinode_nbctl ls-lb-add sw0 lb0

check multinode_nbctl --wait=sb sync

# Flush conntrack entries for easier output parsing of next test.
m_as ovn-gw-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-2 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-3 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-4 ovs-appctl dpctl/flush-conntrack

# Check direct backend traffic using the same LB ports
podman exec ovn-chassis-3 ip netns exec sw1p1 sh -c 'curl -v -O 10.0.2.3:80/download_file --retry 0 --connect-timeout 1 --max-time 1 --local-port 59013 2>curl.out'

gw1_ct=$(m_as ovn-gw-1 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw2_ct=$(m_as ovn-gw-2 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw3_ct=$(m_as ovn-gw-3 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw4_ct=$(m_as ovn-gw-4 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')

# Check the backend IP from ct entries on gateways
backend_check_gw1=$(echo -e $gw1_ct | grep "dport=80" | grep "59013" -c)
backend_check_gw2=$(echo -e $gw2_ct | grep "dport=80" | grep "59013" -c)
backend_check_gw3=$(echo -e $gw3_ct | grep "dport=80" | grep "59013" -c)
backend_check_gw4=$(echo -e $gw4_ct | grep "dport=80" | grep "59013" -c)

chassis_in_use=$(($backend_check_gw1 + $backend_check_gw2 + $backend_check_gw3 + $backend_check_gw4))
# If the traffic passes through both gateways (GW-1 and GW-2 OR GW-3 and GW-4) it will be dropped because
# we are bypassing the Stateless NAT solution for LB when we access the backend directly
if [ $chassis_in_use -gt 2 ]; then
cat >wait-expected-stdout <<'_ATEOF'
timed out
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \
sed 's/\(.*\)timed out/timed out\n/' | sed 's/\(.*\)connect timeout/timed out\n/' | grep -i -e "timed out" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2271" "for output from m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \\
sed 's/\\(.*\\)timed out/timed out\\n/' | sed 's/\\(.*\\)connect timeout/timed out\\n/' | grep -i -e \"timed out\" | uniq"


else
cat >wait-expected-stdout <<'_ATEOF'
Connected to 10.0.2.3 (10.0.2.3) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 10.0.2.3 (10.0.2.3) port 80/Connected to 10.0.2.3 (10.0.2.3) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2276" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 10.0.2.3 (10.0.2.3) port 80/Connected to 10.0.2.3 (10.0.2.3) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "


fi

# Flush conntrack entries for easier output parsing of next test.
m_as ovn-gw-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-2 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-3 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-4 ovs-appctl dpctl/flush-conntrack

podman exec ovn-chassis-3 ip netns exec sw1p1 sh -c 'curl -v -O 10.0.2.4:80/download_file --retry 0 --connect-timeout 1 --max-time 1 --local-port 59014 2>curl.out'

gw1_ct=$(m_as ovn-gw-1 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw2_ct=$(m_as ovn-gw-2 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw3_ct=$(m_as ovn-gw-3 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw4_ct=$(m_as ovn-gw-4 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')

# Check the backend IP from ct entries on gateways
backend_check_gw1=$(echo -e $gw1_ct | grep "dport=80" | grep "59014" -c)
backend_check_gw2=$(echo -e $gw2_ct | grep "dport=80" | grep "59014" -c)
backend_check_gw3=$(echo -e $gw3_ct | grep "dport=80" | grep "59014" -c)
backend_check_gw4=$(echo -e $gw4_ct | grep "dport=80" | grep "59014" -c)

chassis_in_use=$(($backend_check_gw1 + $backend_check_gw2 + $backend_check_gw3 + $backend_check_gw4))

# If the traffic passes through both gateways (GW-1 and GW-2 OR GW-3 and GW-4) it will be dropped because
# we are bypassing the Stateless NAT solution for LB when we access the backend directly
if [ $chassis_in_use -gt 2 ]; then
cat >wait-expected-stdout <<'_ATEOF'
timed out
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \
sed 's/\(.*\)timed out/timed out\n/' | sed 's/\(.*\)connect timeout/timed out\n/' | grep -i -e "timed out" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2306" "for output from m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \\
sed 's/\\(.*\\)timed out/timed out\\n/' | sed 's/\\(.*\\)connect timeout/timed out\\n/' | grep -i -e \"timed out\" | uniq"


else
cat >wait-expected-stdout <<'_ATEOF'
Connected to 10.0.2.4 (10.0.2.4) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 10.0.2.4 (10.0.2.4) port 80/Connected to 10.0.2.4 (10.0.2.4) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2311" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 10.0.2.4 (10.0.2.4) port 80/Connected to 10.0.2.4 (10.0.2.4) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "


fi

# Check the flows again for the LB VIP
podman exec ovn-chassis-3 ip netns exec sw1p1 sh -c 'curl -v 172.16.0.100:80 --retry 0 --connect-timeout 1 --max-time 1 --local-port 59015 2>curl.out'

curl_timeout=$(m_as ovn-chassis-3 cat -v curl.out | grep -i -e "timed out" -e "timeout" -c)

# This may fail because we do not have the flows to work independently of the DGP (DNAT + SNAT for the LB Stateless NAT)
if [ $curl_timeout -gt 0 ]; then
cat >wait-expected-stdout <<'_ATEOF'
timed out
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \
sed 's/\(.*\)timed out/timed out\n/' | sed 's/\(.*\)connect timeout/timed out\n/' | grep -i -e "timed out" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2324" "for output from m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \\
sed 's/\\(.*\\)timed out/timed out\\n/' | sed 's/\\(.*\\)connect timeout/timed out\\n/' | grep -i -e \"timed out\" | uniq"


else
cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2329" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "


fi

# Check the flows again for the LB VIP
podman exec ovn-chassis-3 ip netns exec sw1p1 sh -c 'curl -v 172.16.0.100:80 --retry 0 --connect-timeout 1 --max-time 1 --local-port 59016 2>curl.out'

curl_timeout=$(m_as ovn-chassis-3 cat -v curl.out | grep -i -e "timed out" -e "timeout" -c)

# This may fail because we do not have the flows to work independently of the DGP (DNAT + SNAT for the LB Stateless NAT)
if [ $curl_timeout -gt 0 ]; then
cat >wait-expected-stdout <<'_ATEOF'
timed out
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \
sed 's/\(.*\)timed out/timed out\n/' | sed 's/\(.*\)connect timeout/timed out\n/' | grep -i -e "timed out" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2342" "for output from m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \\
sed 's/\\(.*\\)timed out/timed out\\n/' | sed 's/\\(.*\\)connect timeout/timed out\\n/' | grep -i -e \"timed out\" | uniq"


else
cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2347" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "


fi

# Set use_stateless_nat to true
# Now, if the traffic passes through both gateways (GW-1 and GW-2) it will be forwarded successfully
check multinode_nbctl set load_balancer lb0 options:use_stateless_nat=true
check multinode_nbctl set load_balancer lb0 selection_fields="ip_src,tp_src"

# Check the flows again for the LB VIP - always needs to be successful regardless of the datapath (one or two gw chassis)
podman exec ovn-chassis-3 ip netns exec sw1p1 sh -c 'curl -v -O 172.16.0.100:80/download_file --retry 0 --connect-timeout 1 --max-time 10 2>curl.out'
m_as ovn-chassis-3 cat -v curl.out
podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'ss -nn >connections.out'
podman exec ovn-chassis-2 ip netns exec sw0p2 sh -c 'ss -nn >connections.out'

cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2364" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



cat >wait-expected-stdout <<'_ATEOF'
0
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-1 cat connections.out | grep "FIN-WAIT-2" | wc -l
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2369" "for output from m_as ovn-chassis-1 cat connections.out | grep \"FIN-WAIT-2\" | wc -l"



cat >wait-expected-stdout <<'_ATEOF'
0
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-2 cat connections.out | grep  "FIN-WAIT-2" | wc -l
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2373" "for output from m_as ovn-chassis-2 cat connections.out | grep  \"FIN-WAIT-2\" | wc -l"



podman exec ovn-chassis-3 ip netns exec sw1p1 sh -c 'curl -v -O 172.16.0.100:80/download_file --retry 0 --connect-timeout 1 --max-time 10 2>curl.out'
m_as ovn-chassis-3 cat -v curl.out
podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'ss -nn >connections.out'
podman exec ovn-chassis-2 ip netns exec sw0p2 sh -c 'ss -nn >connections.out'

cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2382" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



cat >wait-expected-stdout <<'_ATEOF'
0
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-1 cat connections.out | grep "FIN-WAIT-2" | wc -l
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2387" "for output from m_as ovn-chassis-1 cat connections.out | grep \"FIN-WAIT-2\" | wc -l"



cat >wait-expected-stdout <<'_ATEOF'
0
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-2 cat connections.out | grep "FIN-WAIT-2" | wc -l
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2391" "for output from m_as ovn-chassis-2 cat connections.out | grep \"FIN-WAIT-2\" | wc -l"



podman exec ovn-chassis-3 ip netns exec sw1p1 sh -c 'curl -v -O 172.16.0.100:80/download_file --retry 0 --connect-timeout 1 --max-time 10 2>curl.out'
m_as ovn-chassis-3 cat -v curl.out
podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'ss -nn >connections.out'
podman exec ovn-chassis-2 ip netns exec sw0p2 sh -c 'ss -nn >connections.out'

cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2400" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



cat >wait-expected-stdout <<'_ATEOF'
0
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-1 cat connections.out | grep "FIN-WAIT-2" | wc -l
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2405" "for output from m_as ovn-chassis-1 cat connections.out | grep \"FIN-WAIT-2\" | wc -l"



cat >wait-expected-stdout <<'_ATEOF'
0
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-2 cat connections.out | grep "FIN-WAIT-2" | wc -l
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2409" "for output from m_as ovn-chassis-2 cat connections.out | grep \"FIN-WAIT-2\" | wc -l"



podman exec ovn-chassis-3 ip netns exec sw1p1 sh -c 'curl -v -O 172.16.0.100:80/download_file --retry 0 --connect-timeout 1 --max-time 10 2>curl.out'
m_as ovn-chassis-3 cat -v curl.out
podman exec ovn-chassis-1 ip netns exec sw0p1 sh -c 'ss -nn >connections.out'
podman exec ovn-chassis-2 ip netns exec sw0p2 sh -c 'ss -nn >connections.out'

cat >wait-expected-stdout <<'_ATEOF'
Connected to 172.16.0.100 (172.16.0.100) port 80
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2418" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 172.16.0.100 (172.16.0.100) port 80/Connected to 172.16.0.100 (172.16.0.100) port 80\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "



cat >wait-expected-stdout <<'_ATEOF'
0
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-1 cat connections.out | grep "FIN-WAIT-2" | wc -l
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2423" "for output from m_as ovn-chassis-1 cat connections.out | grep \"FIN-WAIT-2\" | wc -l"



cat >wait-expected-stdout <<'_ATEOF'
0
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-2 cat connections.out | grep "FIN-WAIT-2" | wc -l
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2427" "for output from m_as ovn-chassis-2 cat connections.out | grep \"FIN-WAIT-2\" | wc -l"



# Direct backend traffic using the same LB ports needs to be dropped
podman exec ovn-chassis-3 ip netns exec sw1p1 sh -c 'curl -v -O 10.0.2.3:80/download_file --retry 0 --connect-timeout 1 --max-time 1 2>curl.out'

cat >wait-expected-stdout <<'_ATEOF'
timed out
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \
sed 's/\(.*\)timed out/timed out\n/' | sed 's/\(.*\)connect timeout/timed out\n/' | grep -i -e "timed out" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2434" "for output from m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \\
sed 's/\\(.*\\)timed out/timed out\\n/' | sed 's/\\(.*\\)connect timeout/timed out\\n/' | grep -i -e \"timed out\" | uniq"



# check again using another source ports
podman exec ovn-chassis-3 ip netns exec sw1p1 sh -c 'curl -v -O 10.0.2.3:80/download_file --retry 0 --connect-timeout 1 --max-time 1 2>curl.out'

cat >wait-expected-stdout <<'_ATEOF'
timed out
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \
sed 's/\(.*\)timed out/timed out\n/' | sed 's/\(.*\)connect timeout/timed out\n/' | grep -i -e "timed out" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2442" "for output from m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \\
sed 's/\\(.*\\)timed out/timed out\\n/' | sed 's/\\(.*\\)connect timeout/timed out\\n/' | grep -i -e \"timed out\" | uniq"



# Start backend http services using different ports from the LB config - check connectivity
podman exec ovn-chassis-1 ip netns exec sw0p1 python3 -m http.server --bind 10.0.2.3 8080 >/dev/null 2>&1 & echo $! > http3.pid
     echo "kill \`cat http3.pid\` 2>/dev/null" >> cleanup


podman exec ovn-chassis-2 ip netns exec sw0p2 python3 -m http.server --bind 10.0.2.4 8080 >/dev/null 2>&1 & echo $! > http4.pid
     echo "kill \`cat http4.pid\` 2>/dev/null" >> cleanup



# wait for http server be ready
check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip netns exec sw0p1 ss -tulpn | grep LISTEN | grep 10.0.2.3:8080
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2452" "until m_as ovn-chassis-1 ip netns exec sw0p1 ss -tulpn | grep LISTEN | grep 10.0.2.3:8080"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip netns exec sw0p2 ss -tulpn | grep LISTEN | grep 10.0.2.4:8080
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2453" "until m_as ovn-chassis-2 ip netns exec sw0p2 ss -tulpn | grep LISTEN | grep 10.0.2.4:8080"


# Flush conntrack entries for easier output parsing of next test.
m_as ovn-gw-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-2 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-3 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-4 ovs-appctl dpctl/flush-conntrack

podman exec ovn-chassis-3 ip netns exec sw1p1 sh -c 'curl -v -O 10.0.2.4:8080/download_file --retry 0 --connect-timeout 1 --max-time 5 --local-port 59017 2>curl.out'

gw1_ct=$(m_as ovn-gw-1 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw2_ct=$(m_as ovn-gw-2 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw3_ct=$(m_as ovn-gw-3 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw4_ct=$(m_as ovn-gw-4 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')

# Check the backend IP from ct entries on gateways
backend_check_gw1=$(echo -e $gw1_ct | grep "dport=8080" | grep "59017" -c)
backend_check_gw2=$(echo -e $gw2_ct | grep "dport=8080" | grep "59017" -c)
backend_check_gw3=$(echo -e $gw3_ct | grep "dport=8080" | grep "59017" -c)
backend_check_gw4=$(echo -e $gw4_ct | grep "dport=8080" | grep "59017" -c)

chassis_in_use=$(($backend_check_gw1 + $backend_check_gw2 + $backend_check_gw3 + $backend_check_gw4))

# If the traffic passes through both gateways (GW-1 and GW-2 OR GW-3 and GW-4) it will be dropped because
# we are bypassing the Stateless NAT solution for LB when we access the backend directly
if [ $chassis_in_use -gt 2 ]; then
cat >wait-expected-stdout <<'_ATEOF'
timed out
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \
sed 's/\(.*\)timed out/timed out\n/' | sed 's/\(.*\)connect timeout/timed out\n/' | grep -i -e "timed out" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2479" "for output from m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \\
sed 's/\\(.*\\)timed out/timed out\\n/' | sed 's/\\(.*\\)connect timeout/timed out\\n/' | grep -i -e \"timed out\" | uniq"


else
cat >wait-expected-stdout <<'_ATEOF'
Connected to 10.0.2.4 (10.0.2.4) port 8080
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 10.0.2.4 (10.0.2.4) port 8080/Connected to 10.0.2.4 (10.0.2.4) port 8080\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2484" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 10.0.2.4 (10.0.2.4) port 8080/Connected to 10.0.2.4 (10.0.2.4) port 8080\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "


fi

# Flush conntrack entries for easier output parsing of next test.
m_as ovn-gw-1 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-2 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-3 ovs-appctl dpctl/flush-conntrack
m_as ovn-gw-4 ovs-appctl dpctl/flush-conntrack

# Check again
podman exec ovn-chassis-3 ip netns exec sw1p1 sh -c 'curl -v -O 10.0.2.4:8080/download_file --retry 0 --connect-timeout 1 --max-time 1 --local-port 59018 2>curl.out'

gw1_ct=$(m_as ovn-gw-1 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw2_ct=$(m_as ovn-gw-2 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw3_ct=$(m_as ovn-gw-3 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')
gw4_ct=$(m_as ovn-gw-4 ovs-appctl dpctl/dump-conntrack | sed ':a;N;$!ba;s/\n/\\n/g')

# Check the backend IP from ct entries on gateways
backend_check_gw1=$(echo -e $gw1_ct | grep "dport=8080" | grep "59018" -c)
backend_check_gw2=$(echo -e $gw2_ct | grep "dport=8080" | grep "59018" -c)
backend_check_gw3=$(echo -e $gw3_ct | grep "dport=8080" | grep "59018" -c)
backend_check_gw4=$(echo -e $gw4_ct | grep "dport=8080" | grep "59018" -c)

chassis_in_use=$(($backend_check_gw1 + $backend_check_gw2 + $backend_check_gw3 + $backend_check_gw4))

# If the traffic passes through both gateways (GW-1 and GW-2 OR GW-3 and GW-4) it will be dropped because
# we are bypassing the Stateless NAT solution for LB when we access the backend directly
if [ $chassis_in_use -gt 2 ]; then
cat >wait-expected-stdout <<'_ATEOF'
timed out
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \
sed 's/\(.*\)timed out/timed out\n/' | sed 's/\(.*\)connect timeout/timed out\n/' | grep -i -e "timed out" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2515" "for output from m_as ovn-chassis-3 ip netns exec sw1p1 cat -v curl.out | \\
sed 's/\\(.*\\)timed out/timed out\\n/' | sed 's/\\(.*\\)connect timeout/timed out\\n/' | grep -i -e \"timed out\" | uniq"


else
cat >wait-expected-stdout <<'_ATEOF'
Connected to 10.0.2.4 (10.0.2.4) port 8080
200 OK
_ATEOF

: >wait-expected-stderr
wait_expected_status=0
ovs_wait_command() {
    m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 10.0.2.4 (10.0.2.4) port 8080/Connected to 10.0.2.4 (10.0.2.4) port 8080\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq
}
ovs_wait_cond() {
    ovs_wait_command >wait-stdout 2>wait-stderr
    wait_status=$?
    (test $wait_status = $wait_expected_status &&
     $at_diff wait-expected-stdout wait-stdout &&
     $at_diff wait-expected-stderr wait-stderr) >/dev/null 2>&1
}
ovs_wait_failed () {
    if test $wait_status != $wait_expected_status; then
        echo "exit status $wait_status != expected $wait_expected_status"
    fi
    $at_diff wait-expected-stdout wait-stdout
    $at_diff wait-expected-stderr wait-stderr
}
ovs_wait "multinode.at:2520" "for output from m_as ovn-chassis-3 cat -v curl.out | sed 's/\(.*\)Connected to 10.0.2.4 (10.0.2.4) port 8080/Connected to 10.0.2.4 (10.0.2.4) port 8080\n/' | sed 's/\(.*\)200 OK/200 OK\n/' | grep -i -e connected -e "200 OK" | uniq "


fi

ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_14
#AT_START_15
at_fn_group_banner 15 'multinode.at:2528' \
  "ovn multinode - Transit Router basic functionality" "" 1
at_xfail=no
(
  printf "%s\n" "15. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

# Network topology
#         
#                                                                          
#           AZ1         AZ2      
#             external                                                 
#                                                                      
#         192.168.100.10/24                       .................    
#            1000::10/64                                               
#                                
#                                                                        
#                                                                        
#                                
#         192.168.100.1/24                        192.168.100.2/24     
#            1000::1/64                              1000::2/64        
#                                                                      
#                GW                                      GW            
#                                                                      
#           100.65.0.1/30                           100.65.0.5/30      
#           100:65::1/126                           100:65::5/126      
#                                
#                                                                        
#                    Peer ports                               Peer ports 
#                                                                        
#           
#           100.65.0.2/30                             100.65.0.6/30      
#           100:65::2/126                             100:65::6/126      
#                                                                        
#                                      TR                                
#                                                                        
#          10.100.200.1/24                           10.100.200.1/24     
#           10:200::1/64                              10:200::1/64       
#           
#                                                                        
#                                                                        
#                                                                        
#           
#                                      TS                                
#           
#                                                                        
#                                                                        
#                                                                        
#                                
#               pod10                                   pod20          
#                                                                      
#          10.100.200.10/24                        10.100.200.20/24    
#           10:200::10/64                           10:200::20/64      
#                                
#         

for i in 1 2; do
    chassis="ovn-chassis-$i"
    ip=$(m_as $chassis ip -4 addr show eth1 | grep inet | awk '{print $2}' | cut -d'/' -f1)

    multinode_setup_northd $chassis
    multinode_setup_controller $chassis $chassis $ip $ip

    check m_as $chassis ovs-vsctl set open . external_ids:ovn-monitor-all=true
    check m_as $chassis ovs-vsctl set open . external_ids:ovn-is-interconn=true

    check m_as $chassis ovn-nbctl ls-add public

    check m_as $chassis ovn-nbctl lsp-add public public-gw
    check m_as $chassis ovn-nbctl lsp-set-type public-gw router
    check m_as $chassis ovn-nbctl lsp-set-addresses public-gw router
    check m_as $chassis ovn-nbctl lsp-set-options public-gw router-port=gw-public

    check m_as $chassis ovn-nbctl lr-add gw
    check m_as $chassis ovn-nbctl lrp-add gw gw-public 00:00:00:00:20:00 192.168.100.$i/24 1000::$i/64

    check m_as $chassis ovn-nbctl set logical_router gw options:chassis=$chassis

    # Add TR and set the same tunnel key for both chassis
    check m_as $chassis ovn-nbctl ls-add ts
    check m_as $chassis ovn-nbctl set logical_switch ts other_config:requested-tnl-key=10

    check m_as $chassis ovn-nbctl lsp-add ts ts-tr
    check m_as $chassis ovn-nbctl lsp-set-type ts-tr router
    check m_as $chassis ovn-nbctl lsp-set-addresses ts-tr router
    check m_as $chassis ovn-nbctl lsp-set-options ts-tr router-port=tr-ts

    check m_as $chassis ovn-nbctl lr-add tr
    check m_as $chassis ovn-nbctl lrp-add tr tr-ts 00:00:00:00:10:00 10.100.200.1/24 10:200::1/64
    check m_as $chassis ovn-nbctl set logical_router tr options:requested-tnl-key=20
    check m_as $chassis ovn-nbctl lrp-set-gateway-chassis tr-ts $chassis

    # Add TS pods, with the same tunnel keys on both sides
    check m_as $chassis ovn-nbctl lsp-add ts pod10
    check m_as $chassis ovn-nbctl lsp-set-addresses pod10 "00:00:00:00:10:10 10.100.200.10 10:200::10"
    check m_as $chassis ovn-nbctl set logical_switch_port pod10 options:requested-tnl-key=10

    check m_as $chassis ovn-nbctl lsp-add ts pod20
    check m_as $chassis ovn-nbctl lsp-set-addresses pod20 "00:00:00:00:10:20 10.100.200.20 10:200::20"
    check m_as $chassis ovn-nbctl set logical_switch_port pod20 options:requested-tnl-key=20

    # Add mgmt pod
    check m_as $chassis ovn-nbctl lsp-add ts mgmt
    check m_as $chassis ovn-nbctl lsp-set-addresses mgmt "00:00:00:00:10:11 10.100.200.11 10:200::11"
    check m_as $chassis ovn-nbctl set logical_switch_port mgmt options:requested-tnl-key=11
done

# Add SNAT for the GW router that corresponds to "gw-tr" LRP IP
check m_as ovn-chassis-1 ovn-nbctl lr-nat-add gw snat 100.65.0.1 192.168.100.0/24
check m_as ovn-chassis-1 ovn-nbctl lr-nat-add gw snat 100:65::1 1000::/64
check m_as ovn-chassis-2 ovn-nbctl lr-nat-add gw snat 100.65.0.5 192.168.100.0/24
check m_as ovn-chassis-2 ovn-nbctl lr-nat-add gw snat 100:65::5 1000::/64

# Add peer ports between GW and TR
check m_as ovn-chassis-1 ovn-nbctl lrp-add gw gw-tr 00:00:00:00:30:01 100.65.0.1/30 100:65::1/126 peer=tr-gw
check m_as ovn-chassis-1 ovn-nbctl lrp-add tr tr-gw 00:00:00:00:30:02 100.65.0.2/30 100:65::2/126 peer=gw-tr

check m_as ovn-chassis-2 ovn-nbctl lrp-add gw gw-tr 00:00:00:00:30:05 100.65.0.5/30 100:65::5/126 peer=tr-gw
check m_as ovn-chassis-2 ovn-nbctl lrp-add tr tr-gw 00:00:00:00:30:06 100.65.0.6/30 100:65::6/126 peer=gw-tr

# Add routes for the TS subnet
check m_as ovn-chassis-1 ovn-nbctl lr-route-add gw 10.100.200.0/24 100.65.0.2
check m_as ovn-chassis-1 ovn-nbctl lr-route-add gw 10:200::/64 100:65::2
check m_as ovn-chassis-2 ovn-nbctl lr-route-add gw 10.100.200.0/24 100.65.0.6
check m_as ovn-chassis-2 ovn-nbctl lr-route-add gw 10:200::/64 100:65::6

# Add LB on TS and condition NAT
check m_as ovn-chassis-1 ovn-nbctl lb-add lb0 172.16.0.5:5656 10.100.200.10:2324 tcp
check m_as ovn-chassis-1 ovn-nbctl ls-lb-add ts lb0
check m_as ovn-chassis-1 ovn-nbctl --match="eth.dst == 00:00:00:00:10:11" lr-nat-add tr snat 172.16.0.2 10.100.200.0/24
check m_as ovn-chassis-1 ovn-nbctl set logical_router tr options:ct-commit-all="true"

# Add mutual remote ports
check m_as ovn-chassis-1 ovn-nbctl lrp-add tr tr-az2 00:00:00:00:30:06 100.65.0.6/30 100:65::6/126
check m_as ovn-chassis-1 ovn-nbctl set logical_router_port tr-az2 options:requested-chassis=ovn-chassis-2

check m_as ovn-chassis-2 ovn-nbctl lrp-add tr tr-az1 00:00:00:00:30:02 100.65.0.2/30 100:65::2/126
check m_as ovn-chassis-2 ovn-nbctl set logical_router_port tr-az1 options:requested-chassis=ovn-chassis-1

# Important set the proper tunnel keys
check m_as ovn-chassis-1 ovn-nbctl set logical_router_port tr-gw options:requested-tnl-key=10
check m_as ovn-chassis-1 ovn-nbctl set logical_router_port tr-az2 options:requested-tnl-key=20

check m_as ovn-chassis-2 ovn-nbctl set logical_router_port tr-gw options:requested-tnl-key=20
check m_as ovn-chassis-2 ovn-nbctl set logical_router_port tr-az1 options:requested-tnl-key=10

check m_as ovn-chassis-1 ovn-nbctl lsp-add public external
check m_as ovn-chassis-1 ovn-nbctl lsp-set-addresses external "00:00:00:00:20:10 192.168.100.10 1000::10"

# Add mutual chassis
check m_as ovn-chassis-1 ovn-sbctl chassis-add ovn-chassis-2 geneve $(m_as ovn-chassis-2 ip -4 addr show eth1 | grep inet | awk '{print $2}' | cut -d'/' -f1)
check m_as ovn-chassis-1 ovn-sbctl set chassis ovn-chassis-2 other_config:is-remote=true

check m_as ovn-chassis-2 ovn-sbctl chassis-add ovn-chassis-1 geneve $(m_as ovn-chassis-1 ip -4 addr show eth1 | grep inet | awk '{print $2}' | cut -d'/' -f1)
check m_as ovn-chassis-2 ovn-sbctl set chassis ovn-chassis-1 other_config:is-remote=true

# Configure ports on the transit switch as remotes
check m_as ovn-chassis-1 ovn-nbctl lsp-set-type pod20 remote
check m_as ovn-chassis-1 ovn-nbctl lsp-set-options pod10 requested-chassis=ovn-chassis-1
check m_as ovn-chassis-1 ovn-nbctl lsp-set-options mgmt requested-chassis=ovn-chassis-1
check m_as ovn-chassis-1 ovn-nbctl lsp-set-options pod20 requested-chassis=ovn-chassis-2

check m_as ovn-chassis-2 ovn-nbctl lsp-set-type pod10 remote
check m_as ovn-chassis-2 ovn-nbctl lsp-set-type mgmt remote
check m_as ovn-chassis-2 ovn-nbctl lsp-set-options pod10 requested-chassis=ovn-chassis-1
check m_as ovn-chassis-2 ovn-nbctl lsp-set-options mgmt requested-chassis=ovn-chassis-1
check m_as ovn-chassis-2 ovn-nbctl lsp-set-options pod20 requested-chassis=ovn-chassis-2

m_as ovn-chassis-1 /data/create_fake_vm.sh external external 00:00:00:00:20:10 1500 192.168.100.10 24 192.168.100.1 1000::10/64 1000::1
m_as ovn-chassis-1 /data/create_fake_vm.sh pod10 pod10 00:00:00:00:10:10 1500 10.100.200.10 24 10.100.200.1 10:200::10/64 10:200::1
m_as ovn-chassis-1 /data/create_fake_vm.sh mgmt mgmt 00:00:00:00:10:11 1500 10.100.200.11 24 10.100.200.1 10:200::11/64 10:200::1
m_as ovn-chassis-2 /data/create_fake_vm.sh pod20 pod20 00:00:00:00:10:20 1500 10.100.200.20 24 10.100.200.1 10:200::20/64 10:200::1

# We cannot use any of the helpers as they assume that there is only single ovn-northd instance running
check m_as ovn-chassis-1 ovn-nbctl --wait=hv sync
check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    test -n "$(m_as ovn-chassis-1 ovn-sbctl --bare --columns _uuid find Port_Binding logical_port=external up=true)"
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2704" "until test -n \"\$(m_as ovn-chassis-1 ovn-sbctl --bare --columns _uuid find Port_Binding logical_port=external up=true)\""

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    test -n "$(m_as ovn-chassis-1 ovn-sbctl --bare --columns _uuid find Port_Binding logical_port=pod10 up=true)"
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2705" "until test -n \"\$(m_as ovn-chassis-1 ovn-sbctl --bare --columns _uuid find Port_Binding logical_port=pod10 up=true)\""

check m_as ovn-chassis-2 ovn-nbctl --wait=hv sync
check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    test -n "$(m_as ovn-chassis-2 ovn-sbctl --bare --columns _uuid find Port_Binding logical_port=pod20 up=true)"
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2707" "until test -n \"\$(m_as ovn-chassis-2 ovn-sbctl --bare --columns _uuid find Port_Binding logical_port=pod20 up=true)\""


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2709: podman exec ovn-chassis-1 ip netns exec external ping -q -c 5 -i 0.3 -w 2 10.100.200.20 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2709"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec external ping -q -c 5 -i 0.3 -w 2 10.100.200.20 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "5 packets transmitted, 5 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:2709"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2714: podman exec ovn-chassis-1 ip netns exec external ping -q -c 5 -i 0.3 -w 2 10:200::20 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2714"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec external ping -q -c 5 -i 0.3 -w 2 10:200::20 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "5 packets transmitted, 5 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:2714"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2719: podman exec ovn-chassis-1 ip netns exec mgmt ip a a 172.16.100.2/24 dev mgmt"
at_fn_check_prepare_trace "multinode.at:2719"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec mgmt ip a a 172.16.100.2/24 dev mgmt
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2719"
$at_failed && at_fn_log_failure
$at_traceon; }


podman exec ovn-chassis-1 ip netns exec pod10 nc -e /bin/cat -v -l -o server.log 10.100.200.10 2324 & echo $! > pod10.pid
     echo "kill \`cat pod10.pid\` 2>/dev/null" >> cleanup



     podman exec ovn-chassis-1 tcpdump -l -neei pod10-p ip >pod10.tcpdump 2>pod10.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" pod10.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2721" "until grep -q \"listening\" pod10.stderr"




     podman exec ovn-chassis-1 tcpdump -l -neei mgmt-p ip >mgmt.tcpdump 2>mgmt.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" mgmt.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2722" "until grep -q \"listening\" mgmt.stderr"




m_as ovn-chassis-1 sh -c 'echo -e "Hello\nHello" > msg.expected'
check m_as ovn-chassis-1 ovn-nbctl --policy="src-ip" lr-route-add tr 10.100.200.0/24 10.100.200.11

check test $(m_as ovn-chassis-1 grep -c "skipping output to input port" \
    /var/log/openvswitch/ovs-vswitchd.log) -eq 0
check test $(m_as ovn-chassis-2 grep -c "skipping output to input port" \
    /var/log/openvswitch/ovs-vswitchd.log) -eq 0

 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2732: podman exec ovn-chassis-1 ip netns exec mgmt sh -c '(echo \"Hello\"; sleep 3) | nc -s 172.16.100.2 -o client.log 172.16.0.5 5656'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2732"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec mgmt sh -c '(echo "Hello"; sleep 3) | nc -s 172.16.100.2 -o client.log 172.16.0.5 5656'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2732"
$at_failed && at_fn_log_failure
$at_traceon; }


check m_as ovn-chassis-1 cmp server.log msg.expected
check m_as ovn-chassis-1 cmp client.log msg.expected

echo "Chassis1"
m_as ovn-chassis-1 ovn-sbctl show
m_as ovn-chassis-1 ovn-nbctl show
m_as ovn-chassis-1 ovs-vsctl show

echo "Chassis2"
m_as ovn-chassis-2 ovn-sbctl show
m_as ovn-chassis-2 ovn-nbctl show
m_as ovn-chassis-2 ovs-vsctl show

# Connect the chassis back to the original northd and remove northd per chassis.
for i in 1 2; do
    chassis="ovn-chassis-$i"
    ip=$(m_as $chassis ip -4 addr show eth1 | grep inet | awk '{print $2}' | cut -d'/' -f1)

    multinode_setup_controller $chassis $chassis $ip "170.168.0.2"
    multinode_cleanup_northd $chassis
done

m_as ovn-chassis-1 killall tcpdump

ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_15
#AT_START_16
at_fn_group_banner 16 'multinode.at:2759' \
  "Migration of container ports" "                   " 1
at_xfail=no
(
  printf "%s\n" "16. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init

# Migrate vif port between chassis-1 and chassis-3; send packets between
# chassis-2 and chassis-1/chassis-3, and check that
# - packet handing on src works before migration.
# - packet handing on src & dst works during migration.
# - packet handing on dst works after migration.
# Do the same for container ports.
# The container port migration is tested in two different orders,
# setting iface-id on dst resp. before and after requested-chassis.

# Check that ovn-fake-multinode setup is up and running
check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

m_as ovn-chassis-1 ip link del migrator-p
m_as ovn-chassis-2 ip link del sw0-port1-p
m_as ovn-chassis-2 ip link del sw0-port2-p
m_as ovn-chassis-2 ip link del sw0-port3-p
m_as ovn-chassis-3 ip link del migrator-p

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2781" "until m_as ovn-chassis-1 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2782" "until m_as ovn-chassis-2 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-3 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2783" "until m_as ovn-chassis-3 ip link show | grep -q genev_sys"


# check_ping(src_port, src_chassis, dst_port, expected_status)
# Check whether ping, from src_port on src_chassis to dst_port works as expected.
# expected_status:
#   - "success" (or empty): ping should succeed between src and dst.
#   - "potential-duplicates": ping should succeed, but we might have potential duplicate packets.
#   - "lost": ping should fail, no packets should go through.
# Source ip namespace is derived from previous parameters:
#   - parent_port name for container ports.
#   - same name as port itself for other ports.
# Dest ip is retrieved from dst_port.
check_ping() {
    src_port=$1
    src_chassis=$2
    dst_port=$3
    status=${4:-success}

    parent_port=$(multinode_sbctl get port_binding $src_port parent_port)
    if [ "$parent_port" != "[]" ]; then
        src_ns=$parent_port
    else
        src_ns=$src_port
    fi
    dst_chassis_uuid=$(multinode_sbctl get port_binding $dst_port chassis)
    requested_chassis_uuid=$(multinode_sbctl get port_binding $dst_port requested_chassis)
    dst_chassis=$(multinode_sbctl --bare --columns name list chassis $dst_chassis_uuid)
    dst_ip=$(multinode_nbctl lsp-get-addresses $dst_port | awk '{print $2}')
    echo "$src_port on $src_chassis => $dst_port on $dst_chassis(requested_chassis=$requested_chassis_uuid)"
     { set +x
printf "%s\n" "$at_srcdir/multinode.at:2812: podman exec \$src_chassis ip netns exec \$src_ns ping -q -c 3 -i 0.1 -w 2 \$dst_ip | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2812"
( $at_check_trace; podman exec $src_chassis ip netns exec $src_ns ping -q -c 3 -i 0.1 -w 2 $dst_ip | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo stdout:; tee stdout <"$at_stdout"
at_fn_check_status \
0 $at_status "$at_srcdir/multinode.at:2812"
$at_failed && at_fn_log_failure
$at_traceon; }


    if [ "$status" == "success" ]; then
        { set +x
printf "%s\n" "$at_srcdir/multinode.at:2815: cat stdout | grep -c \"3 packets transmitted, 3 received, 0% packet loss\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2815"
( $at_check_trace; cat stdout | grep -c "3 packets transmitted, 3 received, 0% packet loss"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2815"
$at_failed && at_fn_log_failure
$at_traceon; }

    elif [ "$status" == "potential-duplicates" ]; then
        { set +x
printf "%s\n" "$at_srcdir/multinode.at:2819: cat stdout | grep \"3 packets transmitted\" | grep -c \"3 received\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2819"
( $at_check_trace; cat stdout | grep "3 packets transmitted" | grep -c "3 received"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2819"
$at_failed && at_fn_log_failure
$at_traceon; }

    elif [ "$status" == "lost" ]; then
        { set +x
printf "%s\n" "$at_srcdir/multinode.at:2823: cat stdout | grep -c \"100% packet loss\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:2823"
( $at_check_trace; cat stdout | grep -c "100% packet loss"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2823"
$at_failed && at_fn_log_failure
$at_traceon; }

    else
        echo "unexpected status $status"
        printf "%s\n" "multinode.at:2828" >"$at_check_line_file"
at_fn_check_skip 99 "$at_srcdir/multinode.at:2828"
    fi
}

check multinode_nbctl ls-add sw0
check multinode_nbctl lsp-add sw0 migrator
check multinode_nbctl lsp-set-addresses migrator "50:54:00:00:00:09 10.0.0.9 1000::9"
for i in 1 2 3; do
    check multinode_nbctl lsp-add sw0 sw0-port${i}
    check multinode_nbctl lsp-set-addresses sw0-port${i} "50:54:00:00:00:0${i} 10.0.0.${i} 1000::${i}"
done

# Set requested chassis before creating migrator on chassis-3
check multinode_nbctl --wait=hv set Logical_Switch_Port migrator options:requested-chassis=ovn-chassis-1

m_as ovn-chassis-1 /data/create_fake_vm.sh migrator migrator 50:54:00:00:00:09 1342 10.0.0.9 24 10.0.0.10 1000::9/64 1000::a
m_as ovn-chassis-3 /data/create_fake_vm.sh migrator migrator 50:54:00:00:00:09 1342 10.0.0.9 24 10.0.0.10 1000::9/64 1000::a
for i in 1 2 3; do
    m_as ovn-chassis-${i} /data/create_fake_vm.sh sw0-port${i} sw0-port${i} 50:54:00:00:00:0${i} 1342 10.0.0.${i} 24 10.0.0.10 1000::${i}/64 1000::a
done

m_wait_for_ports_up


     podman exec ovn-chassis-1 tcpdump -l -neei genev_sys_6081 arp or ip >ch1_genev.tcpdump 2>ch1_genev.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_genev.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2851" "until grep -q \"listening\" ch1_genev.stderr"




     podman exec ovn-chassis-1 tcpdump -l -neei migrator-p arp or ip >ch1_migrator.tcpdump 2>ch1_migrator.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1_migrator.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2852" "until grep -q \"listening\" ch1_migrator.stderr"




     podman exec ovn-chassis-2 tcpdump -l -neei genev_sys_6081 arp or ip >ch2_genev.tcpdump 2>ch2_genev.stderr &
     echo "podman exec ovn-chassis-2 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-2 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch2_genev.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2853" "until grep -q \"listening\" ch2_genev.stderr"



for i in 1 2 3; do

     podman exec ovn-chassis-${i} tcpdump -l -neei sw0-port${i}-p arp or ip >ch${i}_sw0-port${i}.tcpdump 2>ch${i}_sw0-port${i}.stderr &
     echo "podman exec ovn-chassis-${i} ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-${i} killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch${i}_sw0-port${i}.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2855" "until grep -q \"listening\" ch\${i}_sw0-port\${i}.stderr"



done

     podman exec ovn-chassis-3 tcpdump -l -neei genev_sys_6081 arp or ip >ch3_genev.tcpdump 2>ch3_genev.stderr &
     echo "podman exec ovn-chassis-3 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-3 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch3_genev.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2857" "until grep -q \"listening\" ch3_genev.stderr"




     podman exec ovn-chassis-3 tcpdump -l -neei migrator-p arp or ip >ch3_migrator.tcpdump 2>ch3_migrator.stderr &
     echo "podman exec ovn-chassis-3 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-3 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch3_migrator.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:2858" "until grep -q \"listening\" ch3_migrator.stderr"




printf "%s\n" "## ------------------- ##
## Migration with vifs ##
## ------------------- ##"
for i in 1 2 3; do
    check_ping migrator ovn-chassis-1 sw0-port${i}
    check_ping sw0-port${i} ovn-chassis-${i} migrator
done

echo "== Starting migration =="
check multinode_nbctl --wait=hv set Logical_Switch_Port migrator options:requested-chassis=ovn-chassis-1,ovn-chassis-3

for i in 1 2 3; do
    check_ping migrator ovn-chassis-1 sw0-port${i}
    check_ping migrator ovn-chassis-3 sw0-port${i}
    check_ping sw0-port${i} ovn-chassis-${i} migrator "potential-duplicates"
done

echo "== Finalizing migration =="
check multinode_nbctl --wait=hv set Logical_Switch_Port migrator options:requested-chassis=ovn-chassis-3

for i in 1 2 3; do
    check_ping migrator ovn-chassis-1 sw0-port${i} "lost"
    check_ping migrator ovn-chassis-3 sw0-port${i}
    check_ping sw0-port${i} ovn-chassis-${i} migrator
done

printf "%s\n" "## ------------------------------ ##
## Migration with container ports ##
## ------------------------------ ##"
# Create container ports.
check multinode_nbctl ls-add sw1
check multinode_nbctl lsp-add sw1 mig-cont migrator 10 \
                   -- lsp-set-addresses mig-cont "f0:00:00:01:02:09 20.0.0.9"
for i in 1 2 3; do
    check multinode_nbctl lsp-add sw1 cont${i} sw0-port${i} 10 \
                       -- lsp-set-addresses cont${i} "f0:00:00:01:02:0${i} 20.0.0.${i}"
done

# Create the interface for lport mig-cont
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2895: podman exec ovn-chassis-1 ip netns exec migrator ip link add link migrator name cont type vlan id 10"
at_fn_check_prepare_trace "multinode.at:2895"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec migrator ip link add link migrator name cont type vlan id 10
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2895"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2896: podman exec ovn-chassis-1 ip netns exec migrator ip link set cont address f0:00:00:01:02:09"
at_fn_check_prepare_trace "multinode.at:2896"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec migrator ip link set cont address f0:00:00:01:02:09
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2896"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2897: podman exec ovn-chassis-1 ip netns exec migrator ip link set cont up"
at_fn_check_prepare_trace "multinode.at:2897"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec migrator ip link set cont up
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2897"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2898: podman exec ovn-chassis-1 ip netns exec migrator ip addr add 20.0.0.9/24 dev cont"
at_fn_check_prepare_trace "multinode.at:2898"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec migrator ip addr add 20.0.0.9/24 dev cont
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2898"
$at_failed && at_fn_log_failure
$at_traceon; }



 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2900: podman exec ovn-chassis-3 ip netns exec migrator ip link add link migrator name cont type vlan id 10"
at_fn_check_prepare_trace "multinode.at:2900"
( $at_check_trace; podman exec ovn-chassis-3 ip netns exec migrator ip link add link migrator name cont type vlan id 10
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2900"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2901: podman exec ovn-chassis-3 ip netns exec migrator ip link set cont address f0:00:00:01:02:09"
at_fn_check_prepare_trace "multinode.at:2901"
( $at_check_trace; podman exec ovn-chassis-3 ip netns exec migrator ip link set cont address f0:00:00:01:02:09
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2901"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2902: podman exec ovn-chassis-3 ip netns exec migrator ip link set cont up"
at_fn_check_prepare_trace "multinode.at:2902"
( $at_check_trace; podman exec ovn-chassis-3 ip netns exec migrator ip link set cont up
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2902"
$at_failed && at_fn_log_failure
$at_traceon; }


 { set +x
printf "%s\n" "$at_srcdir/multinode.at:2903: podman exec ovn-chassis-3 ip netns exec migrator ip addr add 20.0.0.9/24 dev cont"
at_fn_check_prepare_trace "multinode.at:2903"
( $at_check_trace; podman exec ovn-chassis-3 ip netns exec migrator ip addr add 20.0.0.9/24 dev cont
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2903"
$at_failed && at_fn_log_failure
$at_traceon; }



# Create the cont interface for lport sw0-port1, sw0-port2, sw0-port3
for i in 1 2 3; do
     { set +x
printf "%s\n" "$at_srcdir/multinode.at:2907: podman exec ovn-chassis-\${i} ip netns exec sw0-port\${i} ip link add link sw0-port\${i} name cont\${i} type vlan id 10"
at_fn_check_prepare_notrace 'a ${...} parameter expansion' "multinode.at:2907"
( $at_check_trace; podman exec ovn-chassis-${i} ip netns exec sw0-port${i} ip link add link sw0-port${i} name cont${i} type vlan id 10
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2907"
$at_failed && at_fn_log_failure
$at_traceon; }


     { set +x
printf "%s\n" "$at_srcdir/multinode.at:2908: podman exec ovn-chassis-\${i} ip netns exec sw0-port\${i} ip link set cont\${i} address f0:00:00:01:02:0\${i}"
at_fn_check_prepare_notrace 'a ${...} parameter expansion' "multinode.at:2908"
( $at_check_trace; podman exec ovn-chassis-${i} ip netns exec sw0-port${i} ip link set cont${i} address f0:00:00:01:02:0${i}
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2908"
$at_failed && at_fn_log_failure
$at_traceon; }


     { set +x
printf "%s\n" "$at_srcdir/multinode.at:2909: podman exec ovn-chassis-\${i} ip netns exec sw0-port\${i} ip link set cont\${i} up"
at_fn_check_prepare_notrace 'a ${...} parameter expansion' "multinode.at:2909"
( $at_check_trace; podman exec ovn-chassis-${i} ip netns exec sw0-port${i} ip link set cont${i} up
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2909"
$at_failed && at_fn_log_failure
$at_traceon; }


     { set +x
printf "%s\n" "$at_srcdir/multinode.at:2910: podman exec ovn-chassis-\${i} ip netns exec sw0-port\${i} ip addr add 20.0.0.\${i}/24 dev cont\${i}"
at_fn_check_prepare_notrace 'a ${...} parameter expansion' "multinode.at:2910"
( $at_check_trace; podman exec ovn-chassis-${i} ip netns exec sw0-port${i} ip addr add 20.0.0.${i}/24 dev cont${i}
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:2910"
$at_failed && at_fn_log_failure
$at_traceon; }


done

for i in 1 2 3; do
    check_ping mig-cont ovn-chassis-3 cont${i}
    check_ping cont${i} ovn-chassis-${i} mig-cont
    check_ping migrator ovn-chassis-3 cont${i}
    check_ping cont${i} ovn-chassis-${i} migrator
done

echo "== Starting migration back =="
check multinode_nbctl --wait=hv set Logical_Switch_Port migrator options:requested-chassis=ovn-chassis-3,ovn-chassis-1

for i in 1 2 3; do
    check_ping mig-cont ovn-chassis-3 cont${i}
    check_ping mig-cont ovn-chassis-1 cont${i}
    check_ping cont${i} ovn-chassis-${i} mig-cont "potential-duplicates"
    check_ping migrator ovn-chassis-3 cont${i}
    check_ping migrator ovn-chassis-1 cont${i}
    check_ping cont${i} ovn-chassis-${i} migrator "potential-duplicates"
done

echo "== Finalizing migration =="
check multinode_nbctl --wait=hv set Logical_Switch_Port migrator options:requested-chassis=ovn-chassis-1

for i in 1 2 3; do
    check_ping mig-cont ovn-chassis-3 cont${i} "lost"
    check_ping mig-cont ovn-chassis-1 cont${i}
    check_ping cont${i} ovn-chassis-${i} mig-cont
    check_ping migrator ovn-chassis-3 cont${i} "lost"
    check_ping migrator ovn-chassis-1 cont${i}
    check_ping cont${i} ovn-chassis-${i} migrator
done

echo "== Starting another migration, this time before starting dst VM =="
# Unbind migrator from chassis-3
m_as ovn-chassis-3 ovs-vsctl -- set Interface migrator-p external_ids:iface-id=foo

check multinode_nbctl --wait=hv set Logical_Switch_Port migrator options:requested-chassis=ovn-chassis-1,ovn-chassis-3
sleep 1
m_as ovn-chassis-3 ovs-vsctl -- set Interface migrator-p external_ids:iface-id=migrator

for i in 1 2 3; do
    check_ping mig-cont ovn-chassis-3 cont${i}
    check_ping mig-cont ovn-chassis-1 cont${i}
    check_ping cont${i} ovn-chassis-${i} mig-cont "potential-duplicates"
    check_ping migrator ovn-chassis-3 cont${i}
    check_ping migrator ovn-chassis-1 cont${i}
    check_ping cont${i} ovn-chassis-${i} migrator "potential-duplicates"
done

echo "== Finalizing migration =="
check multinode_nbctl --wait=hv set Logical_Switch_Port migrator options:requested-chassis=ovn-chassis-3

for i in 1 2 3; do
    check_ping mig-cont ovn-chassis-1 cont${i} "lost"
    check_ping mig-cont ovn-chassis-3 cont${i}
    check_ping cont${i} ovn-chassis-${i} mig-cont
    check_ping migrator ovn-chassis-1 cont${i} "lost"
    check_ping migrator ovn-chassis-3 cont${i}
    check_ping cont${i} ovn-chassis-${i} migrator
done

# Remove iface-id from src after migration is completed
m_as ovn-chassis-1 ovs-vsctl -- remove Interface migrator-p external_ids iface-id
check multinode_nbctl --wait=sb sync

for i in 1 2 3; do
    check_ping migrator ovn-chassis-1 sw0-port${i} "lost"
    check_ping mig-cont ovn-chassis-1 cont${i} "lost"
    check_ping migrator ovn-chassis-1 cont${i} "lost"
    check_ping migrator ovn-chassis-3 sw0-port${i}
    check_ping mig-cont ovn-chassis-3 cont${i}
    check_ping migrator ovn-chassis-3 cont${i}
    check_ping sw0-port${i} ovn-chassis-${i} migrator
    check_ping cont${i} ovn-chassis-${i} mig-cont
    check_ping cont${i} ovn-chassis-${i} migrator
done

# Finally, remove interface from src after migration is completed
m_as ovn-chassis-1 ovs-vsctl -- del-port migrator-p
for i in 1 2 3; do
    check_ping migrator ovn-chassis-1 sw0-port${i} "lost"
    check_ping mig-cont ovn-chassis-1 cont${i} "lost"
    check_ping migrator ovn-chassis-1 cont${i} "lost"
    check_ping migrator ovn-chassis-3 sw0-port${i}
    check_ping mig-cont ovn-chassis-3 cont${i}
    check_ping migrator ovn-chassis-3 cont${i}
    check_ping sw0-port${i} ovn-chassis-${i} migrator
    check_ping cont${i} ovn-chassis-${i} mig-cont
    check_ping cont${i} ovn-chassis-${i} migrator
done

# Also do some recomputes ...
printf "%s\n" "## ---------------------------------- ##
## Recompute after removing interface ##
## ---------------------------------- ##"
for i in 1 2 3; do
    m_as ovn-chassis-${i} ovn-appctl -t ovn-controller recompute
done

check multinode_nbctl --wait=sb sync

for i in 1 2 3; do
    check_ping migrator ovn-chassis-1 sw0-port${i} "lost"
    check_ping mig-cont ovn-chassis-1 cont${i} "lost"
    check_ping migrator ovn-chassis-1 cont${i} "lost"
    check_ping migrator ovn-chassis-3 sw0-port${i}
    check_ping mig-cont ovn-chassis-3 cont${i}
    check_ping migrator ovn-chassis-3 cont${i}
    check_ping sw0-port${i} ovn-chassis-${i} migrator
    check_ping cont${i} ovn-chassis-${i} mig-cont
    check_ping cont${i} ovn-chassis-${i} migrator
done

m_as ovn-chassis-1 killall tcpdump
m_as ovn-chassis-2 killall tcpdump
m_as ovn-chassis-3 killall tcpdump

ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_16
#AT_START_17
at_fn_group_banner 17 'multinode.at:3029' \
  "ovn multinode bgp unnumbered" "                   " 1
at_xfail=no
(
  printf "%s\n" "17. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init


# Check that ovn-fake-multinode setup is up and running.
check_fake_multinode_setup


    rc=0
    modprobe vrf || rc=$?
    printf "%s\n" "multinode.at:3034" >"$at_check_line_file"
(test $rc -ne 0) \
  && at_fn_check_skip 77 "$at_srcdir/multinode.at:3034"
    on_exit 'modprobe -r vrf'


# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

setup_frr() {
    node=$1
    bgp_as=$2
    bgp_ip=$3
    br_name=br-$node

    check m_as $node ovs-vsctl add-br $br_name
    on_exit "m_as $node ovs-vsctl del-br $br_name"
    check m_as $node ip netns add frr-ns
    on_exit "m_as $node ip netns del frr-ns"

    check m_as $node ip netns exec frr-ns ip link set lo up
    m_as $node ovs-vsctl add-port $br_name ext1 \
        -- set interface ext1 type=internal

    m_as $node ip link set ext1 netns frr-ns
    m_as $node ip netns exec frr-ns ip link set ext1 up
    m_as $node ip netns exec frr-ns ip addr add $bgp_ip dev ext1

    # configure main frr
    check m_as $node sed -i 's/bgpd=no/bgpd=yes/g' /etc/frr/daemons
    check m_as $node sed -i 's/StartLimitBurst=.*/StartLimitBurst=100/g' /usr/lib/systemd/system/frr.service
    check m_as $node systemctl daemon-reload

    # setup frr namespace
    check m_as $node mkdir -p /etc/frr/frr-ns
    if m_is_fedora; then
        check m_as $node chown -R frr:frr /etc/frr/frr-ns
        check m_as $node mkdir -p /run/frr/frr-ns
        check m_as $node chown -R frr:frr /run/frr/frr-ns
        check m_as $node cp -r /etc/frr/daemons /etc/frr/frr.conf /etc/frr/frr-ns/
    else
        check m_as $node cp -r /etc/frr/daemons /etc/frr/frr.conf /etc/frr/support_bundle_commands.conf /etc/frr/frr-ns/
    fi

    on_exit "m_as $node rm -rf /etc/frr/frr-ns"
    check m_as $node rm -rf /etc/frr/frr-ns/vtysh.conf
    check m_as $node touch /etc/frr/frr-ns/vtysh.conf

    check m_as $node systemctl stop frr
    # start frr within namespace
    if m_is_fedora; then
        m_as $node ip netns exec frr-ns /usr/libexec/frr/frrinit.sh start frr-ns
        on_exit "m_as $node ip netns exec frr-ns /usr/libexec/frr/frrinit.sh stop frr-ns"
    else
        m_as $node ip netns exec frr-ns /usr/lib/frr/frrinit.sh start frr-ns
        on_exit "m_as $node ip netns exec frr-ns /usr/lib/frr/frrinit.sh stop frr-ns"
    fi
    on_exit "m_as $node systemctl stop frr"
    check m_as $node systemctl start frr

    frr_flags="-N frr-ns"
    if m_is_fedora; then
        frr_flags="--vty_socket /run/frr/frr-ns"
    fi

    # configure frr-ns frr
    echo "configure
    ip prefix-list accept-all seq 5 permit any

    router bgp $bgp_as
      bgp router-id $bgp_ip
      neighbor ext1 interface remote-as external
      address-family ipv4 unicast
        neighbor ext1 soft-reconfiguration inbound
        neighbor ext1 prefix-list accept-all in
      exit-address-family
      !
      address-family ipv6 unicast
        neighbor ext1 soft-reconfiguration inbound
        neighbor ext1 activate
      exit-address-family
    " | podman exec -i $node vtysh $frr_flags
}

setup_ovn_bgp() {
    node=$1
    bgp_as=$2
    bgp_ip=$3
    bgp_mac=$4
    vrf_id=$5
    br_name=br-$node
    physnet=physnet_${node}_ext0

    check m_as $node ovs-vsctl set Open_vSwitch . \
        external-ids:ovn-bridge-mappings="$physnet:$br_name"

    # setup lr and lrp for bgp
    check multinode_nbctl lr-add lr-$node-ext0
    check multinode_nbctl set Logical_Router lr-$node-ext0             \
        options:chassis=$node                                          \
        options:dynamic-routing=true options:requested-tnl-key=$vrf_id

    check multinode_nbctl lrp-add lr-$node-ext0 lrp-$node-ext0 $bgp_mac
    check multinode_nbctl lrp-set-options lrp-$node-ext0 \
        dynamic-routing-maintain-vrf=true                \
        dynamic-routing-redistribute=nat

    check multinode_nbctl ls-add ls-$node-ext0

    check multinode_nbctl lsp-add ls-$node-ext0 lsp-$node-ext0
    check multinode_nbctl lsp-set-type lsp-$node-ext0 router
    check multinode_nbctl lsp-set-options lsp-$node-ext0 \
        router-port=lrp-$node-ext0
    check multinode_nbctl lsp-set-addresses lsp-$node-ext0 router

    check multinode_nbctl lsp-add ls-$node-ext0 patch-$node-ext0
    check multinode_nbctl lsp-set-addresses patch-$node-ext0 unknown
    check multinode_nbctl lsp-set-type patch-$node-ext0 localnet
    check multinode_nbctl lsp-set-options patch-$node-ext0 \
        network_name=$physnet

    check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as $node ip link | grep -q ovnvrf${vrf_id}:.*UP
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3151" "until m_as \$node ip link | grep -q ovnvrf\${vrf_id}:.*UP"


    check multinode_nbctl lsp-add ls-$node-ext0 lsp-$node-ext0-bgp
    check multinode_nbctl lsp-set-addresses lsp-$node-ext0-bgp unknown

    # set up lrp with proper configuration for BGP
    check multinode_nbctl add Logical_Router_Port lrp-$node-ext0 \
        options routing-protocols=\"BGP,BFD\"                    \
                routing-protocol-redirect=lsp-$node-ext0-bgp
    check multinode_nbctl set Logical_Router_Port lrp-$node-ext0 \
        ipv6_ra_configs:send_periodic=true
    check multinode_nbctl set Logical_Router_Port lrp-$node-ext0 \
        ipv6_ra_configs:address_mode=slaac
    check multinode_nbctl set Logical_Router_Port lrp-$node-ext0 \
        ipv6_ra_configs:max_interval=1
    check multinode_nbctl set Logical_Router_Port lrp-$node-ext0 \
        ipv6_ra_configs:min_interval=1

    check m_as $node ovs-vsctl add-port br-int ext0-bgp --     \
        set Interface ext0-bgp type=internal  mac=\"$bgp_mac\" \
        external-ids:iface-id=lsp-$node-ext0-bgp
    on_exit "m_as $node ovs-vsctl del-port br-int ext0-bgp"

    check m_as $node ip link set dev ext0-bgp master ovnvrf${vrf_id}
    check m_as $node ip link set dev ext0-bgp up

    check multinode_nbctl --wait=hv sync
    m_wait_for_ports_up

    # configure frr to work with ovn bgp
    echo "configure
    ip prefix-list no-default seq 5 deny 0.0.0.0/0
    ip prefix-list no-default seq 10 permit 0.0.0.0/0 le 32

    ipv6 prefix-list no-default seq 5 deny ::/0
    ipv6 prefix-list no-default seq 10 permit ::/0 le 128

    vrf ovnvrf${vrf_id}
    exit-vrf

    router bgp ${bgp_as} vrf ovnvrf${vrf_id}
      bgp router-id $bgp_ip
      neighbor ext0-bgp interface remote-as external
      address-family ipv4 unicast
        redistribute kernel
        neighbor ext0-bgp prefix-list no-default out
      exit-address-family
      address-family ipv6 unicast
        neighbor ext0-bgp soft-reconfiguration inbound
        neighbor ext0-bgp prefix-list no-default out
        redistribute kernel
        neighbor ext0-bgp activate
      exit-address-family
    " | podman exec -i $node vtysh
}

add_guest_vm_and_connections() {
    node=$1
    vrf_id=$2
    default_route_mac=$3
    default_route=$4
    default_route_gw=$5
    guest_gw_ip=$6
    guest_ip=$7

    gw_lr=lr-$node-ext0
    lrp_to_join=lrp-$node-to-join
    lsp_join_to_lrp=join-to-lrp-$node
    lrp_guest=lrp-guest-$node

    ls_g=ls-guest-$node
    lsp_g_lrg=lsp-guest-$node-lr-guest
    lsp_g_iface=lsp-guest-$node-guest-vm
    lrp_g_lsg=lrp-guest-ls-guest-$node

    guest_gw_cidr="$guest_gw_ip/24"
    guest_cidr="$guest_ip/24"

    # set up connections to connect the new vm
    check multinode_nbctl lrp-add $gw_lr $lrp_to_join $default_route_mac
    check multinode_nbctl lrp-set-options $lrp_to_join \
        dynamic-routing-redistribute=nat
    check multinode_nbctl lsp-add $join_ls $lsp_join_to_lrp
    check multinode_nbctl lsp-set-type $lsp_join_to_lrp router
    check multinode_nbctl lsp-set-options $lsp_join_to_lrp \
        router-port=$lrp_to_join
    check multinode_nbctl lsp-set-addresses $lsp_join_to_lrp router

    check multinode_nbctl ls-add $ls_g
    check multinode_nbctl lrp-add $lr_guest $lrp_g_lsg \
        00:16:03:01:03:03 $guest_gw_cidr
    check multinode_nbctl lsp-add $ls_g $lsp_g_lrg
    check multinode_nbctl lsp-set-type $lsp_g_lrg router
    check multinode_nbctl lsp-set-options $lsp_g_lrg router-port=$lrp_g_lsg
    check multinode_nbctl lsp-set-addresses $lsp_g_lrg router
    check multinode_nbctl lsp-add $ls_g $lsp_g_iface
    check multinode_nbctl lsp-set-addresses $lsp_g_iface \
        '00:16:01:00:02:02 '$guest_cidr''

    # create the new vm
    m_as $node /data/create_fake_vm.sh $lsp_g_iface $guest_vm_ns \
        00:16:01:00:02:02 1342 $guest_ip 24 $guest_gw_ip 1000::13/64 1000::a
    neighbor_lla=$(m_as $node vtysh -c "show bgp vrf ovnvrf${vrf_id} neighbor ext0-bgp" | grep "^Foreign host:" | awk '{print $3}' | tr -d ',')

    check multinode_nbctl lr-route-add lr-$node-ext0 "0.0.0.0/0" \
        $neighbor_lla lrp-$node-ext0
    check multinode_nbctl lr-route-add $lr_guest \
        $default_route $default_route_gw $lrp_guest_join
}

setup_frr ovn-gw-1     4200000100 41.41.41.41
setup_ovn_bgp ovn-gw-1 4210000000 14.14.14.14 12:fb:d6:66:99:1c 10

setup_frr ovn-gw-2     4200000200 42.42.42.42
setup_ovn_bgp ovn-gw-2 4210000000 24.24.24.24 22:fb:d6:66:99:2c 20

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-2 vtysh -c 'show bgp vrf ovnvrf20 neighbors' | grep -qE 'Connections established 1'
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3267" "until m_as ovn-gw-2 vtysh -c 'show bgp vrf ovnvrf20 neighbors' | grep -qE 'Connections established 1'"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-1 vtysh -c 'show bgp vrf ovnvrf10 neighbors' | grep -qE 'Connections established 1'
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3268" "until m_as ovn-gw-1 vtysh -c 'show bgp vrf ovnvrf10 neighbors' | grep -qE 'Connections established 1'"


# Tor <-> ovn-gw via bgp
# lr-guest with distributed gateway port
# bgp on lr-ovn-gw-2-ext0
#
#                guest-1          guest-2
#                       \        /
#                        lr-guest
#                          DGP
#                           |
#                        ls-join
#                       /       \
# tor <-> lr-ovn-gw-2-ext0*    lr-ovn-gw-1-ext0* <-> tor
#               |                     |
#         ls-ovn-gw-2-ext0     ls-ovn-gw-1-ext0
#
#
#

join_ls="ls-join"
lsp_join_guest="lsp-join-guest"

lr_guest="lr-guest"
lrp_guest_join="lrp-guest-join-dgp"

guest_vm_iface="guest-vm"
guest_vm_ns="ns-guest"

check multinode_nbctl ls-add $join_ls

check multinode_nbctl lr-add $lr_guest
check multinode_nbctl lrp-add $lr_guest $lrp_guest_join 00:16:06:12:f0:0d
check multinode_nbctl lsp-add $join_ls $lsp_join_guest
check multinode_nbctl lsp-set-type $lsp_join_guest router
check multinode_nbctl lsp-set-options $lsp_join_guest \
    router-port=$lrp_guest_join
check multinode_nbctl lsp-set-addresses $lsp_join_guest router
check multinode_nbctl lrp-set-gateway-chassis $lrp_guest_join ovn-gw-1 20
check multinode_nbctl lrp-set-gateway-chassis $lrp_guest_join ovn-gw-2 20

vrf_id=10
default_route_mac=00:00:ff:00:00:01
default_route=41.0.0.0/8
default_route_gw=fe80::200:ffff:fe00:1
guest_gw_ip=192.168.10.1
guest_ip=192.168.10.10
add_guest_vm_and_connections ovn-gw-1 $vrf_id           \
    $default_route_mac $default_route $default_route_gw \
    $guest_gw_ip $guest_ip

vrf_id=20
default_route_mac=00:00:ff:00:00:02
default_route=42.0.0.0/8
default_route_gw=fe80::200:ffff:fe00:2
guest_gw_ip=192.168.20.1
guest_ip=192.168.20.10
add_guest_vm_and_connections ovn-gw-2 $vrf_id           \
    $default_route_mac $default_route $default_route_gw \
    $guest_gw_ip $guest_ip

check multinode_nbctl --gateway-port $lrp_guest_join --add-route lr-nat-add \
    $lr_guest dnat_and_snat 172.16.10.2 192.168.10.10

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_central_as ovn-sbctl list Advertised_Route | grep -q 172.16.10.2
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3332" "until m_central_as ovn-sbctl list Advertised_Route | grep -q 172.16.10.2"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-1 ip netns exec frr-ns ip route | grep -q 'ext1'
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3333" "until m_as ovn-gw-1 ip netns exec frr-ns ip route | grep -q 'ext1'"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-1 ip netns exec frr-ns ping -W 1 -c 1 172.16.10.2
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3334" "until m_as ovn-gw-1 ip netns exec frr-ns ping -W 1 -c 1 172.16.10.2"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-2 ip netns exec frr-ns ip route | grep -q 'ext1'
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3335" "until m_as ovn-gw-2 ip netns exec frr-ns ip route | grep -q 'ext1'"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-2 ip netns exec frr-ns ping -W 1 -c 1 172.16.10.2
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3336" "until m_as ovn-gw-2 ip netns exec frr-ns ping -W 1 -c 1 172.16.10.2"


ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_17
#AT_START_18
at_fn_group_banner 18 'multinode.at:3340' \
  "HA: Check for missing garp on leader when BFD goes back up" "" 1
at_xfail=no
(
  printf "%s\n" "18. $at_setup_line: testing $at_desc ..."
  $at_traceon

ovs_init

# Network topology
#    
#                                                                                                            
#                        
#           ovn-chassis-1         ovn-gw-1               ovn-gw-2               ovn-chassis-2        
#                        
#                                                                                       
#               inside1                                                                                    
#           192.168.1.1/24                                                                                 
#                                                                                       
#                                                                                       
#               inside                                                                                     
#                                                                                       
#                                                                                       
#            192.168.1.254                                                                                 
#                 R1                                                                                       
#            192.168.0.254                                                                                 
#                                                                                       
#                  ------eth1-----------------------eth1-----------                                       
#                                                                  
#                                     192.168.1.254         192.168.1.254                                
#                                          R1                     R1                                     
#                                     192.168.0.254         192.168.0.254                                
#                                                                  
#                                                                                     
#                                             192.168.0.1        
#                                        outside                outside                 ext1           
#                                             
#                                             
#                                     ln-outside             ln-outside                ln-ext1         
#                                             
#                                             
#                                        br-ex                  br-ex                  br-ex           
#                                             
#                                           ---------eth2------------------eth2-------------              
#                                                                                                            
#    

# The goal of this test is the check that GARP are properly generated by higest priority traffic when
# BFD goes down, and back up, and this whether the BFD event is due either to some bfd packet lost
# or by gw death.
# gw1 is the highest priority gw; gw2 the second priority and gw3 is configured as the lowest priority gw.
# So gw3 should in this test neither send garp or receive packets.
#
# Enable vconn so we can check the GARP from a log perspective.
m_as ovn-gw-1 ovn-appctl vlog/set vconn:dbg
m_as ovn-gw-2 ovn-appctl vlog/set vconn:dbg
m_as ovn-gw-3 ovn-appctl vlog/set vconn:dbg
m_as ovn-gw-1 ovn-appctl vlog/disable-rate-limit
m_as ovn-gw-2 ovn-appctl vlog/disable-rate-limit
m_as ovn-gw-3 ovn-appctl vlog/disable-rate-limit

check_fake_multinode_setup

# Delete the multinode NB and OVS resources before starting the test.
cleanup_multinode_resources

ip_ch1=$(m_as ovn-chassis-1 ip a show dev eth1 | grep "inet " | awk '{print $2}'| cut -d '/' -f1)
ip_gw1=$(m_as ovn-gw-1 ip a show dev eth1 | grep "inet " | awk '{print $2}'| cut -d '/' -f1)
ip_gw2=$(m_as ovn-gw-2 ip a show dev eth1 | grep "inet " | awk '{print $2}'| cut -d '/' -f1)
ip_gw3=$(m_as ovn-gw-3 ip a show dev eth1 | grep "inet " | awk '{print $2}'| cut -d '/' -f1)

from_gw1_to_gw2=$(m_as ovn-gw-1 ovs-vsctl --bare --columns=name find interface options:remote_ip=$ip_gw2)
from_gw1_to_gw3=$(m_as ovn-gw-1 ovs-vsctl --bare --columns=name find interface options:remote_ip=$ip_gw3)
from_gw1_to_ch1=$(m_as ovn-gw-1 ovs-vsctl --bare --columns=name find interface options:remote_ip=$ip_ch1)
from_gw2_to_gw1=$(m_as ovn-gw-2 ovs-vsctl --bare --columns=name find interface options:remote_ip=$ip_gw1)
from_gw2_to_gw3=$(m_as ovn-gw-2 ovs-vsctl --bare --columns=name find interface options:remote_ip=$ip_gw3)
from_gw2_to_ch1=$(m_as ovn-gw-2 ovs-vsctl --bare --columns=name find interface options:remote_ip=$ip_ch1)
from_ch1_to_gw1=$(m_as ovn-chassis-1 ovs-vsctl --bare --columns=name find interface options:remote_ip=$ip_gw1)
from_ch1_to_gw2=$(m_as ovn-chassis-1 ovs-vsctl --bare --columns=name find interface options:remote_ip=$ip_gw2)

m_as ovn-chassis-1 ip link del hv1-vif1-p
m_as ovn-chassis-2 ip link del ext1-p

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-1 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3415" "until m_as ovn-chassis-1 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-chassis-2 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3416" "until m_as ovn-chassis-2 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-1 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3417" "until m_as ovn-gw-1 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-2 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3418" "until m_as ovn-gw-2 ip link show | grep -q genev_sys"

check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    m_as ovn-gw-3 ip link show | grep -q genev_sys
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3419" "until m_as ovn-gw-3 ip link show | grep -q genev_sys"


check multinode_nbctl ls-add inside
check multinode_nbctl ls-add outside
check multinode_nbctl ls-add ext
check multinode_nbctl lsp-add inside inside1 -- lsp-set-addresses inside1 "f0:00:c0:a8:01:01 192.168.1.1"
check multinode_nbctl lsp-add ext ext1 -- lsp-set-addresses ext1 "00:00:c0:a8:00:01 192.168.0.1"

multinode_nbctl create Logical_Router name=R1
check multinode_nbctl lrp-add R1 R1_inside f0:00:c0:a8:01:fe 192.168.1.254/24
check multinode_nbctl -- lsp-add inside inside_R1 \
                      -- set Logical_Switch_Port inside_R1 type=router options:router-port=R1_inside \
                      -- lsp-set-addresses inside_R1 router

check multinode_nbctl lrp-add R1 R1_outside f0:00:c0:a8:00:fe 192.168.0.254/24
check multinode_nbctl -- lsp-add outside outside_R1 \
                      -- set Logical_Switch_Port outside_R1 type=router options:router-port=R1_outside \
                      -- lsp-set-addresses outside_R1 router

multinode_nbctl -- --id=@gc0 create Gateway_Chassis name=outside_gw1 chassis_name=ovn-gw-1 priority=20 \
                -- --id=@gc1 create Gateway_Chassis name=outside_gw2 chassis_name=ovn-gw-2 priority=10 \
                -- --id=@gc2 create Gateway_Chassis name=outside_gw3 chassis_name=ovn-gw-3 priority=5 \
                -- set Logical_Router_Port R1_outside 'gateway_chassis=@gc0,@gc1,@gc2'

# Create localnet port in outside
check multinode_nbctl lsp-add outside ln-outside
check multinode_nbctl lsp-set-addresses ln-outside unknown
check multinode_nbctl lsp-set-type ln-outside localnet
check multinode_nbctl lsp-set-options ln-outside network_name=public

# Create localnet port in ext1
check multinode_nbctl lsp-add ext ln-ext1
check multinode_nbctl lsp-set-addresses ln-ext1 unknown
check multinode_nbctl lsp-set-type ln-ext1 localnet
check multinode_nbctl lsp-set-options ln-ext1 network_name=public

# Make sure garp-max-timeout-sec is not set
m_as ovn-gw-1 ovs-vsctl remove open . external_ids garp-max-timeout-sec
m_as ovn-gw-2 ovs-vsctl remove open . external_ids garp-max-timeout-sec
m_as ovn-gw-3 ovs-vsctl remove open . external_ids garp-max-timeout-sec

m_as ovn-chassis-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-chassis-2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-gw-1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-gw-2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex
m_as ovn-gw-3 ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-ex

m_as ovn-chassis-1 /data/create_fake_vm.sh inside1 hv1-vif1 f0:00:c0:a8:01:01 1500 192.168.1.1 24 192.168.1.254 2000::1/64 2000::a
m_as ovn-chassis-2 /data/create_fake_vm.sh ext1 ext1 00:00:c0:a8:00:01 1500 192.168.0.1 24 192.168.0.254 1000::3/64 1000::a

# There should be one ha_chassis_group with the name "R1_outside"
m_check_row_count HA_Chassis_Group 1 name=R1_outside

# There should be 2 ha_chassis rows in SB DB.
m_check_row_count HA_Chassis 3 'chassis!=[]'

ha_ch=$(m_fetch_column HA_Chassis_Group ha_chassis)
m_check_column "$ha_ch" HA_Chassis _uuid

gw1_chassis=$(m_fetch_column Chassis _uuid name=ovn-gw-1)
gw2_chassis=$(m_fetch_column Chassis _uuid name=ovn-gw-2)
gw3_chassis=$(m_fetch_column Chassis _uuid name=ovn-gw-3)

wait_bfd_enabled() {
    chassis=$1
    interface=$2
    echo "Using $chassis $interface"
    check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    test 1 = $(m_as $chassis ovs-vsctl --bare --columns bfd find Interface name=$interface | \
grep "enable=true" | wc -l)

}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3486" "until test 1 = \$(m_as \$chassis ovs-vsctl --bare --columns bfd find Interface name=\$interface | \\
grep \"enable=true\" | wc -l)
"

}

wait_bfd_up() {
    hv1=$1
    hv2=$2

    echo "checking bfd_status for $hv1 => $hv2"
    check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {

        state=$(m_as $hv1 ovs-vsctl get interface $hv2 bfd_status:state)
        remote_state=$(m_as $hv1 ovs-vsctl get interface $hv2 bfd_status:remote_state)
        echo "$(date +%H:%M:%S.%03N) bfd state = $state, remote_state = $remote_state"
        test "$state" = "up" -a "$remote_state" = "up"

}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3496" "until
        state=\$(m_as \$hv1 ovs-vsctl get interface \$hv2 bfd_status:state)
        remote_state=\$(m_as \$hv1 ovs-vsctl get interface \$hv2 bfd_status:remote_state)
        echo \"\$(date +%H:%M:%S.%03N) bfd state = \$state, remote_state = \$remote_state\"
        test \"\$state\" = \"up\" -a \"\$remote_state\" = \"up\"
    "

}

# check BFD enablement on tunnel ports from ovn-gw-1 ##########
for chassis in $from_gw1_to_gw2 $from_gw1_to_gw3 $from_gw1_to_ch1; do
    echo "checking ovn-gw-1 -> $chassis"
    wait_bfd_enabled ovn-gw-1 $chassis
done

# check BFD enablement on tunnel ports from ovn-gw-2 ##########
for chassis in $from_gw2_to_gw1 $from_gw2_to_gw3 $from_gw2_to_ch1; do
    echo "checking ovn-gw-2 -> $chassis"
    wait_bfd_enabled ovn-gw-2 $chassis
done

# check BFD enablement on tunnel ports from ovn-chassis-1 ###########
for chassis in $from_ch1_to_gw1 $from_ch1_to_gw2; do
    echo "checking ovn-chassis-1 -> $chassis"
    wait_bfd_enabled ovn-chassis-1 $chassis
done

# Make sure there is no nft table left. Do not use nft directly as might not be installed in container.
gw1_pid=$(podman inspect -f '{{.State.Pid}}' ovn-gw-1)
nsenter --net=/proc/$gw1_pid/ns/net nft list tables | grep ovn-test && nsenter --net=/proc/$gw1_pid/ns/net nft delete table ip ovn-test
on_exit "nsenter --net=/proc/$gw1_pid/ns/net nft list tables | grep ovn-test && nsenter --net=/proc/$gw1_pid/ns/net nft delete table ip ovn-test"

for chassis in $from_gw1_to_gw2 $from_gw1_to_gw3 $from_gw1_to_ch1; do
    wait_bfd_up ovn-gw-1 $chassis
done
for chassis in $from_gw2_to_gw1 $from_gw2_to_gw3 $from_gw2_to_ch1; do
    wait_bfd_up ovn-gw-2 $chassis
done
for chassis in $from_ch1_to_gw1 $from_ch1_to_gw2; do
    wait_bfd_up ovn-chassis-1 $chassis
done

m_wait_row_count Port_Binding 1 logical_port=cr-R1_outside chassis=$gw1_chassis
check multinode_nbctl --wait=hv sync

start_tcpdump() {
    echo "$(date +%H:%M:%S.%03N) Starting tcpdump"

     podman exec ovn-chassis-1 tcpdump -l -neei hv1-vif1-p >ch1.tcpdump 2>ch1.stderr &
     echo "podman exec ovn-chassis-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch1.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3542" "until grep -q \"listening\" ch1.stderr"




     podman exec ovn-chassis-2 tcpdump -l -neei eth2 >ch2.tcpdump 2>ch2.stderr &
     echo "podman exec ovn-chassis-2 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-chassis-2 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" ch2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3543" "until grep -q \"listening\" ch2.stderr"




     podman exec ovn-gw-1 tcpdump -l -neei eth2 >gw1.tcpdump 2>gw1.stderr &
     echo "podman exec ovn-gw-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-gw-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" gw1.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3544" "until grep -q \"listening\" gw1.stderr"




     podman exec ovn-gw-1 tcpdump -l -neei eth2 -Q out >gw1_out.tcpdump 2>gw1_out.stderr &
     echo "podman exec ovn-gw-1 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-gw-1 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" gw1_out.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3545" "until grep -q \"listening\" gw1_out.stderr"




     podman exec ovn-gw-2 tcpdump -l -neei eth2 >gw2.tcpdump 2>gw2.stderr &
     echo "podman exec ovn-gw-2 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-gw-2 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" gw2.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3546" "until grep -q \"listening\" gw2.stderr"




     podman exec ovn-gw-2 tcpdump -l -neei eth2 -Q out >gw2_out.tcpdump 2>gw2_out.stderr &
     echo "podman exec ovn-gw-2 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-gw-2 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" gw2_out.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3547" "until grep -q \"listening\" gw2_out.stderr"




     podman exec ovn-gw-3 tcpdump -l -neei eth2 >gw3.tcpdump 2>gw3.stderr &
     echo "podman exec ovn-gw-3 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-gw-3 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" gw3.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3548" "until grep -q \"listening\" gw3.stderr"




     podman exec ovn-gw-3 tcpdump -l -neei eth2 -Q out >gw3_out.tcpdump 2>gw3_out.stderr &
     echo "podman exec ovn-gw-3 ps -ef | grep -v grep | grep tcpdump && podman exec ovn-gw-3 killall tcpdump" >> cleanup
     check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {
    grep -q "listening" gw3_out.stderr
}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3549" "until grep -q \"listening\" gw3_out.stderr"



}

stop_tcpdump() {
    echo "$(date +%H:%M:%S.%03N) Stopping tcpdump"
    m_kill 'ovn-gw-1 ovn-gw-2 ovn-gw-3 ovn-chassis-1 ovn-chassis-2' tcpdump
}

# Send packets from chassis2 (ext1) to chassis1
send_background_packets() {
    echo "$(date +%H:%M:%S.%03N) Sending packets in Background"
    start_tcpdump
    podman exec ovn-chassis-2 ip netns exec ext1 ping -f -i 0.1 192.168.1.1 & echo $! > ping.pid
     echo "kill \`cat ping.pid\` 2>/dev/null" >> cleanup


}

stop_sending_background_packets() {
    echo "$(date +%H:%M:%S.%03N) Stopping Background process"
    m_as ovn-chassis-1 ps -ef | grep -v grep | grep -q ping && \
        m_as ovn-chassis-1 echo "Stopping ping on ovn-chassis-1" && killall ping
    m_as ovn-chassis-2 ps -ef | grep -v grep | grep -q ping && \
        m_as ovn-chassis-2 echo "Stopping ping on ovn-chassis-2" && killall ping
    stop_tcpdump
}

check_for_new_garps() {
    hv=$1
    expecting_garp=$2
    n_new_garps=$(cat ${hv}_out.tcpdump | grep -c "f0:00:c0:a8:00:fe > Broadcast, ethertype ARP (0x0806), length 42: Request who-has 192.168.0.254 tell 192.168.0.254, length 28")

    if  "$expecting_garp" == "true" ; then
        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Waiting/checking for garp from $hv - Starting with $n_new_garps ##
_ASBOX
        check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {

            n_garps=$n_new_garps
            n_new_garps=$(cat ${hv}_out.tcpdump | grep -c "f0:00:c0:a8:00:fe > Broadcast, ethertype ARP (0x0806), length 42: Request who-has 192.168.0.254 tell 192.168.0.254, length 28")
            echo "We saw $n_new_garps so far on ${hv}."
            test "$n_garps" -ne "$n_new_garps"

}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3580" "until
            n_garps=\$n_new_garps
            n_new_garps=\$(cat \${hv}_out.tcpdump | grep -c \"f0:00:c0:a8:00:fe > Broadcast, ethertype ARP (0x0806), length 42: Request who-has 192.168.0.254 tell 192.168.0.254, length 28\")
            echo \"We saw \$n_new_garps so far on \${hv}.\"
            test \"\$n_garps\" -ne \"\$n_new_garps\"
        "

    else
        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Checking no garp from ${hv} ##
_ASBOX
        # Waiting a few seconds to get a chance to see unexpected garps.
        sleep 3
        n_garps=$(cat ${hv}_out.tcpdump | grep -c "f0:00:c0:a8:00:fe > Broadcast, ethertype ARP (0x0806), length 42: Request who-has 192.168.0.254 tell 192.168.0.254, length 28")
        { set +x
printf "%s\n" "$at_srcdir/multinode.at:3591: test \"\$n_garps\" -eq \"\$n_new_garps\""
at_fn_check_prepare_dynamic "test \"$n_garps\" -eq \"$n_new_garps\"" "multinode.at:3591"
( $at_check_trace; test "$n_garps" -eq "$n_new_garps"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:3591"
$at_failed && at_fn_log_failure
$at_traceon; }

    fi
}

check_for_new_echo_pkts() {
    hv=$1
    mac_src=$2
    mac_dst=$3
    expecting_pkts=$4
    n_new_echo_req=$(cat ${hv}.tcpdump | grep -c "$mac_src > $mac_dst, ethertype IPv4 (0x0800), length 98: 192.168.0.1 > 192.168.1.1: ICMP echo request")
    n_new_echo_rep=$(cat ${hv}.tcpdump | grep -c "$mac_dst > $mac_src, ethertype IPv4 (0x0800), length 98: 192.168.1.1 > 192.168.0.1: ICMP echo reply")

    if  "$expecting_pkts" == "true" ; then
        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Waiting/checking for echo pkts through ${hv} ##
_ASBOX
        echo "Starting with $n_new_echo_req requests and $n_new_echo_rep replies so far on ${hv}."
        check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {

            n_echo_req=$n_new_echo_req
            n_echo_rep=$n_new_echo_rep
            n_new_echo_req=$(cat ${hv}.tcpdump | grep -c "$mac_src > $mac_dst, ethertype IPv4 (0x0800), length 98: 192.168.0.1 > 192.168.1.1: ICMP echo request")
            n_new_echo_rep=$(cat ${hv}.tcpdump | grep -c "$mac_dst > $mac_src, ethertype IPv4 (0x0800), length 98: 192.168.1.1 > 192.168.0.1: ICMP echo reply")
            echo "We saw $n_new_echo_req requests and $n_new_echo_rep replies so far on ${hv}."
            test "$n_echo_req" -ne "$n_new_echo_req" && test "$n_echo_rep" -ne "$n_new_echo_rep"

}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3606" "until
            n_echo_req=\$n_new_echo_req
            n_echo_rep=\$n_new_echo_rep
            n_new_echo_req=\$(cat \${hv}.tcpdump | grep -c \"\$mac_src > \$mac_dst, ethertype IPv4 (0x0800), length 98: 192.168.0.1 > 192.168.1.1: ICMP echo request\")
            n_new_echo_rep=\$(cat \${hv}.tcpdump | grep -c \"\$mac_dst > \$mac_src, ethertype IPv4 (0x0800), length 98: 192.168.1.1 > 192.168.0.1: ICMP echo reply\")
            echo \"We saw \$n_new_echo_req requests and \$n_new_echo_rep replies so far on \${hv}.\"
            test \"\$n_echo_req\" -ne \"\$n_new_echo_req\" && test \"\$n_echo_rep\" -ne \"\$n_new_echo_rep\"
        "

    else
        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Checking no pkts from ${hv} ##
_ASBOX
        # Waiting a few seconds to get a chance to see unexpected pkts.
        sleep 3
        n_echo_req=$(cat ${hv}.tcpdump | grep -c "$mac_src > $mac_dst, ethertype IPv4 (0x0800), length 98: 192.168.0.1 > 192.168.1.1: ICMP echo request")
        n_echo_rep=$(cat ${hv}.tcpdump | grep -c "$mac_dst > $mac_src, ethertype IPv4 (0x0800), length 98: 192.168.1.1 > 192.168.0.1: ICMP echo reply")
        echo "We saw $n_new_echo_req requests and $n_new_echo_rep replies on ${hv}."
        { set +x
printf "%s\n" "$at_srcdir/multinode.at:3621: test \"\$n_echo_req\" -eq \"\$n_new_echo_req\" && test \"\$n_echo_rep\" -eq \"\$n_new_echo_rep\""
at_fn_check_prepare_dynamic "test \"$n_echo_req\" -eq \"$n_new_echo_req\" && test \"$n_echo_rep\" -eq \"$n_new_echo_rep\"" "multinode.at:3621"
( $at_check_trace; test "$n_echo_req" -eq "$n_new_echo_req" && test "$n_echo_rep" -eq "$n_new_echo_rep"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:3621"
$at_failed && at_fn_log_failure
$at_traceon; }

    fi
}

dump_statistics() {
    n1=$(m_as ovn-gw-1 grep -c Changing /var/log/ovn/ovn-controller.log)
    n2=$(m_as ovn-gw-2 grep -c Changing /var/log/ovn/ovn-controller.log)
    n3=$(m_as ovn-gw-3 grep -c Changing /var/log/ovn/ovn-controller.log)
    ch1_req=$(grep -c "ICMP echo request" ch1.tcpdump)
    ch1_rep=$(grep -c "ICMP echo reply" ch1.tcpdump)
    ch2_req=$(grep -c "ICMP echo request" ch2.tcpdump)
    ch2_rep=$(grep -c "ICMP echo reply" ch2.tcpdump)
    gw1_req=$(grep -c "ICMP echo request" gw1.tcpdump)
    gw1_rep=$(grep -c "ICMP echo reply" gw1.tcpdump)
    gw2_req=$(grep -c "ICMP echo request" gw2.tcpdump)
    gw2_rep=$(grep -c "ICMP echo reply" gw2.tcpdump)
    gw3_req=$(grep -c "ICMP echo request" gw3.tcpdump)
    gw3_rep=$(grep -c "ICMP echo reply" gw3.tcpdump)
    echo "$n1 claims in gw1, $n2 in gw2 and $n3 on gw3"
    echo "ch2_request=$ch2_req gw1_request=$gw1_req gw2_request=$gw2_req gw3_request=$gw3_req ch1_request=$ch1_req ch1_reply=$ch1_rep gw1_reply=$gw1_rep gw2_reply=$gw2_rep gw3_reply=$gw3_rep ch2_reply=$ch2_rep"
}

check_migration_between_gw1_and_gw2() {
    action=$1
    send_background_packets

    # We make sure gw1 is leader since enough time that it generated all its garps.
    sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Waiting all garps sent by gw1 ##
_ASBOX
    n_new_garps=$(cat gw1_out.tcpdump | grep -c "f0:00:c0:a8:00:fe > Broadcast, ethertype ARP (0x0806), length 42: Request who-has 192.168.0.254 tell 192.168.0.254, length 28")
    check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {

        n_garps=$n_new_garps
        echo "We saw $n_garps so far."
        # Garp delay might be up to 8 seconds.
        sleep 10
        n_new_garps=$(cat gw1_out.tcpdump | grep -c "f0:00:c0:a8:00:fe > Broadcast, ethertype ARP (0x0806), length 42: Request who-has 192.168.0.254 tell 192.168.0.254, length 28")
        test "$n_garps" -eq "$n_new_garps"

}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3650" "until
        n_garps=\$n_new_garps
        echo \"We saw \$n_garps so far.\"
        # Garp delay might be up to 8 seconds.
        sleep 10
        n_new_garps=\$(cat gw1_out.tcpdump | grep -c \"f0:00:c0:a8:00:fe > Broadcast, ethertype ARP (0x0806), length 42: Request who-has 192.168.0.254 tell 192.168.0.254, length 28\")
        test \"\$n_garps\" -eq \"\$n_new_garps\"
    "


    # All packets should go through gw1, and none through gw2 or gw3.
    check_for_new_echo_pkts gw1 "00:00:c0:a8:00:01" "f0:00:c0:a8:00:fe" "true"
    check_for_new_echo_pkts gw2 "00:00:c0:a8:00:01" "f0:00:c0:a8:00:fe" "false"
    check_for_new_echo_pkts gw3 "00:00:c0:a8:00:01" "f0:00:c0:a8:00:fe" "false"

    flap_count_gw_1=$(m_as ovn-gw-1 ovs-vsctl get interface $from_gw1_to_gw2 bfd_status | sed 's/.*flap_count=\"\([0-9]*\).*/\1/g')
    flap_count_gw_2=$(m_as ovn-gw-2 ovs-vsctl get interface $from_gw2_to_gw1 bfd_status | sed 's/.*flap_count=\"\([0-9]*\).*/\1/g')

    if  test "$action" == "stop_bfd" ; then
        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Blocking bfd on gw1 (from $ip_gw1 to $ip_gw2) ##
_ASBOX
        nsenter --net=/proc/$gw1_pid/ns/net nft add table ip ovn-test
        nsenter --net=/proc/$gw1_pid/ns/net nft 'add chain ip ovn-test INPUT { type filter hook input priority 0; policy accept; }'
        # Drop BFD from gw-1 to gw-2: geneve port (6081), inner port 3784 (0xec8), Session state Up, Init, Down.
        nsenter --net=/proc/$gw1_pid/ns/net nft add rule ip ovn-test INPUT ip daddr $ip_gw1 ip saddr $ip_gw2 udp dport 6081 '@th,416,16 == 0x0ec8 @th,472,8 == 0xc0  counter drop'
        nsenter --net=/proc/$gw1_pid/ns/net nft add rule ip ovn-test INPUT ip daddr $ip_gw1 ip saddr $ip_gw2 udp dport 6081 '@th,416,16 == 0x0ec8 @th,472,8 == 0x80  counter drop'
        nsenter --net=/proc/$gw1_pid/ns/net nft add rule ip ovn-test INPUT ip daddr $ip_gw1 ip saddr $ip_gw2 udp dport 6081 '@th,416,16 == 0x0ec8 @th,472,8 == 0x40  counter drop'

        # We do not check that packets go through gw2 as BFD between chassis-2 and gw1 is still up
    fi

    if  test "$action" == "kill_gw2" ; then
        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Killing gw2 ovn-controller ##
_ASBOX
        on_exit 'm_as ovn-gw-2 /usr/share/openvswitch/scripts/ovs-ctl status ||
                 m_as ovn-gw-2 /usr/share/openvswitch/scripts/ovs-ctl start --system-id=ovn-gw-1'
        on_exit 'm_as ovn-gw-2 /usr/share/ovn/scripts/ovn-ctl status_controller ||
                 m_as ovn-gw-2 /usr/share/ovn/scripts/ovn-ctl start_controller ${CONTROLLER_SSL_ARGS}'

        m_as ovn-gw-2 kill -9 $(m_as ovn-gw-2 cat /run/ovn/ovn-controller.pid)
        m_as ovn-gw-2 kill -9 $(m_as ovn-gw-2 cat /run/openvswitch/ovs-vswitchd.pid)
        m_as ovn-gw-2 kill -9 $(m_as ovn-gw-2 cat /run/openvswitch/ovsdb-server.pid)
        # Also delete datapath (flows)
        m_as ovn-gw-2 ovs-dpctl del-dp system@ovs-system
    fi

    if  test "$action" == "kill_gw1" ; then
        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Killing gw1 ovn-controller ##
_ASBOX
        on_exit 'm_as ovn-gw-1 /usr/share/openvswitch/scripts/ovs-ctl status ||
                 m_as ovn-gw-1 /usr/share/openvswitch/scripts/ovs-ctl start --system-id=ovn-gw-1'
        on_exit 'm_as ovn-gw-1 /usr/share/ovn/scripts/ovn-ctl status_controller ||
                 m_as ovn-gw-1 /usr/share/ovn/scripts/ovn-ctl start_controller ${CONTROLLER_SSL_ARGS}'

        m_as ovn-gw-1 kill -9 $(m_as ovn-gw-1 cat /run/ovn/ovn-controller.pid)
        m_as ovn-gw-1 kill -9 $(m_as ovn-gw-1 cat /run/openvswitch/ovs-vswitchd.pid)
        m_as ovn-gw-1 kill -9 $(m_as ovn-gw-1 cat /run/openvswitch/ovsdb-server.pid)
        # Also delete datapath (flows)
        m_as ovn-gw-1 ovs-dpctl del-dp system@ovs-system
    fi

    if  test "$action" == "kill_gw2" ; then
        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Waiting for flap count between gw1 and gw2 to increase ##
_ASBOX
        check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {

            new_flap_count=$(m_as ovn-gw-1 ovs-vsctl get interfac $from_gw1_to_gw2 bfd_status | sed 's/.*flap_count=\"\([0-9]*\).*/\1/g')
            echo "Comparing $new_flap_count versus $flap_count_gw_1"
            test "$new_flap_count" -gt "$((flap_count_gw_1))"

}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3709" "until
            new_flap_count=\$(m_as ovn-gw-1 ovs-vsctl get interfac \$from_gw1_to_gw2 bfd_status | sed 's/.*flap_count=\\\"\\([0-9]*\\).*/\\1/g')
            echo \"Comparing \$new_flap_count versus \$flap_count_gw_1\"
            test \"\$new_flap_count\" -gt \"\$((flap_count_gw_1))\"
        "

    else
        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Waiting for flap count between gw2 and gw1 to increase ##
_ASBOX
        check_ovs_wait_until_args "1" ""
   ovs_wait_cond () {

            new_flap_count=$(m_as ovn-gw-2 ovs-vsctl get interfac $from_gw2_to_gw1 bfd_status | sed 's/.*flap_count=\"\([0-9]*\).*/\1/g')
            echo "Comparing $new_flap_count versus $flap_count_gw_2"
            test "$new_flap_count" -gt "$((flap_count_gw_2))"

}
ovs_wait_failed () {
    :

}
ovs_wait "multinode.at:3716" "until
            new_flap_count=\$(m_as ovn-gw-2 ovs-vsctl get interfac \$from_gw2_to_gw1 bfd_status | sed 's/.*flap_count=\\\"\\([0-9]*\\).*/\\1/g')
            echo \"Comparing \$new_flap_count versus \$flap_count_gw_2\"
            test \"\$new_flap_count\" -gt \"\$((flap_count_gw_2))\"
        "


    fi
    sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Flapped! ##
_ASBOX

    # Wait a few more second for the fight.
    sleep 2
    sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Statistics after flapping ##
_ASBOX
    dump_statistics

    if  test "$action" == "stop_bfd" ; then
        # gw1 still alive and gw2 tried to claim => gw1 should restart generating garps.
        check_for_new_garps gw1 "true"
        check_for_new_garps gw2 "false"
        check_for_new_garps gw3 "false"
        check_for_new_echo_pkts gw1 00:00:c0:a8:00:01 f0:00:c0:a8:00:fe "true"
        check_for_new_echo_pkts gw2 00:00:c0:a8:00:01 f0:00:c0:a8:00:fe "false"
        check_for_new_echo_pkts gw3 00:00:c0:a8:00:01 f0:00:c0:a8:00:fe "false"
        check_for_new_echo_pkts ch1 f0:00:c0:a8:01:fe f0:00:c0:a8:01:01 "true"
        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Unblocking bfd on gw1 ##
_ASBOX
        nsenter --net=/proc/$gw1_pid/ns/net nft -a list ruleset
        nsenter --net=/proc/$gw1_pid/ns/net nft delete table ip ovn-test
    fi

    if  test "$action" == "kill_gw2" ; then
        # gw1 still alive, but gw2 did not try to claim => gw1 should not generate new garps.
        check_for_new_garps gw1 "false"
        check_for_new_garps gw2 "false"
        check_for_new_garps gw3 "false"
        check_for_new_echo_pkts gw1 00:00:c0:a8:00:01 f0:00:c0:a8:00:fe "true"
        check_for_new_echo_pkts gw2 00:00:c0:a8:00:01 f0:00:c0:a8:00:fe "false"
        check_for_new_echo_pkts gw3 00:00:c0:a8:00:01 f0:00:c0:a8:00:fe "false"
        check_for_new_echo_pkts ch1 f0:00:c0:a8:01:fe f0:00:c0:a8:01:01 "true"
        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Restarting gw2 ovn-vswitchd ##
_ASBOX
        m_as ovn-gw-2 /usr/share/openvswitch/scripts/ovs-ctl start --system-id=ovn-gw-2

        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Restarting gw2 ovn-controller ##
_ASBOX
        m_as ovn-gw-2 /usr/share/ovn/scripts/ovn-ctl start_controller ${CONTROLLER_SSL_ARGS}
    fi

    if  test "$action" == "kill_gw1" ; then
        # gw1 died => gw2 should generate garps.
        check_for_new_garps gw1 "false"
        check_for_new_garps gw2 "true"
        check_for_new_garps gw3 "false"
        check_for_new_echo_pkts gw1 00:00:c0:a8:00:01 f0:00:c0:a8:00:fe "false"
        check_for_new_echo_pkts gw2 00:00:c0:a8:00:01 f0:00:c0:a8:00:fe "true"
        check_for_new_echo_pkts gw3 00:00:c0:a8:00:01 f0:00:c0:a8:00:fe "false"
        check_for_new_echo_pkts ch1 f0:00:c0:a8:01:fe f0:00:c0:a8:01:01 "true"
        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Restarting gw1 ovn-vswitchd ##
_ASBOX
        m_as ovn-gw-1 /usr/share/openvswitch/scripts/ovs-ctl start --system-id=ovn-gw-1

        sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Restarting gw1 ovn-controller ##
_ASBOX
        m_as ovn-gw-1 /usr/share/ovn/scripts/ovn-ctl start_controller ${CONTROLLER_SSL_ARGS}
    fi

    # The network is now restored => packets should go through gw1 and reach chassis-1.
    check_for_new_echo_pkts gw1 00:00:c0:a8:00:01 f0:00:c0:a8:00:fe "true"
    check_for_new_echo_pkts gw2 00:00:c0:a8:00:01 f0:00:c0:a8:00:fe "false"
    check_for_new_echo_pkts gw3 00:00:c0:a8:00:01 f0:00:c0:a8:00:fe "false"
    check_for_new_echo_pkts ch1 f0:00:c0:a8:01:fe f0:00:c0:a8:01:01 "true"
    sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Statistics after network restored ##
_ASBOX
    dump_statistics
    stop_sending_background_packets
}

start_tcpdump
sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Sending packet from hv1-vif1(inside1) to ext1 ##
_ASBOX
 { set +x
printf "%s\n" "$at_srcdir/multinode.at:3788: podman exec ovn-chassis-1 ip netns exec hv1-vif1 ping -c3 -q -i 0.1 192.168.0.1 | grep \"transmitted\" | sed 's/time.*ms\$/time 0ms/'"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:3788"
( $at_check_trace; podman exec ovn-chassis-1 ip netns exec hv1-vif1 ping -c3 -q -i 0.1 192.168.0.1 | grep "transmitted" | sed 's/time.*ms$/time 0ms/'
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "3 packets transmitted, 3 received, 0% packet loss, time 0ms
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:3788"
$at_failed && at_fn_log_failure
$at_traceon; }


stop_tcpdump

# It should have gone through gw1 and not gw2
sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $(date +%H:%M:%S.%03N) Checking it went through gw1 and not gw2 ##
_ASBOX
{ set +x
printf "%s\n" "$at_srcdir/multinode.at:3796: cat gw2.tcpdump | grep \"ICMP echo\""
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:3796"
( $at_check_trace; cat gw2.tcpdump | grep "ICMP echo"
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
at_fn_diff_devnull "$at_stdout" || at_failed=:
at_fn_check_status 1 $at_status "$at_srcdir/multinode.at:3796"
$at_failed && at_fn_log_failure
$at_traceon; }


{ set +x
printf "%s\n" "$at_srcdir/multinode.at:3799: cat gw1.tcpdump | grep \"ICMP echo\" | cut -d  ' ' -f2-15"
at_fn_check_prepare_notrace 'a shell pipeline' "multinode.at:3799"
( $at_check_trace; cat gw1.tcpdump | grep "ICMP echo" | cut -d  ' ' -f2-15
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
at_fn_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; printf "%s\n" "f0:00:c0:a8:00:fe > 00:00:c0:a8:00:01, ethertype IPv4 (0x0800), length 98: 192.168.1.1 > 192.168.0.1: ICMP echo request,
00:00:c0:a8:00:01 > f0:00:c0:a8:00:fe, ethertype IPv4 (0x0800), length 98: 192.168.0.1 > 192.168.1.1: ICMP echo reply,
f0:00:c0:a8:00:fe > 00:00:c0:a8:00:01, ethertype IPv4 (0x0800), length 98: 192.168.1.1 > 192.168.0.1: ICMP echo request,
00:00:c0:a8:00:01 > f0:00:c0:a8:00:fe, ethertype IPv4 (0x0800), length 98: 192.168.0.1 > 192.168.1.1: ICMP echo reply,
f0:00:c0:a8:00:fe > 00:00:c0:a8:00:01, ethertype IPv4 (0x0800), length 98: 192.168.1.1 > 192.168.0.1: ICMP echo request,
00:00:c0:a8:00:01 > f0:00:c0:a8:00:fe, ethertype IPv4 (0x0800), length 98: 192.168.0.1 > 192.168.1.1: ICMP echo reply,
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_fn_check_status 0 $at_status "$at_srcdir/multinode.at:3799"
$at_failed && at_fn_log_failure
$at_traceon; }


# We stop bfd between gw1 & gw2, but keep gw1 & gw2 running.
check_migration_between_gw1_and_gw2 "stop_bfd"

# We simulate death of gw2. It should not have any effect.
check_migration_between_gw1_and_gw2 "kill_gw2"

# We simulate death of gw1. gw2 should take over.
check_migration_between_gw1_and_gw2 "kill_gw1"

ovs_cleanup
  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_18
